myCurrentVersionData_xx_xx_xx = "21.04.2019";
var TellAboutDoTextOK = true; // объявляем переменную. Если она не объявлена, срабатывает команда alert в файле установок WordsAndUnits.jsx
var mySelection = app.selection[0];
try {
    var firstTest = app.selection[0].parentTextFrames[0];
}
catch (e) {
    if (myFastUsage == false && (mySelection == null || (mySelection.constructor.name != "Cell" && mySelection.constructor.name != "Table"))) {
        alert("Перед запуском скрипта выберите текст.", " Подготовка текста к вёрстке ");
        exit();
    }
}
//parseIntAppVersion = parseInt (app.version); 
var insertionPointIsActive = false;
//if (myFastUsage == false && mySelection.constructor.name == "InsertionPoint") insertionPointIsActive = true;
try { if (mySelection.constructor.name == "InsertionPoint") insertionPointIsActive = true; } catch (e) { }
var myParentPage;
try {
    if (parseIntAppVersion > 6) myParentPage = app.selection[0].parentTextFrames[0].parentPage;
    else myParentPage = app.selection[0].parentTextFrames[0].parent;
}
catch (e) { }
var myDocument = app.documents.item(0);
var myFirstCharStylename;
var myCurFileWordsAndUnits = "WordsAndUnits.jsx";
var myWordsAndUnitsiFile = myFile(myCurFileWordsAndUnits);
var myIniFile = new File(myWordsAndUnitsiFile);
if (myIniFile.exists) { // myIniFile.exists
    // прочитаем значения переменных из файла WordsAndUnits
    try {
        app.doScript(myIniFile);
    }
    catch (e) {
        alert("Синтаксическая ошибка в файле WordsAndUnits.jsx\n" + e.message);
        exit();
    }
} // myIniFile.exists 
else {
    alert("Не найден файл WordsAndUnits.jsx. Он должен быть в том же каталоге, где размещён этот скрипт.");
    exit();
}
try {
    var test = ScriptDate;
}
catch (e) {
    alert("В файле WordsAndUnits.jsx не найдена переменная ScriptDate с датой выпуска DoTextOK.\nПоследний выпуск скрипта датируется " + myCurrentVersionData_xx_xx_xx + ", соответственно и файл WordsAndUnits.jsx должен быть из того же архива обновления.");
    exit();
}
if (myCurrentVersionData_xx_xx_xx != ScriptDate) {
    alert("Даты одновлений файла WordsAndUnits.jsx и скрипта DoTextOK не совпали.\nФайл настроек датирован " + ScriptDate + ", скрипт DoTextOK — " + myCurrentVersionData_xx_xx_xx + ".\nНадо, чтобы и скрипт, и файл настроек были из одного архива обновления программы.");
    exit();
}
var DefSp = DefaultSpace;
var R = parseInt(Number(DefSp));
if (((R !== R) == true) || DefaultSpace > 10 || DefaultSpace < 0) DefSp = 1; // http://javascript.ru/isNaN -- тут найдена эта операция: (R !== R) == true.  Равенство true будет только в случае, когда DefSp не является числом, т.е. значение R равно NaN
var DefSpInDialog = DefaultSpaceInDialog;
var R = parseInt(Number(DefSpInDialog));
if (((R !== R) == true) || DefSpInDialog > 10 || DefSpInDialog < 0) DefSpInDialog = 9;
//////
if (parseIntAppVersion < 8)
    mySep = "\\s"
else
    mySep = "\\h";
////>>>> темный экран / светлый экран >>>>>
// defSelColor: цвет фона кнопки, когда в её пространстве окажется курсор. Первые три числа: RGB, 0 - мин, 1 - макс.
// defBgColor:  цвет, который приобретёт фон кнопки, когда курсор покинет её пространство.
try {
    var uiBr = app.generalPreferences.uiBrightnessPreference;
}
catch (e) { // до СС темного варианта интерфейса не было
    uiBr = 0.6;
}
if (uiBr == 1 || uiBr > 0.67) {
    defBgColor = [.85, .85, .85, 1]; defSelColor = [.15, .15, .15, 1];
}
else if (uiBr == 0.67 || uiBr > 0.33) {
    defBgColor = [.7, .7, .7, 1]; defSelColor = [.3, .3, .3, 1];
}
else if (uiBr == 0.33 || uiBr > 0) {
    defBgColor = [.34, .34, .34, 1]; defSelColor = [.66, .66, .66, 1];
}
else {
    /* if (uiBr == 0) */ defBgColor = [.2, .2, .2, 1]; defSelColor = [.8, .8, .8, 1];
}
////>>>> темный экран / светлый экран >>>>>

myLastSelectedCharIsLastCharOfStory = false;
var myDelEmptyPagesStatus;
// идея прогресс-бара взята отсюда: http://forums.adobe.com/message/3152162#3152162
var ProgressBar = function (title) { // ProgressBar
    var w = new Window('palette', title, { x: 0, y: 0, width: 700, height: 110 }, { closeButton: true }),
        tl = w.add('statictext', { x: 20, y: 12, width: 660, height: 20 });
    st = w.add('statictext', { x: 20, y: 32, width: 660, height: 20 });
    pb = w.add('progressbar', { x: 20, y: 52, width: 660, height: 12 }),
        ms = w.add('statictext', { x: 20, y: 72, width: 660, height: 20 });
    fc = w.add('statictext', { x: 20, y: 92, width: 660, height: 20 });
    st.justify = 'left';
    //if (File.fs == "Windows") os = true; else os = false; // вот такое решение проблемы пропадания прогресс-бара на маках: будем при каждой итерации обновлять экран              
    w.center();
    this.reset = function (msg, maxValue) {
        tl.text = "";
        st.text = msg;
        pb.value = 0;
        pb.maxvalue = maxValue;
        pb.visible = maxValue;
        //w.show();
        w.update();
    };
    this.info = function (msg) {
        ms.text = msg;
        //w.show();
        w.update();
    };
    this.fClr = function (aboutFormulaColor) {
        fc.text = aboutFormulaColor;
        //w.show();
        w.update();
    };
    this.sqn = function (msg) {
        tl.text = msg;
        //w.show();
        w.update();
    };
    this.set = function (step) { pb.value = step };
    this.hit = function () { ++pb.value; /*!os ? {} : */w.update(); };
    this.close = function () { w.close(); };
} // ProgressBar
////////////
function openInBrowser(/*str*/url) { // openInBrowser
    //--  http://forums.adobe.com/message/3181041#3181041
    var isMac = (File.fs == "Macintosh"), fName = 'tmp' + (+new Date()) + (isMac ? '.webloc' : '.url'), fCode = isMac ?
        ('<?xml version="1.0" encoding="UTF-8"?>\r' +
            '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" ' +
            '"http://www.apple.com/DTDs/PropertyList-1.0.dtd">\r' + '<plist version="1.0">\r' + '<dict>\r' +
            '\t<key>URL</key>\r' +
            '\t<string>%url%</string>\r' +
            '</dict>\r' +
            '</plist>') :
        '[InternetShortcut]\rURL=%url%\r';
    var f = new File(Folder.temp.absoluteURI + '/' + fName);
    if (!f.open('w')) return false;
    f.write(fCode.replace('%url%', url));
    f.close();
    f.execute();
    $.sleep(500);   // 500 ms timer
    f.remove();
    return true;
} // openInBrowser
////////

function main() {
    var pBar;
    var myProgramTitulWholeText = " Подготовка текста к вёрстке " + "(версия " + myCurrentVersionData_xx_xx_xx + " )";
    var myProgramTitulFragment = " Обработка фрагмента текста вёрстки  " + "(версия " + myCurrentVersionData_xx_xx_xx + " )";
    var myProgramTitul = myProgramTitulWholeText;
    var myBoldItalicIndexInfo = " Присвоение символьных стилей курсивным буквам, полужирным буквам, и индексам";
    //var MissedStories = [];
    var MustBeWith;
    var myCurrActionNumber = 0;
    var myNumberOfActions = 0;
    var myResetOrRename = 0;
    var myStyleIndex = 1;
    var mySpaceAfterTireInDialogIndex = 4;
    var myList;
    var mySpecialName;
    var myStartOfFragment = 0;
    var myEndOfFragment = 0;
    var myText;
    var myTextE;

    var footnoteOnlyProc;

    var mySpecFolderName;
    var mySearchMask;
    var ChistkaNow;
    var OformlNow;
    var PhoneNow;
    var QueryNow;
    var myFormulaToProcess_value = false;
    //var SetFontTypeInCharStyles_value = false;
    var myFormulaToProcessValue;
    var MathSignsAreTakedIntoAccountValue;
    var MathSignsAreTakedIntoAccount_value = true;
    var myMathSpaceIndex;
    var myNumberOfLockedStores = 0;
    //var myMathSpaceInfo_selection = myDefaultMathSpace;
    var myInfoAboutProcFormulasValue;
    var myInfoAboutProcFormulas_value = true;
    var myInfoAboutProcFormulasFromMenu;
    //~ var myMathProcSelectIndex;
    //~ var myMathProcSelectIndex_selection = 0;
    var MathSignsAreTakedIntoAccount_valueFromMenu;
    var myMathSpaceIndexFromMenu;
    //var SetFontTypeInCharStyles_valueFromMenu;
    //var myUsedMathSpace;
    //var myMathProcSelectIndexFromMenu;
    var myFormulaToProcessFromMenu;
    var CurrentQuery = "";
    var myRealDigitSeparator = "–";
    CurrentQuery_start = "В правой панели нет сохранённого набора запросов";
    var CurrentQueryInfo = CurrentQuery_start;
    var myFontList = [];
    myDefSetName = "#DoTextOK.dtok"
    myWhiteSpace = "\u00A0";
    HairSpace = "\u200A";
    myThinSpace = "\u2009";
    myNonBreakableSpaceVariableWidth = "\u00A0";
    myApostrof = "\u0027";
    myDefis = "\u002D";
    myTab = "\u0009"; //знак табуляции, другой вариант задания:  "^t"
    myChar0x2212 = "\u2212"; // это минус, "забытый" разработчиками раскладки русских букв. Он будет заменен на короткое тире, имеющееся во всех русских гарнитурах
    var myInfoColorSample = new Array;
    var myFoundSamples;
    var myCurFontStyle;
    var myCharInLine;
    // myInfoColorSample — шаблон цвета для myInfoColor
    myInfoColorSample = [0, 100, 100, 0];
    // myModifiedCharSample — шаблон цвета для mySepChar
    myModifiedCharSample = [0, 0, 0, 100];
    // myAccentedVocalsSample — шаблон цвета для myAccentedVocals
    myAccentedVocalsSample = [0, 100, 100, 0];
    //
    myFormulaToProcessSample = [100, 0, 100, 0];
    myProcessedFormulaSample = [0, 100, 50, 30];
    var myParaStyleNames = new Array;
    myMinusChar = "–";
    var myAllSpaces = ["Волосяная шпация",
        "Обычный пробел",
        "Неразрывный фиксированный пробел",
        "Неразрывный изменяемый пробел",
        "Шпация на 1/6 круглой",
        "Тонкая шпация",
        "Шпация на 1/4 круглой",
        "Шпация на 1/3 круглой",
        "Шпация на точку",
        "Полукруглая шпация",
        "Круглая шпация"];
    var myTwoSpaces = ["Неразрывный фиксированный пробел", "Неразрывный изменяемый пробел"];
    ///////////////////////////////////
    // Индексы массива myAllSpaces
    // "Волосяная шпация" = 0;
    // "Обычный пробел" = 1;
    // "Неразрывный фиксированный пробел" = 2;
    // "Неразрывный изменяемый пробел" = 3;
    // "Шпация на 1/6 круглой" = 4;
    // "Тонкая шпация" = 5;
    // "Шпация на 1/4 круглой"  = 6;
    // "Шпация на 1/3 круглой" = 7;
    // "Шпация на точку" = 8;
    // "Полукруглая шпация" = 9
    // "Круглая шпация" = 10
    /////////////////////////////////
    myDiscretionaryHyphen = "\u00AD";
    myNonbreakingHyphen = "\u2011";
    myWinWordHyphen = "\u00AC";
    myNonbreakingSpace = "~S";
    myNonbreakingSpaceFixedWidth = "~s";
    myThinSpace = "~<";
    myHairSpace = "~|";
    myFigureSpace = "~/";
    myPunctuationSpace = "~.";
    myThirdSpace = "~3";
    myQuarterSpace = "~4";
    mySixSpace = "~%";
    mySpace = " ";
    myNoSpace = "";
    myEnter = "\r";
    myShiftEnter = "\n";
    //myEnSpace = "\u2002";
    myEnSpace = "~>";
    myEmSpace = "~m";
    myDiscrLineBreak = "\u200B";
    myNeedToSaveDtokToo = false; // он будет установлен в true, если  решено сохранить перечень запросов и сами запросы
    ////////////
    BatchProcessingOK1 = true;
    BatchProcessingOK2 = true;
    var myMessageAboutQueryProcessingProblems = "\n\nНе найдены запросы:\n\n";
    myProblemsWithStartTextQueryProcessing = false;
    myProblemsWithStartGrepQueryProcessing = false;
    myProblemsWithFinishTextQueryProcessing = false;
    myProblemsWithFinishGrepQueryProcessing = false;

    var mySavedQueryList = new Array;
    var myQueCntr;
    var myAllSpacesValues = [myHairSpace,
        mySpace,
        myNonbreakingSpaceFixedWidth,
        myNonbreakingSpace,
        mySixSpace,
        myThinSpace,
        myQuarterSpace,
        myThirdSpace,
        myPunctuationSpace,
        myEnSpace,
        myEmSpace];
    var myTwoSpacesValues = [myNonbreakingSpaceFixedWidth, myNonbreakingSpace];
    //////////////////////////////////
    myMultipleReturn = "~b~b+";
    mySingleReturn = "\r";
    myMultipleSpaces = "[~m~>~f~|~S~s~<~/~.~3~4~% ]{2,}";
    myLineOfSpaces = "~m~>~f~|~S~s~<~/~.~3~4~% ";
    mySingleSpace = " ";
    myMultipleTabs = "[\t]{2,}";
    ///////////////////////////
    spaces_value_start = true;
    enters_value_start = true;
    shenters_value_start = false;
    myQuery_value_start = true;
    q_options_enabled_start = true;
    myJobCancelled = false;
    myClean_value_start = true;
    c_options_enabled_start = true;
    repChar_value_start = true;
    tabs2spaces_value_start = false;
    startTabs_value_start = false;
    hyphens_value_start = true;
    bull2text_value_start = true;
    charStyles_value_start = true;
    useUnderline_value_start = false;
    useCapslock_value_start = false;
    noParagraphs_value_start = true;
    digAndChar_value_start = true;
    oneStyle_value_start = false;
    setLang_value_start = false;
    myTypographica_value_start = true;
    t_options_enabled_start = true;////----
    hyplinks_value_start = false;
    scale100_value_start = true;
    fixOneLetter_value_start = true;
    fixTwoLetter_value_start = false;
    fixDigitAndWord_value_start = true;
    WordAndLetterSpace_value_start = true;
    nobreakSpace_value_start = nobreakSpaceState; // эта установка из файла WordsAndUnits.jsx
    nobreakSpace_value_start = false;
    commonTire_value_start = true;
    minus_value_start = true;
    myDPminus_value_start = false;
    tire_value_start = false;
    myDPtire_value_start = true;
    defis_value_start = false;
    myDPdefis_value_start = false;
    defisN_value_start = false;
    myDotOrWithout_value_start = true;//---
    mlnWithoutPoint_value_start = false;
    CurrSlitno_selection_start = 0;//---
    slitno_selection_start = 0;
    myFootnoteGroup_value_start = true;
    footnote1_value_start = true;
    mySpatium_value_start = true;
    s_options_enabled_start = true;////----
    //tireAndSpatium_value_start = true;
    tireAndSpatium_value_start = 1;
    spationsToSpace_value_start = 1;
    tireInDialog_value_start = true;
    //SetFontTypeInCharStyles_value_start = false;
    //mySpaceListBefore_selection_start = 3;
    mySpaceListBefore_selection_start = DefSp;
    ProcSpace_selection_start = 5;
    CurrSpace_selection_start = 5;
    TwoSpacesDrop_selection_start = 1;
    //mySpaceListAfter_selection_start = 1;
    mySpaceListAfter_selection_start = DefSp;
    spaceAfterTireInDialog_start = DefSpInDialog;
    commatire_value_start = true;
    myCommaAndTire_selection_start = 0;
    shortword_value_start = true;
    myShortWordSpace_selection_start = 0;
    initials_value_start = true;
    myASPushkinFirstSpace_selection_start = 5;
    myASPushkinSecondSpace_selection_start = 2;
    myPushkinASFirstSpace_selection_start = 2;
    myPushkinASSecondSpace_selection_start = 5;
    asPushkin_value_start = true;
    pushkinAS_value_start = true;
    myPhone_value_start = false;
    p_options_enabled_start = false; /// 5.1.2014
    mySlider_value_start = mySpaceScale;
    SepIsSpace_value_start = false;
    SepIsDefis_value_start = true;
    SepIsMinus_value_start = false;
    SepIsTire_value_start = false;
    SepIsDot_value_start = false;
    grekCharStyles_value_start = true;
    mySelectedQuotes_value_start = 0;
    setquotes_value_start = false;
    partHE_value_start = false;
    //myFootnoteGroup_value_start = true;
    myOneLineIsOneAbzatz_start = false;
    InTextSepIsSpace_value_start = false;
    InTextSepIsDash_value_start = true;
    InTextSepIsDot_value_start = false;
    my11D_value_start = false;
    myTelNumBreak_value_start = false;
    myTelNumberProcessing = false;
    //===
    var PlaceHolderForEnter = "*";
    ///===
    var spaces_value;
    var enters_value;
    var shenters_value;
    var InTextSepIsSpace_value;
    var InTextSepIsDash_value;
    var InTextSepIsDot_value;
    var myOneLineIsOneAbzatz_value;
    var myQuery_value;
    var myClean_value;
    var c_options_enabled;
    var repChar_value;
    var tabs2spaces_value;
    var startTabs_value;
    var hyphens_value;
    var bull2text_value;
    var charStyles_value;
    var useUnderline_value;
    var useCapslock_value;
    var noParagraphs_value;
    var digAndChar_value;
    var oneStyle_value = "";
    var setLang_value;
    var myTypographica_value;
    var t_options_enabled;////----
    var hyplinks_value;
    var scale100_value;
    var fixOneLetter_value;
    var fixTwoLetter_value;
    var fixDigitAndWord_value;
    var WordAndLetterSpace_value;
    var nobreakSpace_value;
    var commonTire_value;
    var minus_value;
    var tire_value;
    var myDPminus_value;
    var myDPtire_value;
    var defis_value;
    var myDPdefis_value;
    var defisN_value;
    var myDotOrWithout_value;//---
    var mlnWithoutPoint_value;
    var myFootnoteGroup_value;
    var grekCharStyles_value;
    var slitno_selection;
    var CurrSlitno_selection;
    var footnote1_value;
    var mySpatium_value;
    var s_options_enabled;////----
    var tireAndSpatium_value;
    var spationsToSpace_value;
    var tireInDialog_value;
    var mySpaceListBefore_selection;
    var CurrSpace_selection;
    var ProcSpace_selection;
    var TwoSpacesDrop_selection;
    var mySpaceListAfter_selection;
    var commatire_value;
    var myCommaAndTire_selection;
    var shortword_value;
    var myShortWordSpace_selection;
    var initials_value;
    var asPushkin_value;
    var asPushkin_state;
    var pushkinAS_value;
    var pushkinAS_state;
    var myASPushkinFirstSpace_selection;
    var myASPushkinSecondSpace_selection;
    var myPushkinASFirstSpace_selection;
    var myPushkinASSecondSpace_selection;
    var myPhone_value;
    var p_options_enabled;
    var myPrevSelectedStyle;
    var mySlider_value;
    var SepIsSpace_value;
    var SepIsDefis_value;
    var SepIsMinus_value;
    var SepIsTire_value;
    var SepIsDot_value;
    var mySelectedQuotes_value;
    var setquotes_value;
    var partHE_value;
    var my11D_value;
    var myTelNumBreak_value;
    var myLanguageList_selection = 0;
    ////===================
    // Переменные, отражающие выбранные параметры работы скрипта
    // если переменная равна 2, значит, этот параметр сейчас исключён из рассмотрения. (использовалось при отладке)
    // 1 означает, что флажок установлен, 0 -- сброшен
    var myCleanValueFromMenu;
    var repCharFromMenu;
    var tabs2spacesFromMenu;
    var startTabsFromMenu;
    var hyphensFromMenu;
    var bull2textFromMenu;
    var charStylesFromMenu;
    var useUnderlineFromMenu;
    var useCapslockFromMenu;
    var noParagraphsFromMenu;
    var grekCharStylesFromMenu;
    var digAndCharFromMenu;
    var setLangFromMenu;
    var myTypographicaValueFromMenu;
    var hyplinksFromMenu;
    var scale100FromMenu;
    var fixOneLetterFromMenu;
    var fixTwoLetterFromMenu;
    var fixDigitAndWordFromMenu;
    var WordAndLetterSpaceFromMenu;
    var nobreakSpaceFromMenu;
    var commonTireFromMenu;
    var minusFromMenu;
    var tireFromMenu;
    var defisFromMenu;
    var myDPminusFromMenu;
    var myDPtireFromMenu;
    var partHEFromMenu;
    var myDPdefisFromMenu;
    var defisNFromMenu;
    var mlnWithoutPointFromMenu;
    var slitnoFromMenu;
    var CurrSlitnoFromMenu;
    var footnote1FromMenu;
    var ParaIndexFromMenu;
    var tireAndSpatiumFromMenu;
    var spationsToSpaceFromMenu;
    var mySpaceListBeforeFromMenu; // index
    var mySpaceListAfterFromMenu;  // index
    var TwoSpacesDropFromMenu;  // index
    var ProcSpaceFromMenu;  // index
    var CurrSpaceFromMenu;  // index
    var commatireFromMenu;
    var myCommaAndTireFromMenu;  // index
    var shortwordFromMenu;
    var myShortWordSpaceFromMenu; // index
    var initialsFromMenu;
    var myASPushkinFirstSpaceFromMenu; // index
    var myASPushkinSecondSpaceFromMenu; // index
    var myPushkinASFirstSpaceFromMenu;  // index
    var myPushkinASSecondSpaceFromMenu;  // index
    var mySelectedQuotesFromNenu; // index
    var mySliderValueFromMenu;
    var InTextSepIsSpaceFromMenu;
    var InTextSepIsDashFromMenu;
    var InTextSepIsDotFromMenu;
    var SepIsSpaceFromMenu;
    var SepIsDefisFromMenu;
    var SepIsMinusFromMenu;
    var SepIsTireFromMenu;
    var SepIsDotFromMenu;
    var mySpatiumValueFromMenu;
    var myPhoneValueFromMenu;
    var myOneLineIsOneAbzatzFromMenu;
    var my11DFromMenu;
    var myTelNumBreakFromMenu;
    var myQueryValueFromMenu;
    var asPushkinFromMenu;
    var pushkinASFromMenu;
    var mySpaceAfterTireInDialogFromMenu;
    //var myCurFileWordsAndUnits = "WordsAndUnits.jsx";
    ///////////
    var selStory;
    var setsFromParaFromMenu;
    var procEndnotesFromMenu = false;

    var enOptions;
    var fnOptions;

    var pS;
    var nS;
    var signCharStyle;
    var infoString;
    var delimiter;
    var delimiterText;

    var pS_e;
    var nS_e;
    var signCharStyle_e;
    var delimiter_e;
    var delimiterText_e;

    var fnOptions_separatorText; // шпация между символом внутритекстовой сноски и текстом
    var fnOptions_footnoteMarkerStyle; // символьный стиль знака внутритекстовой сноски
    var fnOptions_footnoteTextStyle; // абзацный стиль знака внутритекстовой сноски

    var enOptions_endnoteSeparatorText; // шпация между символом концевой сноски и текстом
    var enOptions_endnoteMarkerStyle; // символьный стиль знака концевой сноски
    var enOptions_endnoteTextStyle; // абзацный стиль знака концевой сноски

    var infoString = "";
    var usedSpace = [];
    usedSpace["TABS"] = "^t";
    usedSpace["EN_SPACE"] = "^>";
    usedSpace["EM_SPACE"] = "^m";
    usedSpace["NONBREAKING_SPACE"] = "^S";

    var usedSpaceValue = [];
    usedSpaceValue["TABS"] = "\u0009";
    usedSpaceValue["EN_SPACE"] = "\u2002";
    usedSpaceValue["EM_SPACE"] = "\u2003";
    usedSpaceValue["NONBREAKING_SPACE"] = "\u00A0";

    messAboutFnAndEn = "Предполагается, что для разделителя знака внутритекстовой сноски и текста из выпадающего меню в строке настроек 'Буквицы и вложенные стили' будет выбран один из четырёх вариантов: 'Символы табуляции', 'Неразрывные пробелы', 'Круглые шпации', 'Полукруглые шпации'. Это условие не выполнено.";
    messAboutFnAndEn_e = "Предполагается, что для разделителя знака концевой сноски и текста из выпадающего меню в строке настроек 'Буквицы и вложенные стили' будет выбран один из четырёх вариантов: 'Символы табуляции', 'Неразрывные пробелы', 'Круглые шпации', 'Полукруглые шпации'. Это условие не выполнено.";
    messNoNestStyle_f = "Абзацный стиль знака внутритекстовой сноски должен иметь по крайней мере один вложенный стиль, а тут нет ни одного.";
    messNoNestStyle_e = "Абзацный стиль знака внутритекстовой сноски должен иметь по крайней мере один вложенный стиль, а тут нет ни одного.";
    utochnenie = ".\rУточнение 'специальный пользовательский' означает следующее:\r1) оформление знака сноски определяется символьным стилем из первой строки настроек 'Буквицы и вложенные стили' в параметрах стиля абзаца;\r2) в той же строке определяется один из стандартных вариантов разделителя. Это может быть табуляция, полукруглая шпация, круглая шпация или неразрывный пробел; \r3) предполагается, что для оформления второго и всех последующих абзацев в многоабзацных сносок подготовлен абазацный стиль, и он указан в параметрах стиля абзаца как следуюший стиль.\rОтмените обработку файла, подготовьте стили для обычных и концевых сносок, если они есть, поместите нужный стиль в поле 'Стиль абзаца' и запустите обработку снова.";

    var haveFootnotes = false;
    var haveEndnotes = false;

    ////======
    var myQuote = 222; // если в обрабатываемом тексте больше абзацев, чем эта квота, текст делится на части, кратные этому числу
    var myParaLength;
    var myFirstProcessedPara, myLastProcessedPara;
    var myRatio;
    var myProcSteps;
    var myProcText;
    var myProcBreak = false;
    var myIncrement;
    var lineForSpatios = "Заменить шпации на обычные пробелы";
    var lineForSpaces = "Изменить ширину пробелов";
    var curLineAboutSpaces = "";
    /////////////////////////////
    // шрифт диалогов
    var dialogFont = File.fs == "Macintosh" ? "Lucida Grande" : "Verdana";
    ///////////////////////////////////
    if (myDocument.activeLayer.locked == true || myDocument.activeLayer.visible == false) { // locked or notvisible
        alert("При запуске скрипта должен быть выбран видимый незаблокированный слой.\nАктивный сейчас слой '" + myDocument.activeLayer.name + "' не отвечает этому требованию.", myProgramTitul);
        exit();
    } // locked or notvisible
    myDelEmptyPagesStatus = myDocument.textPreferences.deleteEmptyPages;
    var myMathSpaceInfo_selection = myDefaultMathSpace;
    var mySpecialChar = myGrecDeuSpecChars; // греческие буквы от альфы до омеги и немецкие буквы α-ω,ä,ö,ü,Ä,Ö,Ü,ß,¼,½,¾ в гарнитуре Times New Roman, и знаки дробей
    var mySpecialChar_start = myGrecDeuSpecChars;
    var myTF = myDocument.stories[0].insertionPoints[0].parentTextFrames[0];
    var myTC = myDocument.stories[0].textContainers[0];
    var SingleStory = true;
    var TmpHaveNonJoiner = 0;
    var TmpHaveNotNonJoiner = 0;
    var EmptyOrMasterspreadStories = 0;
    var LockedOrHiddenLayerStories = 0;
    var ShowProgressbarSingleStory = true;
    if (myFastUsage == true && mySelection == undefined) { // myFastUsage == true && mySelection == undefined    
        // выясним степень готовности групповой обработки документа 
        ShowProgressbarSingleStory = false;
        var WrongState = 0;
        for (var s = 0; s < myDocument.stories.length; s++) { //# s++     
            try { if (myDocument.stories[s].lockState != LockStateValues.NONE) WrongState++; } catch (e) { }
        } //# s++ 
        for (var s = 0; s < myDocument.stories.length; s++) { //// s++ 
            //if (parseIntAppVersion > 6) if (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState == LockStateValues.CHECKED_IN_STORY || myDocument.stories[s].lockState == LockStateValues.LOCKED_STORY || (myDocument.stories[s].textContainers[0].parentPage == null && myDocument.stories[s].textContainers[0].locked)) { EmptyOrMasterspreadStories++; continue; }
            //            if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath"  || myDocument.stories[s].textContainers[0].parentPage == null) continue;
            if (parseIntAppVersion > 6) if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
            if (parseIntAppVersion == 6) if (myDocument.stories[s].textContainers[0].parent.constructor.name == "Spread" || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread") continue;
            if (myDocument.stories[s].textContainers[0].locked == true || myDocument.stories[s].textContainers[0].itemLayer.locked == true || myDocument.stories[s].textContainers[0].itemLayer.visible == false) { LockedOrHiddenLayerStories++; continue; } // статьи на блокированных или скрытых слоях не обрабатываются
            if (parseIntAppVersion > 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) { EmptyOrMasterspreadStories++; continue; }
            if (parseIntAppVersion == 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) { EmptyOrMasterspreadStories++; continue; }
            // Теооретически, в предыдущей строке достаточно myDocument.stories[s].textContainers[0].parent.constructor.name == "MasterSpread". Но если на мастер-странице есть привязанный текстовый фрейм, этой строки недостаточно, т.к. myDocument.stories[s].textContainers[0].parent.constructor.name вернёт значение Character.
            // И только myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name и для обычных текстовых фреймов на мастер-странице, и для привязанных, будет возвращать MasterSpread
            if (myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER) TmpHaveNonJoiner++;
            else TmpHaveNotNonJoiner++;
        } /// s++
        if (myDocument.stories.length == EmptyOrMasterspreadStories + LockedOrHiddenLayerStories) { // myDocument.stories.length == EmptyOrMasterspreadStories
            alert("В документе нет статей c текстом на страницах вёрстки,\nа содержимое фреймов мастер-страниц, блокированных фреймов и фреймов на блокированных или скрытых слоях в режиме обработки всех статей документа не проверяется.", myProgramTitul);
            exit();
        } // myDocument.stories.length == EmptyOrMasterspreadStories
        var TextAboutAction = "+";
        var StateOfStoriesProcesing1 = "Обработка всех статей документа.";
        var StateOfStoriesProcesing2 = "Обработано " + String(TmpHaveNonJoiner) + ", осталось обработать " + String(TmpHaveNotNonJoiner) + ".";
        if (WrongState > 0) { // WrongState > 0
            var StateOfStoriesProcesing3 = "В документе встречены статьи, отданные на обработку в программе InCopy.";
            var StateOfStoriesProcesing4 = "Число таких статей " + String(WrongState) + ", информация о них собрана в панели 'Подборки' ('Assignments').";
            var StateOfStoriesProcesing5 = "Эти тексты будут исключены из групповой обработки статей.";
        } // WrongState > 0    
        if (TmpHaveNonJoiner == 0) { // TmpHaveNonJoiner == 0
            StateOfStoriesProcesing1 = "Обработка всех статей документа, всего их " + String(myDocument.stories.length) + ".";
            StateOfStoriesProcesing2 = "Возможно, в процессе обработки потребуется запускать скрипт несколько раз.";
            TextAboutAction = "*";
        } // TmpHaveNonJoiner == 0
        var SuperFastProc = null;
        SuperFastProc = NewPrompt(TextAboutAction, myProgramTitulWholeText, SuperFastProc, WrongState, StateOfStoriesProcesing1, StateOfStoriesProcesing2, StateOfStoriesProcesing3, StateOfStoriesProcesing4, StateOfStoriesProcesing5);
        if (SuperFastProc == null) exit();
        if (SuperFastProc == '+') { // +
            EmptyOrMasterspreadStories = 0;
            LockedOrHiddenLayerStories = 0;
            for (var s = 0; s < myDocument.stories.length; s++) { //// s++ 
                //if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath"  || myDocument.stories[s].textContainers[0].parentPage == null) continue;
                if (parseIntAppVersion > 6) if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
                if (parseIntAppVersion == 6) if (myDocument.stories[s].textContainers[0].parent.constructor.name == "Spread" || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread") continue;
                if (myDocument.stories[s].textContainers[0].locked == true || myDocument.stories[s].textContainers[0].itemLayer.locked == true || myDocument.stories[s].textContainers[0].itemLayer.visible == false) { LockedOrHiddenLayerStories++; continue; } // статьи в блокированных фреймах на блокированных или скрытых слоях не обрабатываются
                if (parseIntAppVersion > 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) { EmptyOrMasterspreadStories++; continue; }
                if (parseIntAppVersion == 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) { EmptyOrMasterspreadStories++; continue; }
                if (myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER) myDocument.stories[s].characters[-1].remove();
            } //// s++
        } // +
        SingleStory = false;
    } // myFastUsage == true && mySelection == undefined
    if (ShowProgressbarSingleStory == true) pBar = new ProgressBar(myProgramTitul); // это прогресс-бар для обработки отдельных статей
    if (myDocument.stories.length == EmptyOrMasterspreadStories + LockedOrHiddenLayerStories) { // myDocument.stories.length == EmptyOrMasterspreadStories
        alert("В документе нет статей c текстом на страницах вёрстки,\nа содержимое фреймов мастер-страниц, блокированных фреймов и фреймов на блокированных или скрытых слоях в режиме обработки всех статей документа не проверяется.", myProgramTitul);
        exit();
    } // myDocument.stories.length == EmptyOrMasterspreadStories
    if (SingleStory == true) { // SingleStory == true
        if (mySelection == undefined || (mySelection.parent.constructor.name != "Story" && mySelection.parent.constructor.name != "Footnote" && mySelection.parent.constructor.name != "Table" && mySelection.parent.constructor.name != "Cell")) {
            alert("Перед запуском программы поставьте курсор в текст для подготовки всей статьи к вёрстке.\nВыделите часть текста для проверки только её.\nДля обработки только таблицы достаточно поместить курсор в ячейку.\nТаблица обрабатывается только целиком,\nобработки одной ячейки не предусмотрено.\n\nЕсли хотите обработать за один раз все статьи документа,\nзапустите вариант скрипта [Use Current Set],\nно перед запуском ничего не должно быть выбрано.", myProgramTitul);
            exit();
        }
        if ((mySelection.parent.constructor.name == "Story" || mySelection.parent.constructor.name == "Footnote") && (InCopyIsUsed == true && mySelection.parent.lockState == LockStateValues.CHECKED_IN_STORY)) { // == LockStateValues.CHECKED_IN_STORY
            alert("Приведение вёрстки в порядок предполагает внесение исправлений в вёрстку. Но у выбранной статьи установлен указатель, извещающий, что в него вносить правку нельзя, возможно, у неё сейчас состояние 'Редактирование в программе InCopy'.\nВизуально статус всех статей отображается в панели 'Окно>Правка>Подборки' (Window>Editorial>Assignments).", myProgramTitul);
            exit();
        } // == LockStateValues.CHECKED_IN_STORY  
        a = 0;
        //~         if (app.selection[0].parentTextFrames[0].constructor.name != "TextFrame") { //  constructor.name != "TextFrame"
        //~             alert("Текст, размещенный на контуре объекта или линии, этой программой не обрабатывается.\nЕго можно проверить визуально.\nПри обработке всех статей за один раз такие тексты будут пропущены.",myProgramTitul); 
        //~             exit();              
        //~             } // constructor.name != "TextFrame"
        try {
            if (app.selection[0].parentTextFrames[0].constructor.name == "TextPath") { //  constructor.name == "TextPath"
                alert("Текст, размещенный на контуре объекта или линии, этой программой не обрабатывается.\nЕго можно проверить визуально.\nПри обработке всех статей за один раз такие тексты будут пропущены.", myProgramTitul);
                exit();
            } // constructor.name == "TextPath"
        }
        catch (e) { }
    } // SingleStory == true
    var myZoom = app.documents[0].layoutWindows[0].zoomPercentage;
    if (mySelection != undefined) { // mySelection != undefined
        if (mySelection.parent.constructor.name != "Story" && mySelection.parent.constructor.name != "Footnote") { // это таблица
            var myStartNmr = 0;
            //~        var SelectionInTable = false;
            //~         if (mySelection.constructor.name == "Table") { mySelection.storyOffset.select(); myStartNmr = mySelection.storyOffset.index; SelectionInTable = true; }
            //~         if (mySelection.parent.constructor.name == "Table") { mySelection.parent.storyOffset.select(); myStartNmr = mySelection.parent.storyOffset.index;  SelectionInTable = true; }
            //~         if (mySelection.parent.parent.constructor.name == "Table") { mySelection.parent.parent.storyOffset.select(); myStartNmr = mySelection.parent.parent.storyOffset.index;  SelectionInTable = true;}
            if (mySelection.constructor.name == "Table") { mySelection.storyOffset.select(); myStartNmr = mySelection.storyOffset.index; }
            if (mySelection.parent.constructor.name == "Table") { mySelection.parent.storyOffset.select(); myStartNmr = mySelection.parent.storyOffset.index; }
            if (mySelection.parent.parent.constructor.name == "Table") { mySelection.parent.parent.storyOffset.select(); myStartNmr = mySelection.parent.parent.storyOffset.index; }
            mySelection = app.selection[0];
            mySelection.parent.characters.itemByRange(myStartNmr, myStartNmr).select();
            var myStory = mySelection.parentStory;
            //       if ( SelectionInTable == true) { // SelectionInTable == true
            myStartOfFragment = mySelection.paragraphs[0].characters.firstItem().index;
            myEndOfFragment = mySelection.paragraphs[mySelection.paragraphs.length - 1].characters.lastItem().index;
            //          } // SelectionInTable == true
            //~         else {
            //~                myStartOfFragment = mySelection.characters.firstItem().index;
            //~                myEndOfFragment = mySelection.characters.lastItem().index; 
            //~                }
            myIndxStart = myStartOfFragment;
            myFragment = true;
            myProgramTitul = myProgramTitulFragment;
            mySelection.parent.characters.itemByRange(myStartOfFragment, myEndOfFragment).select();
        } // это таблица
        else { // курсор в тексте статьи или в сноске
            var myStory = mySelection.parentStory;
            if (mySelection.parent.constructor.name == "Footnote") { // == "Footnote"
                try { while (mySelection.parent.characters[-1].contents == myEnter) mySelection.parent.characters.lastItem().remove(); } catch (e) { }
                // mySelection.parent.characters.itemByRange(0,-1).select();
                mySelection = app.selection[0];
            } // == "Footnote"
            var myCharsOrig = mySelection.characters.length;
            var myParsOrig = mySelection.paragraphs.length;
            if (myStory.characters.length <= 1) { // 0 - ничего нет. 1 - только один знак перевода строки
                alert("В фрейме текста нет.\n", myProgramTitul);
                exit();
            } //0	
            if (myCharsOrig == 0) { // myCharsOrig == 0   // не выделен ни один символ, значит, обрабатывается вся статья
                myText = myStory;
                var myCharsOrig = myStory.characters.length;
                var myParsOrig = myStory.paragraphs.length;
                myIndxStart = 0;
                myFragment = false;
                myProgramTitul = myProgramTitulWholeText;
                myStartOfFragment = 0;
                myEndOfFragment = myStory.length - 1;
                myLastSelectedCharIsLastCharOfStory = true;
            } //myCharsOrig == 0
            else { // myCharsOrig != 0
                //~ //		расширим выделенную область до кратности абзацам
                //~ 		myStartOfFragment = mySelection.paragraphs[0].characters.firstItem().index;
                //~ 		myEndOfFragment = mySelection.paragraphs[mySelection.paragraphs.length - 1].characters.lastItem().index;
                //~ 		myIndxStart = myStartOfFragment;
                myFragment = true;
                myProgramTitul = myProgramTitulFragment;
                myStartOfFragment = mySelection.characters.firstItem().index;
                if (myStartOfFragment != myStory.characters[0].index && (myStory.characters[myStartOfFragment].contents == "\r" || myStory.characters[myStartOfFragment].contents == "\n") && myStory.characters[myStartOfFragment].paragraphs[0].contents.length > 1) myStartOfFragment++; // не должен перевод строки предыдущего абзаца быть в выборке на обработку
                // myStory.characters[myStartOfFragment].paragraphs[0].contents.length == 1 -- в случае, когда есть только один перевод строки; >1 -- когда в этом абзаце что-то есть. Эта проверка позволяет удалять пустые абзацы в начале области выделения, но исключит из обработки абзац, у которого только знак перевода строки попал в выборку на обработку.
                myIndxStart = myStartOfFragment;
                myEndOfFragment = mySelection.characters.lastItem().index;
                if (myEndOfFragment == myStory.characters[-1].index) myLastSelectedCharIsLastCharOfStory = true; // в фрагмент выборки попал конец статьи
                else if (myStory.characters[myEndOfFragment].contents == "\r" || myStory.characters[myEndOfFragment].contents == "\n") myEndOfFragment--;  // не должен перевод строки последнего абзаца быть в выборке на обработку. Если его оставить, то последний выделенный абзац подхватит оформление того абзаца, что идёт за ним. А это совсем не нужно.
                mySelection.parent.characters.itemByRange(myStartOfFragment, myEndOfFragment).select();
            } // myCharsOrig != 0
        } // курсор в тексте статьи или в сноске    
    }  // mySelection != undefined
    // #DoTextOK.dtok - основной файл обработки текста
    a = 0;
    //app.findChangeGrepOptions.includeFootnotes = true;
    app.findGrepPreferences = NothingEnum.nothing;
    app.changeGrepPreferences = NothingEnum.nothing;
    //~ app.findGrepPreferences.findWhat="\\x{FFFD}"; // ищем символ потерянной сноски 
    //~ var missedFootnotesSigns = mySelection.parent.findGrep();
    var missedFootnotesSigns;
    if (SingleStory) { // SingleStory
        app.findChangeTextOptions.includeFootnotes = true;
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = "<FFFD>"; // ищем символ потерянной сноски 
        if (mySelection.parent.constructor.name == "Story") missedFootnotesSigns = mySelection.parent.findText();
        else if (mySelection.parent.constructor.name == "Footnote") missedFootnotesSigns = mySelection.parent.parent.findText();
    } // SingleStory
    var mySetFile;
    var myScriptFile = myGetScriptPath();
    var myScriptFolder = decodeURI(myScriptFile.path);
    var myFilePath = decodeURI(myScriptFolder + "/" + myDefSetName); // myDefSetName = #DoTextOK.dtok
    var mySetInfoFile = new File(myFilePath);
    myScrFolder = new Folder(myScriptFile.path);
    if (myFastUsage == true || myEditCurSet == true) mySearchMask = myDefSetName;
    else mySearchMask = "*.dtok";
    var myDoTextOKList = myScrFolder.getFiles(mySearchMask);
    if (myDoTextOKList.length == 0) { // первый запуск. нет ни одного файла настроек
        mySetFile = mySetInfoFile;
    } //  первый запуск. нет ни одного файла настроек
    if (myDoTextOKList.length == 1) { //  == 1 
        mySetFile = myDoTextOKList[0];
    } //  == 1
    if (myDoTextOKList.length > 1) { // > 1
        var mySetFile = File(myFilePath).openDlg('Файлы установок обработки текста скриптом DoTextOK', 'dtok: *.dtok');
        if (mySetFile == null) { mySetFile = mySetInfoFile; }
    } // > 1
    var myArrForSplit = [];
    myArrForSplit = decodeURI(mySetFile).split("/");
    var myParaFileName = myArrForSplit[myArrForSplit.length - 1];
    if (myParaFileName != myDefSetName) myResetOrRename = 3; // = 3 для отображения названия файла настроек в строке сразу под временем обработки. Длина имени этого файла может быть длинее стандартного #DoTextOK.dtok
    if (mySetFile.exists) { //File.exists
        mySetFile.open("r");
        myClean_value = mySetFile.readln();
        c_options_enabled = mySetFile.readln();
        repChar_value = mySetFile.readln();
        tabs2spaces_value = mySetFile.readln();
        hyphens_value = mySetFile.readln();
        bull2text_value = mySetFile.readln();
        charStyles_value = mySetFile.readln();
        digAndChar_value = mySetFile.readln();
        setLang_value = mySetFile.readln();
        myTypographica_value = mySetFile.readln();
        t_options_enabled = mySetFile.readln();
        hyplinks_value = mySetFile.readln();
        fixOneLetter_value = mySetFile.readln();
        fixTwoLetter_value = mySetFile.readln();
        fixDigitAndWord_value = mySetFile.readln();
        commonTire_value = mySetFile.readln();
        minus_value = mySetFile.readln();
        mlnWithoutPoint_value = mySetFile.readln();
        slitno_selection = mySetFile.readln();
        myFootnoteGroup_value = mySetFile.readln();
        footnote1_value = mySetFile.readln();
        myPrevSelectedStyle = mySetFile.readln();
        mySpatium_value = mySetFile.readln();
        s_options_enabled = mySetFile.readln();
        tireAndSpatium_value = mySetFile.readln();
        mySpaceListBefore_selection = mySetFile.readln();
        mySpaceListAfter_selection = mySetFile.readln();
        mySlider_value = mySetFile.readln();
        commatire_value = mySetFile.readln();
        myCommaAndTire_selection = mySetFile.readln();
        grekCharStyles_value = mySetFile.readln();
        shortword_value = mySetFile.readln();
        myShortWordSpace_selection = mySetFile.readln();
        initials_value = mySetFile.readln();
        asPushkin_value = mySetFile.readln();
        asPushkin_state = mySetFile.readln();
        pushkinAS_value = mySetFile.readln();
        pushkinAS_state = mySetFile.readln();
        myASPushkinFirstSpace_selection = mySetFile.readln();
        myASPushkinSecondSpace_selection = mySetFile.readln();
        myPushkinASFirstSpace_selection = mySetFile.readln();
        myPushkinASSecondSpace_selection = mySetFile.readln();
        setquotes_value = mySetFile.readln();
        // 18.10.2013 -- пока оставлю чтение строки mySpecCharLine исключительно радо того, чтобы не нарушить очередность считывания и записи установок. Но теперь она определяется только в файле WordsAndUnits.jsx. Возможность установки в скрипте исключена.
        var myUniLine = mySetFile.readln(); // считана строка в записи данных формате юникод. Значения разделены запятой
        // Теперь их надо из текстового вида перевести в знаковый и поместить в mySpecialChar 
        var myUniArr = [];
        myUniArr = myUniLine.split(',');
        var myNewCharLine = "";
        for (j = 0; j < myUniArr.length; j++) { ///
            myNewCharLine += String.fromCharCode(myUniArr[j]);
        } ///
        //mySpecialChar = myNewCharLine; // ранее в эту переменную уже помещена строка myGrecDeuSpecChars из файла WordsAndUnits.jsx.
        myPhone_value = mySetFile.readln();
        p_options_value = mySetFile.readln();
        SepIsSpace_value = mySetFile.readln();
        SepIsDefis_value = mySetFile.readln();
        SepIsMinus_value = mySetFile.readln();
        SepIsTire_value = mySetFile.readln();
        SepIsDot_value = mySetFile.readln();
        myOneLineIsOneAbzatz_value = mySetFile.readln();
        InTextSepIsSpace_value = mySetFile.readln();
        InTextSepIsDash_value = mySetFile.readln();
        InTextSepIsDot_value = mySetFile.readln();
        my11D_value = mySetFile.readln();
        myTelNumBreak_value = mySetFile.readln();
        myQuery_value = mySetFile.readln();
        //q_options_enabled = mySetFile.readln();
        myQueCntr = mySetFile.readln();
        for (i = 0; i < myQueCntr; i++) mySavedQueryList[i] = mySetFile.readln();
        // 27.12.2013 - добавим чтение двух новых флажков
        spaces_value = mySetFile.readln();
        enters_value = mySetFile.readln();
        shenters_value = mySetFile.readln();
        CurrentQuery = mySetFile.readln();
        noParagraphs_value = mySetFile.readln();
        myLanguageList_selection = mySetFile.readln();
        MathSignsAreTakedIntoAccountValue = mySetFile.readln();
        myMathSpaceIndex = mySetFile.readln();
        myInfoAboutProcFormulasValue = mySetFile.readln();
        oneStyle_value = mySetFile.readln();
        tire_value = mySetFile.readln();
        defis_value = mySetFile.readln();
        defisN_value = mySetFile.readln();
        TwoSpacesDrop_selection = mySetFile.readln();
        ProcSpace_selection = mySetFile.readln();
        CurrSlitno_selection = mySetFile.readln();
        CurrSpace_selection = mySetFile.readln();
        mySpaceAfterTireInDialogIndex = mySetFile.readln();
        scale100_value = mySetFile.readln();
        WordAndLetterSpace_value = mySetFile.readln();
        nobreakSpace_value = mySetFile.readln();
        spationsToSpace_value = mySetFile.readln();
        //SetFontTypeInCharStyles_value = mySetFile.readln();    
        useUnderline_value = mySetFile.readln();
        useCapslock_value = mySetFile.readln();
        startTabs_value = mySetFile.readln();
        myDPdefis_value = mySetFile.readln();
        myDPminus_value = mySetFile.readln();
        myDPtire_value = mySetFile.readln();
        partHE_value = mySetFile.readln();
        mySetFile.close();
    } // File exists
    else mySetDefaultValues();  // не найден файл с установками
    if (ShowProgressbarSingleStory == false && myOneLineIsOneAbzatz_value == 1) { // myOneLineIsOneAbzatz.value
        alert("При установленном флажке «Текст в формате 'одна строка - один абзац'» все статьи за один раз не обрабатываются.", myProgramTitul);
        exit();
    } // myOneLineIsOneAbzatz.value 
    /////////////////
    // *** выбор параметров замены ***
    var myCleanValue;
    myClean_value == true ? myCleanValue = 1 : myCleanValue = 0;
    var myTypoValue;
    myTypographica_value == true ? myTypoValue = 1 : myTypoValue = 0;
    var mySpatiumValue;
    mySpatium_value == true ? mySpatiumValue = 1 : mySpatiumValue = 0;
    var myPhoneValue;
    myPhone_value == true ? myPhoneValue = 1 : myPhoneValue = 0;
    var myQueryValue;
    myQuery_value == true ? myQueryValue = 1 : myQueryValue = 0;
    ///
    var myWin = myScriptWindow();
    if (myFastUsage == false) { // myFastUsage == false
        //if (myWin.show() == 2) exit(); // ==2  -- это щелчок на красном крестике в правом верхнем угле окна
    } // myFastUsage == false
    //=================
    function myScriptWindow() { // myScriptWindow
        var win = new Window("dialog", "Подготовка текста к вёрстке" + "  [ " + myParaFileName + " ]", undefined, { closeButton: true });
        //var win = new Window ("palette", "Подготовка текста к вёрстке" + "  [ " + myParaFileName + " ]", undefined, {closeButton: true});
        //win.alignChildren = "right";
        win.alignChildren = "left";
        //win.alignChildren = ["fill", "fill"];
        var tpanel = win.add("tabbedpanel");
        //tpanel.alignChildren = ["fill", "fill"];
        tpanel.alignChildren = "left";
        tpanel.preferredSize = [350, 250]; // лучше оставить на откуп программы управление шириной вкладок
        var tabSize;
        tabSize = [0, 0, GetTheValue(HorTabSize), 20];
        //===========================================
        var clean = tpanel.add("tab", undefined, "Чистка текста");
        clean.alignChildren = "left";
        var myClean = clean.add("checkbox", undefined, "Выполнить выбранные операции");
        myClean_value == 1 ? myClean.value = true : myClean.value = false;
        var c_options = clean.add("panel", undefined, "");
        c_options.alignChildren = ["fill", "fill"];
        //infoAboutFootnotes = c_options.add ("checkbox", tabSize, "Убедитесь, что число сносок в файле такое же, как и в переданном на вёрстку тексте");
        infoAboutFootnotes = c_options.add("checkbox", tabSize, "Получить информацию о сносках в переданном на вёрстку тексте");
        var twoChNotes = c_options.add("group");
        twoChNotes.orientation = "row";
        twoChNotes.alignChildren = ["fill", "fill"];
        //setsFromPara = c_options.add ("checkbox", tabSize, "Оформление сноски определяется установками абзацного стиля");
        setsFromPara = twoChNotes.add("checkbox", undefined, "Оформление сноски определяется установками абзацного стиля");
        //var procEndnotes = twoChNotes.add ("checkbox", undefined, "Обрабатывать концевые сноски");
        procEndnotes = twoChNotes.add("checkbox", undefined, "Обрабатывать концевые сноски"); // 4/3/2019 -- почему-то var не работает...
        procEndnotes.value = false;
        //if (parseIntAppVersion <13) procEndnotes.enabled = false;
        //if (parseIntAppVersion <13 || mySelection.parent.endnotes.length == 0) procEndnotes.hide();

        if ((myFastUsage == false && myEditCurSet == true) && (parseIntAppVersion < 13 || mySelection.parent.endnotes.length == 0)) procEndnotes.hide();
        if (insertionPointIsActive == false) procEndnotes.enabled = false;
        setsFromPara.value = false;
        separator_f = c_options.add("panel"); // Помещаем на экран горизонтальную линию.  Для программы этот параметр высота, но по сути это ширина линии
        separator_f.minimumSize.height = separator_f.maximumSize.height = 1;
        var RepeatedSpacesAndEnters = c_options.add("group");
        RepeatedSpacesAndEnters.alignChildren = "left";
        RepeatedSpacesAndEnters.orientation = "column";
        /////
        setsFromPara.onClick = function () { // setsFromPara
            var parseIntAppVersion = parseInt(app.version);
            if (parseIntAppVersion < 8) {
                alert("Эта опция работает, начиная в версии CS6.", "Оформление сноски установками абазцного стиля");
                setsFromPara.value = false;
                setsFromPara.enabled = false;
                return;
            }
            var myParent = mySelection.parent;
            if (myParent.constructor.name == "Footnote") myParent = myParent.parent;
            var myFootnotesNumber = "";
            var myEndnotesNumber = 0;
            if (parseIntAppVersion > 12) myEndnotesNumber = myParent.endnotes.length;
            myFootnotesNumber = myParent.footnotes.length;
            if (myFootnotesNumber + myEndnotesNumber == 0) {
                setsFromPara.value = false;
                setsFromPara.enabled = false;
                setsFromPara.helpTip = "В этой работе нет сносок";
                return;
            }
            ////////////////////////////////////////
            var myFileNoteProc = File(decodeURI(myScriptFolder + "/BIN/" + "SmartNoteProc.jsxbin"));
            if (myFileNoteProc.exists) {
                app.doScript(myFileNoteProc);
                selStory = app.selection[0].parentStory;
                var mess = smartNoteProc1(selStory, setsFromPara);
                if (mess[0] != " " || hideMessageAboutNoteProcessing == false) { alert(mess, "Подготовка текста к вёрстке"); setsFromPara.value = false };
                if (mess[0] == " ") { setsFromPara.value = true; setsFromPara.enabled = false };
                if (hideUserName) setsFromPara.helpTip = "";
                return;
            }
            else {
                alert("На этой машине нет данной опции. В папке Info есть файл с информацией, что делает это дополнение к скрипту и как его подключить.", "Оформление сноски установками абазцного стиля");
                setsFromPara.value = false;
                setsFromPara.enabled = false;
                setsFromPara.helpTip = "Вся информация в папке Info.";
                return;
            }
        } // setsFromPara
        ////////////////
        repChar = RepeatedSpacesAndEnters.add("checkbox", undefined, "Удалить повторяющиеся символы...");
        repChar_value == 1 ? repChar.value = true : repChar.value = false;
        setRepChar = RepeatedSpacesAndEnters.add("group");
        setRepChar.alignChildren = "left";
        setRepChar.orientation = "row";
        spaces = setRepChar.add("checkbox", undefined, "...пробелов и знаков табуляции" + myWhiteSpace + myWhiteSpace);
        spaces_value == 1 ? spaces.value = true : spaces.value = false;
        enters = setRepChar.add("checkbox", undefined, "...пустых абзацев" + myWhiteSpace + myWhiteSpace);
        enters_value == 1 ? enters.value = true : enters.value = false;

        shenters = setRepChar.add("checkbox", undefined, "...принудительных обрывов строк");
        shenters_value == 1 ? shenters.value = true : shenters.value = false;
        if (repChar.value == false) { // repChar.value == false
            enters.enabled = false;
            shenters.enabled = false;
            spaces.enabled = false;
        } // repChar.value == false
        separator_rc = c_options.add("panel"); // Помещаем на экран горизонтальную линию Для программы этот параметр высота, но по сути это ширина линии
        scale100 = c_options.add("checkbox", undefined, "Перед вёрсткой установить вертикальный и горизонтальный масштаб символов равным 100%");
        scale100_value == 1 ? scale100.value = true : scale100.value = false;
        tabsProc = c_options.add("group");
        tabsProc.alignChildren = "left";
        //tabsProc.alignChildren = ["fill", "fill"];
        tabsProc.orientation = "row";
        startTabs = tabsProc.add("checkbox", undefined, "Удалить символ табуляции в начале абзаца");
        startTabs_value == 1 ? startTabs.value = true : startTabs.value = false;
        tS = tabsProc.add("statictext", undefined, "\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0\u00A0");
        tabs2spaces = tabsProc.add("checkbox", undefined, "Заменить символы табуляции на пробелы");
        tabs2spaces_value == 1 ? tabs2spaces.value = true : tabs2spaces.value = false;
        hyphens = c_options.add("checkbox", undefined, "Удалить в тексте символы деления на слоги");
        hyphens_value == 1 ? hyphens.value = true : hyphens.value = false;
        digAndChar = c_options.add("checkbox", undefined, "Привести в порядок наращение чисел (исправить '1-ых' на '1-х', '2-ого' на '2-го' и т.п.)");
        digAndChar_value == 1 ? digAndChar.value = true : digAndChar.value = false;
        hyplinks = c_options.add("checkbox", undefined, "Удалить гиперссылки из текста");
        hyplinks_value == 1 ? hyplinks.value = true : hyplinks.value = false;
        separator_c1 = c_options.add("panel"); // Помещаем на экран горизонтальную линию Для программы этот параметр высота, но по сути это ширина линии
        separator_c1.minimumSize.height = separator_c1.maximumSize.height = 1;
        var myTireAndSeparatorGroup = c_options.add("group");
        myTireAndSeparatorGroup.orientation = "row";
        myTireAndSeparatorGroup.alignChildren = "left";
        var TireGroup = myTireAndSeparatorGroup.add("group");
        TireGroup.orientation = "column";
        TireGroup.alignChildren = "left";
        TireGroup.add("statictext", undefined, "Тире в тексте");
        var myVariantTireRadioGroup = TireGroup.add("group");
        myVariantTireRadioGroup.orientation = "row";
        myVariantTireRadioGroup.alignChildren = "left";
        var commonTire = myVariantTireRadioGroup.add("radiobutton", undefined, "Длинное тире");
        commonTire_value == 1 ? commonTire.value = true : commonTire.value = false;
        var shortTire = myVariantTireRadioGroup.add("radiobutton", undefined, "Короткое тире (минус)");
        shortTire.value = !commonTire.value;
        //---
        var myEmptyGroup = myTireAndSeparatorGroup.add("group");
        myEmptyGroup.orientation = "column";
        myEmptyGroup.alignChildren = "left";
        myEmptyGroup.add("statictext", [0, 0, 20, 10], "");
        //---
        var mySeparatorGroup = myTireAndSeparatorGroup.add("group");
        mySeparatorGroup.orientation = "column";
        mySeparatorGroup.alignChildren = "left";
        mySeparatorGroup.add("statictext", undefined, "Разделитель цифр в интервалах дат и чисел");
        var myDigitAndYearDivisionRadioGroup = mySeparatorGroup.add("group");
        myDigitAndYearDivisionRadioGroup.orientation = "row";
        myDigitAndYearDivisionRadioGroup.alignChildren = "left";
        var minus = myDigitAndYearDivisionRadioGroup.add("radiobutton", undefined, "Минус");
        minus_value == 1 ? minus.value = true : minus.value = false;
        var tire = myDigitAndYearDivisionRadioGroup.add("radiobutton", undefined, "Тире");
        tire_value == 1 ? tire.value = true : tire.value = false;
        var defis = myDigitAndYearDivisionRadioGroup.add("radiobutton", undefined, "Дефис");
        defis_value == 1 ? defis.value = true : defis.value = false;
        var defisN = myDigitAndYearDivisionRadioGroup.add("radiobutton", undefined, "Неразрывный дефис");
        defisN_value == 1 ? defisN.value = true : defisN.value = false;
        //
        var myDefisProccessing = c_options.add("group");
        myDefisProccessing.orientation = "row";
        //myDefisProccessing.alignment = "left";
        myDefisProccessing.alignChildren = ["left", "top"]; //"bottom"
        myDP = myDefisProccessing.add("statictext", undefined, "Дефис в начале абзаца:");
        myDP.helpTip = "Если это вёрстка художественной литературы, выберите тире, оно в начале абзаца используется в диалогах. Будет использоваться то тире, что определено в позиции 'Тире в тексте'.\rЕсли это вёрстка научного издания, то там такие дефисы обычно в списках, поэтому или оставьте дефис, или выберите минус.";
        insteadDefis = myDefisProccessing.add("group");
        //insteadDefis.alignChildren = ["left", "bottom"]; //"bottom"
        var myDPdefis = insteadDefis.add("radiobutton", undefined, "Дефис");
        myDPdefis_value == 1 ? myDPdefis.value = true : myDPdefis.value = false;
        var myDPminus = insteadDefis.add("radiobutton", undefined, "Минус");
        myDPminus_value == 1 ? myDPminus.value = true : myDPminus.value = false;
        var myDPtire = insteadDefis.add("radiobutton", undefined, "Тире");
        myDPtire_value == 1 ? myDPtire.value = true : myDPtire.value = false;
        //
        separatorS = c_options.add("panel"); // Помещаем на экран горизонтальную линию
        separatorS.minimumSize.height = separatorS.maximumSize.height = 1;
        var myMlnGroup = c_options.add("group");
        myMlnGroup.orientation = "column";
        myMlnGroup.alignChildren = "left";
        myMlnGroup.add("statictext", undefined, "Вариант сокращения слов 'миллион', 'миллиард', 'триллион': с точкой или без точки");
        myDotOrNot = myMlnGroup.add("group");
        myDotOrNot.orientation = "row";
        myDotOrNot.alignChildren = "left";
        var mlnWithoutPoint = myDotOrNot.add("radiobutton", undefined, "млн, млрд, трлн");
        var mlnWithPoint = myDotOrNot.add("radiobutton", undefined, "млн., млрд., трлн.");
        mlnWithoutPoint_value == 1 ? mlnWithoutPoint.value = true : mlnWithoutPoint.value = false;
        mlnWithPoint.value = !mlnWithoutPoint.value;
        //=============================================
        var typo = tpanel.add("tab", undefined, "Оформление текста");
        typo.alignChildren = "left";
        //typo.alignChildren = "left";
        var myTypographica = typo.add("checkbox", undefined, "Выполнить выбранные операции");  // undefined
        myTypographica_value == 1 ? myTypographica.value = true : myTypographica.value = false;
        var t_options = typo.add("panel", undefined, "");
        t_options.alignChildren = ["fill", "fill"];
        var CheckAndDrop = t_options.add("group");
        CheckAndDrop.orientation = "row";
        //CheckAndDrop.alignChildren = "left";
        CheckAndDrop.alignChildren = ["fill", "fill"];
        var CheckGroup = CheckAndDrop.add("group");
        CheckGroup.orientation = "column";
        CheckGroup.alignChildren = "left";
        var fixOneLetter = CheckGroup.add("checkbox", undefined, "Запретить отрывать однобуквенные предлоги (частицы, союзы) от слов");
        var fixTwoLetter = CheckGroup.add("checkbox", undefined, "Запретить отрывать двухбуквенные предлоги (частицы, союзы) от слов");
        //var fixLettersAndTire = CheckGroup.add ("checkbox", undefined, "Запретить оставлять в конце строки предлог и тире начала предложения");
        //fixDigitAndWord = t_options.add ("checkbox", undefined, "Неразрывный изменяемый пробел между цифрой и названием месяца/единицей измерения, или между словом и числом");
        //var sp = CheckAndDrop.add ("statictext", ButtonSize, myWhiteSpace+myWhiteSpace+myWhiteSpace+myWhiteSpace+myWhiteSpace+myWhiteSpace);
        var sp = CheckAndDrop.add("statictext", myButtonSize, "");
        var DropPanel = CheckAndDrop.add("panel", undefined, "Вариант неразрывного пробела в этих запретах");
        TwoSpacesDrop = DropPanel.add("dropdownlist", undefined, myTwoSpaces, { multiselect: false });
        TwoSpacesDrop.helpTip = "Этот пробел будет также между римской цифрой и одним из сокращений, собранных в переменной myWordsAfterRomanDigits. Сейчас она выглядит так: " + myWordsAfterRomanDigits + ".";
        TwoSpacesDrop.selection = TwoSpacesDrop_selection;
        var TwoSpacesDropIndex = TwoSpacesDrop.selection.index;
        fixOneLetter_value == 1 ? fixOneLetter.value = true : fixOneLetter.value = false;
        fixTwoLetter_value == 1 ? fixTwoLetter.value = true : fixTwoLetter.value = false;
        if (fixOneLetter_value == 0 && fixTwoLetter_value == 0) DropPanel.enabled = false;
        separatorD = t_options.add("panel"); // Помещаем на экран горизонтальную линию Для программы этот параметр высота, но по сути это ширина линии
        separatorD.minimumSize.height = separatorD.maximumSize.height = 1;
        //WordAndLetterSpace = t_options.add ("checkbox", undefined, "Установить работающие значения межсловных и межбуквенных интервалов и масштабы глифов, подходящие для кириллицы");
        WordAndLetterSpace = t_options.add("checkbox", undefined, "Установить пользовательские значения межсловных и межбуквенных интервалов и горизонтального масштаба глифов");
        WordAndLetterSpace.helpTip = "При установке индизайна межсловным и межбуквенным интервалам по умолчанию назначаются такие стартовые значения, при которых компоновщик только на широкой полосе может нормально скомпоновать абзац. На узких колонках слова при таких установках нередко или слипаются, или разваливаются на отдельные буквы.\rОсобенно сильно влияют установки межбуквенных интервалов, стандартно они нулевые, и установки масштабирования глифов, стандартно они равны 100. То есть как раз те параметры, которыми оперирует компоновщик в процессе вёрстки, стандартно не имеют никаких допусков.\rМожно, конечно, так и работать с усреднёнными стандартными установками, но качество компоновки абзаца уже будет зависеть не от мастерства верстальщика, а от везения. А можно попробовать управлять процессом и постараться найти оптимальные значения этих установок. Чтобы компоновщик мог нормально работать на узких колонках, начните с таких значений: диапазон изменения межбуквенных интервалов –5  0  5, диапазон изменения горизонтального масштаба глифов не стоит делать шире 96  100  104, межсловные интервалы вместо стандартных 80  100  133 обычно достаточно сделать 95  100  105.\rВ программе DoTextOK значения межсловных, межбуквенных интервалов и диапазон масштабирования глифов находятся в переменных WordSpacing(" + WordSpacing + "), LetterSpacing(" + LetterSpacing + "), GlyphScaling(" + GlyphScaling + ") в файле WordsAndUnits.jsx, в скобках указаны их текущие значения. Эти значения целесообразно повторить и в установках абзацных стилей.\rКритерий, что при текущих настройках индизайн справляется с задачей компоновки абзаца — отсутствие желтого цвета при установленном флажке 'Проблемы переноса и выключки' на вкладке 'Компоновка' в панели 'Установки'. Жёлтый цвет появляется там, где компоновщик не справляется с задачей вёрстки абзаца с соблюдением текущих установок, и желтизна тем ярче, чем дальше компоновщик отходит от заданных значений.";
        WordAndLetterSpace_value == 1 ? WordAndLetterSpace.value = true : WordAndLetterSpace.value = false;

        nobreakSpace = t_options.add("checkbox", undefined, "После обработки заменить изменяемые неразрывные пробелы на обычный пробел с атрибутом 'Без переносов' (Nobreak)");
        nobreakSpace.helpTip = "Этот флажок актуален только для тех, кто использует многоязычный компоновщик, т.к. он обрабатывает изменяемые неразрывные пробелы как фиксированные неразрывные пробелы.\rЕсли в вёрстке нужны именно изменяемые пробелы, то при установке этого флажка все изменяемые неразрывные пробелы будут заменены на обычные с артибутом 'Без переносов'. При этой замене рекомендуется использовать многострочный, а не однострочный многоязычный компоновщик.";
        nobreakSpace_value == 1 ? nobreakSpace.value = true : nobreakSpace.value = false;
        //else var nobreakSpace.value = false;
        //
        fixDigitAndWord = t_options.add("checkbox", undefined, "Неразрывный изменяемый пробел между цифрой и названием месяца/единицей измерения, или между словом и числом");
        bull2text = t_options.add("checkbox", tabSize, "Преобразовать буллиты и нумерацию в текст");
        bull2text_value == 1 ? bull2text.value = true : bull2text.value = false;
        fixDigitAndWord_value == 1 ? fixDigitAndWord.value = true : fixDigitAndWord.value = false;
        //--
        var fontStyles = t_options.add("group");
        fontStyles.alignChildren = "left";
        fontStyles.orientation = "row";
        charStyles = fontStyles.add("checkbox", undefined, "Символьные стили для курсива, полужирного, индексов");
        charStyles_value == 1 ? charStyles.value = true : charStyles.value = false;
        noParagraphs = fontStyles.add("checkbox", undefined, "Только слова и буквы, абзацы не учитывать");
        noParagraphs_value == 1 ? noParagraphs.value = true : noParagraphs.value = false;
        charStyles.value == false ? noParagraphs.enabled = false : noParagraphs.enabled = true;
        grekCharStyles = t_options.add("checkbox", undefined, "Создать символьные стили для специальных знаков и букв других алфавитов");
        grekCharStyles_value == 1 ? grekCharStyles.value = true : grekCharStyles.value = false;
        //grekCharStyles.helpTip = "Греческие буквы от альфы до омеги α-ω, немецкие буквы ä,ö,ü,Ä,Ö,Ü,ß, знаки дробей ¼,½,¾ собраны в переменной myGrecDeuSpecChars в файле WordsAndUnits.jsx, вы можете там редактировать этот список" ;
        grekCharStyles.helpTip = "Вы можете там редактировать список знаков, которые надо отметить специальным символьным стилем.\rСейчас переменная myGrecDeuSpecChars, размещённая в файле WordsAndUnits.jsx, выглядит так: " + myGrecDeuSpecChars;
        var underlineAndcapsGroup = t_options.add("group");
        underlineAndcapsGroup.alignChildren = "left";
        underlineAndcapsGroup.orientation = "row";
        useUnderline = underlineAndcapsGroup.add("checkbox", undefined, "Отдельные стили для подчеркивания");
        useUnderline_value == 1 ? useUnderline.value = true : useUnderline.value = false;
        useCapslock = underlineAndcapsGroup.add("checkbox", undefined, "Отдельные стили для ПРОПИСНЫХ БУКВ");
        useCapslock_value == 1 ? useCapslock.value = true : useCapslock.value = false;
        //---
        setquotes = t_options.add("checkbox", undefined, "Кавычки в тексте в соответствии с выбранным языком статьи");
        setquotes_value == 1 ? setquotes.value = true : setquotes.value = false;
        var twoChB = t_options.add("group");
        //twoChB.alignChildren = "left";
        twoChB.orientation = "row";
        twoChB.alignChildren = ["fill", "fill"];
        myOneLineIsOneAbzatz = twoChB.add("checkbox", undefined, "Текст в формате 'одна строка - один абзац'");
        partHE = twoChB.add("checkbox", undefined, "Переносы '-НЕ' и 'НЕ-'");
        partHE.helpTip = "В практике книгоиздания известны два редких случая упущений в вёрстке, из-за которых при быстром чтении можно понять текст неправильно.\rЭто может случиться, если: 1) частица ‘не’ оказалась в конце строки;\r2) буквы ‘не’ — первая или последняя часть разделённого переносом слова.\rПервая ошибка вёрстки снимается запретом отрывать частицу НЕ от слова, см. переменную 'SpaceTwoLetterNonbreakingSpace' в файле WordsAndUnits.jsx.\rУстановка данного флажка исключит вторую ошибку.\rЭто правило для вёрстки книг, не для узкой колонки газеты или журнала.";
        partHE_value == 1 ? partHE.value = true : partHE.value = false;
        myOneLineIsOneAbzatz_value == 1 ? myOneLineIsOneAbzatz.value = true : myOneLineIsOneAbzatz.value = false;
        separator4 = t_options.add("panel"); // Помещаем на экран горизонтальную линию Для программы этот параметр высота, но по сути это ширина линии
        separator4.minimumSize.height = separator4.maximumSize.height = 1;
        //--- 
        var myFootnoteProcessing = t_options.add("group");
        myFootnoteProcessing.alignChildren = ["fill", "fill"];
        myFootnoteProcessing.orientation = "column";
        var myFootnoteGroup = myFootnoteProcessing.add("checkbox", undefined, "Когда рядом запятая или точка и знак сноски — ");
        myFootnoteGroup.helpTip = "Когда этот флажок сброшен, знак сноски идёт непосредственно за словом. Особенности обработки стоящих рядом сносок и знаков пунктуации при установленном этом флажке смотрите в комментариях к радиокнопкам."
        myFootnoteGroup_value == 1 ? myFootnoteGroup.value = true : myFootnoteGroup.value = false;
        var footnoteselection = myFootnoteProcessing.add("group");
        footnoteselection.orientation = "row";
        var footnote1 = footnoteselection.add("radiobutton", undefined, "...знак сноски перед знаком пунктуации");
        var footnote2 = footnoteselection.add("radiobutton", undefined, "...сначала точка или запятая, затем знак сноски");
        footnote1.helpTip = "Когда эта кнопка активна, перед знаком сноски ставится волосяная шпация."
        footnote2.helpTip = "Когда эта кнопка активна, отбивкой между словом и знаком сноски служит горизонтальное пространство знака пунктуации."
        footnote1_value == 1 ? footnote1.value = true : footnote1.value = false;
        footnote2.value = !footnote1.value;
        myFootnoteGroup.value == false ? footnoteselection.enabled = false : footnoteselection.enabled = true;
        try { // #
            if (myStory.footnotes.length == 0) {  // == 0 :: если сносок нет, то управление  очередностью снято
                //myFootnoteGroup.value = false;
                myFootnoteGroup.enabled = false;
                footnoteselection.enabled = false;
            }  // == 0 
        } // #
        catch (e) { } // в случае, когда ничего не выбрано (для случая обработки всех статей документа) проверка  myStory.footnotes.length == 0 смысла не имеет
        separator_t2 = t_options.add("panel"); // Помещаем на экран горизонтальную линию
        separator_t2.minimumSize.height = separator_t2.maximumSize.height = 1;
        var myInfoAboutStyleGroup = t_options.add("group");
        //myInfoAboutStyleGroup.align = "right";
        myInfoAboutStyleGroup.alignChildren = ["fill", "fill"];
        myInfoAboutStyleGroup.orientation = "row";
        var myInfoGroup1 = myInfoAboutStyleGroup.add("group");
        myInfoGroup1.align = "left";
        myInfoGroup1.orientation = "row";
        ///--- доработка Бориса Кащеева: выборка стилей, хранящихся в группах стилей. 
        myParaStyleNames = getParagraphStyleNames();
        // var myStyleNameLength = 0;
        var myStyleNameLength = getMaxStyleNameLength(myParaStyleNames);
        /*for (i=0; i< myDocument.paragraphStyles.length; i++) { 
            myParaStyleNames.push(myDocument.paragraphStyles.item(i).name) ;  // перечень всех стилей документа, включая неотображаемый в панели Paragraphs вариант сброса всех стилей myDocument.paragraphStyles.item(0).name =  [No Paragraph Style]
            if (myDocument.paragraphStyles.item(i).name.length > myStyleNameLength) myStyleNameLength = myDocument.paragraphStyles.item(i).name.length;
            }*/
        ///----
        for (j = 0; j < myParaStyleNames.length; j++) { // myParaStyleNames.length
            if (myParaStyleNames[j] == myPrevSelectedStyle) break;
        } // myParaStyleNames.length
        if (j < myParaStyleNames.length) myStyleIndex = j;
        else myStyleIndex = 1; // единица -- это индекс стиля Basic Paragraph
        var oneStyle = myInfoGroup1.add("checkbox", undefined, "Присвоить тексту один стиль:");
        if (oneStyle_value == false || myStyleIndex == 1) oneStyle.value = false
        else oneStyle.value = true;
        myList = myInfoGroup1.add("dropdownlist", undefined, myParaStyleNames, { multiselect: false });
        myList.minimumSize.width = myList.maximumSize.width = 160;
        myList.selection = myStyleIndex;
        oneStyle.value == false ? myList.enabled = false : myList.enabled = true;
        ///
        myWhSp = myInfoAboutStyleGroup.add("statictext", undefined, myWhiteSpace + myWhiteSpace + myWhiteSpace + myWhiteSpace);
        //myWhSp = myInfoAboutStyleGroup.add ("statictext", undefined, "|");
        //~ var myInfoAboutLang = t_options.add ("group");
        //~ myInfoAboutLang.alignChildren = "left";
        //~ myInfoAboutLang.orientation = "row";
        //var setLang = myInfoAboutLang.add ("checkbox", undefined, "Выбрать язык статьи:");
        var myInfoGroup2 = myInfoAboutStyleGroup.add("group");
        myInfoGroup2.align = "right";
        myInfoGroup2.orientation = "row";
        var setLang = myInfoGroup2.add("checkbox", undefined, "Выбрать язык статьи:");
        setLang_value == 1 ? setLang.value = true : setLang.value = false;
        if (setLang_value == 0) setquotes.enabled = false;
        ///
        var AllLang = app.languagesWithVendors;
        var LangList = [];
        for (var i = 0; i < AllLang.length; i++) LangList[i] = AllLang[i].name;
        //var myLanguageList = myInfoAboutLang.add ("dropdownlist",undefined, LangList,{multiselect: false}); 
        var myLanguageList = myInfoGroup2.add("dropdownlist", undefined, LangList, { multiselect: false });
        myLanguageList.minimumSize.width = myLanguageList.maximumSize.width = 160;
        myLanguageList.helpTip = "Для выбора языка в этом списке удерживайте мышку нажатой, а список прокручивайте клавишами-стрелками";
        //try { if (userLanguage < app.languagesWithVendors.length) myLanguageList_selection = userLanguage; else myLanguageList_selection = 0; } catch (e) { myLanguageList_selection = 0; }
        try { // ##
            if (myLanguageList_selection > AllLang.length) myLanguageList_selection = 0;
            myLanguageList.selection = myLanguageList_selection;
        } // ##
        catch (e) { myLanguageList.selection = 0; }
        myLanguageList_selection = myLanguageList.selection.index;
        setLang_value == 0 ? myLanguageList.enabled = false : myLanguageList.enabled = true;
        if (myLanguageList.selection == 0) setquotes.enabled = false;
        myLanguageList.onChange = function () { if (myLanguageList.selection.index == 0) setquotes.enabled = false else setquotes.enabled = true }
        //==============================================
        //var spatium = tpanel.add ("tab", undefined, "Шпации в тексте");
        var spatium = tpanel.add("tab", undefined, "Шпации в тексте и формулах");
        spatium.alignChildren = "left";
        var mySpatium = spatium.add("checkbox", undefined, "Выполнить выбранные операции");
        mySpatium_value == 1 ? mySpatium.value = true : mySpatium.value = false;
        var s_options = spatium.add("panel", undefined, "");
        s_options.alignChildren = ["fill", "fill"];
        s_options.align = "left";
        //---
        var myTireGroup = s_options.add("group");
        myTireGroup.alignChildren = "left";
        //myTireGroup.alignChildren =  ["fill", "fill"];
        myTireGroup.orientation = "column";
        var myTireAndSpatiumInfo = myTireGroup.add("group");
        //myTireAndSpatiumInfo.alignChildren =  ["fill", "fill"];
        myTireAndSpatiumInfo.orientation = "row";
        myTireAndSpatiumInfo.alignChildren = "left";
        var tireAndSpatium = myTireAndSpatiumInfo.add("checkbox", undefined, "Шпации до и после тире:");
        tireAndSpatium_value == 1 ? tireAndSpatium.value = true : tireAndSpatium.value = false;
        var myTireSpatiumGroup = myTireAndSpatiumInfo.add("group");
        myTireSpatiumGroup.orientation = "row";
        myTireSpatiumGroup.alignChildren = "left";
        //myTireSpatiumGroup.alignChildren =  ["fill", "fill"];
        var mySpaceListBefore = myTireSpatiumGroup.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        mySpaceListBefore.helpTip = "Какая шпация до и после тире будет стоять по умолчанию, т.е. после сброса, определяет значение переменной DefaultSpace.\nОна хранится в файле установок WordsAndUnits.jsx.";
        //var s = myTireSpatiumGroup.add ("statictext", [0,0,10,20], "—");
        var s = myTireSpatiumGroup.add("statictext", undefined, "—");
        var mySpaceListAfter = myTireSpatiumGroup.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        mySpaceListBefore.selection = mySpaceListBefore_selection;
        mySpaceListAfter.selection = mySpaceListAfter_selection;
        var mySpaceListBeforeIndex = mySpaceListBefore.selection.index;
        var mySpaceListAfterIndex = mySpaceListAfter.selection.index;
        //var scaleInfo = myWhiteSpace + myWhiteSpace + myWhiteSpace + myWhiteSpace;
        //var scaleInfo = "";
        //var usedScale = myTireSpatiumGroup.add ("staticText", undefined, mySpaceScale); 
        //~ var usedScale = myTireSpatiumGroup.add ("statictext", undefined, scaleInfo); 
        //~ usedScale.characters = 5;
        //~ usedScale.helpTip = "";
        if (mySpaceListBeforeIndex == 1 && mySpaceListAfterIndex == 1) curLineAboutSpaces = lineForSpaces
        else curLineAboutSpaces = lineForSpatios;
        ////
        mySpaceListBefore.onActivate = function () { // mySpaceListBefore.onActivate
            try { var test = sameSpaces } catch (e) { test = null }
            if (test != null && sameSpaces == true) { // sameSpaces
                mySpaceListAfter.selection = mySpaceListBefore.selection.index;
            } // sameSpaces
            if (mySpaceListBefore.selection.index == 1 && mySpaceListAfter.selection.index == 1) curLineAboutSpaces = lineForSpaces
            else curLineAboutSpaces = lineForSpatios;
            try { spationsToSpace.text = curLineAboutSpaces } catch (e) { }
        } // mySpaceListBefore.onActivate 
        ////
        mySpaceListAfter.onActivate = function () { // mySpamySpaceListAfterceListBefore.onActivate
            try { var test = sameSpaces } catch (e) { test = null }
            if (test != null && sameSpaces == true) { // sameSpaces
                mySpaceListBefore.selection = mySpaceListAfter.selection.index;
            } // sameSpaces
            if (mySpaceListBefore.selection.index == 1 && mySpaceListAfter.selection.index == 1) curLineAboutSpaces = lineForSpaces
            else curLineAboutSpaces = lineForSpatios;
            try { spationsToSpace.text = curLineAboutSpaces } catch (e) { }
        } // mySpaceListAfter.onActivate
        ////
        var changeSpationsToSpace = s_options.add("group");
        changeSpationsToSpace.orientation = "row";
        changeSpationsToSpace.alignChildren = "left";
        var mySliderGroup = changeSpationsToSpace.add("group");
        mySliderGroup.alignChildren = "left";
        mySliderGroup.orientation = "row";
        var spaceSelSlider = mySliderGroup.add("statictext", undefined, "Ширина пробелов, от 1 до 100%");
        var SliderStartValue = Number(mySlider_value).toFixed(0);  //mySliderValueFromMenu; mySlider_value
        //var mySpaceProc = mySliderGroup.add ("edittext {justify: 'center'}", [0,0,45,20], SliderStartValue);
        var mySpaceProc = mySliderGroup.add("edittext {justify: 'center'}", [0, 0, 40, 20]);
        mySpaceProc.text = SliderStartValue;
        var s2 = mySliderGroup.add("statictext", [0, 0, 5, 20], "");
        var slider = mySliderGroup.add("slider", [0, 0, 180, 20], SliderStartValue, 1, 100);
        slider.onChanging = function () { mySpaceProc.text = Number(slider.value).toFixed(0) };
        mySpaceProc.onChanging = function () { // function
            if (isNaN(Number(mySpaceProc.text)) || (Number(mySpaceProc.text)) < 0 || (Number(mySpaceProc.text)) > 100 || mySpaceProc.text.length == 0 || mySpaceProc.text[0] == " " || mySpaceProc.text[0] == "0") { /// isNaN...  
                mySpaceProc.text = slider.value;
                return;
            } /// isNaN...
            else if (Number(mySpaceProc.text) >= 1) slider.value = mySpaceProc.text;
            else { // в описании стиля не допускается задавать масштаб уменьшения меньше 1%
                mySpaceProc.text = 1;
                slider.value = 1;
            }
        } // function
        //var spatioScaleInfo = "";
        var spationsToSpace = changeSpationsToSpace.add("checkbox", undefined, curLineAboutSpaces);
        spationsToSpace.characters = lineForSpatios.length;
        spationsToSpace_value == 1 ? spationsToSpace.value = true : spationsToSpace.value = false;
        setSliderState();
        spationsToSpace.onClick = function () { // spationsToSpace.onClick
            setSliderState();
        } // spationsToSpace.onClick
        //---
        function setSliderState() { // setSliderState
            if (spationsToSpace.value == true) { // == true
                spaceSelSlider.enabled = true;
                mySpaceProc.enabled = true;
                slider.enabled = true;
                //spaceSelSlider.show();
                //mySpaceProc.show(  
                //slider.show();
            } // == true
            else { /// else
                spaceSelSlider.enabled = false;
                mySpaceProc.enabled = false;
                slider.enabled = false;
                spaceSelSlider.hide();
                mySpaceProc.hide();
                slider.hide();
            } /// else    
        } // setSliderState
        ////
        if (tireAndSpatium.value == false) {
            myTireSpatiumGroup.enabled = false;
            changeSpationsToSpace.enabled = false;
        }
        else {
            myTireSpatiumGroup.enabled = true;
            changeSpationsToSpace.enabled = true;
        }
        /////
        separatorL = s_options.add("panel"); // Помещаем на экран горизонтальную линию
        separatorL.minimumSize.height = separatorL.maximumSize.height = 1;
        var myTireInDialog = s_options.add("group");
        myTireInDialog.alignChildren = "left";
        myTireInDialog.orientation = "row";
        myTireInDialog.add("statictext", undefined, "Шпация после тире в начале диалога или перед строкой списка");
        var mySpaceAfterTireInDialog = myTireInDialog.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        mySpaceAfterTireInDialog.selection = mySpaceAfterTireInDialogIndex;
        mySpaceAfterTireInDialog.helpTip = "Какая шпация после тире будет по умолчанию, т.е. после сброса, определяет значение переменной DefaultSpaceInDialog.\nОна хранится в файле установок WordsAndUnits.jsx.";

        var myCommaAndTireGroup = s_options.add("group");
        //myCommaAndTireGroup.alignChildren = ["fill", "fill"];
        myCommaAndTireGroup.alignChildren = "left";
        myCommaAndTireGroup.orientation = "column";
        var myCommaAndTireGroup1 = myCommaAndTireGroup.add("group");
        //var myCommaAndTireGroup1 = s_options.add ("group");
        myCommaAndTireGroup1.alignChildren = "left";
        myCommaAndTireGroup1.orientation = "row";
        var commatire = myCommaAndTireGroup1.add("checkbox", undefined, "Между запятой, точкой, многоточием и тире:");
        //var commatire= myCommaAndTireGroup1.add ("checkbox", undefined, "Между запятой, многоточием и тире:");
        commatire_value == 1 ? commatire.value = true : commatire.value = false;
        var myCommaAndTire = myCommaAndTireGroup1.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myCommaAndTire.selection = myCommaAndTire_selection;
        var myCommaAndTireIndex;
        commatire.value == false ? myCommaAndTire.enabled = false : myCommaAndTire.enabled = true;
        //---
        var myCommaAndTireGroup2 = myCommaAndTireGroup.add("group");
        //var myCommaAndTireGroup2 = s_options.add ("group");
        myCommaAndTireGroup2.orientation = "row";
        myCommaAndTireGroup2.alignChildren = "left";
        //var shortword= myCommaAndTireGroup2.add ("checkbox", undefined, "В составных сокращениях (т.д., т.е., т.к., ...):");
        var shortword = myCommaAndTireGroup2.add("checkbox", undefined, "В составных сокращениях (т.д., т.е., т.к., ...):");
        shortword_value == 1 ? shortword.value = true : shortword.value = false;
        var myShortWordSpace = myCommaAndTireGroup2.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myShortWordSpace.selection = myShortWordSpace_selection;
        var myShortWordSpaceIndex;
        shortword.value == false ? myShortWordSpace.enabled = false : myShortWordSpace.enabled = true;
        //---   
        separator3 = s_options.add("panel"); // Помещаем на экран горизонтальную линию
        separator3.minimumSize.height = separator3.maximumSize.height = 1;
        var myFIOGroup = s_options.add("group");
        //myFIOGroup.alignChildren = ["fill", "fill"];
        myFIOGroup.alignChildren = "left";
        myFIOGroup.orientation = "column";
        var initials = myFIOGroup.add("checkbox", tabSize, "Шпации в инициалах");
        initials_value == 1 ? initials.value = true : initials.value = false;
        var myASPushkin = myFIOGroup.add("group");
        myASPushkin.orientation = "row";
        var asPushkin = myASPushkin.add("checkbox");
        //asPushkin.value = asPushkin_value;
        asPushkin_value == false ? asPushkin.value = false : asPushkin.value = true;
        asPushkin.enabled = asPushkin_state;
        myASPushkin.add("statictext", undefined, "А.");
        var myASPushkinFirstSpace = myASPushkin.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myASPushkinFirstSpace.selection = myASPushkinFirstSpace_selection;
        myASPushkin.add("statictext", undefined, "C.");
        var myASPushkinSecondSpace = myASPushkin.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myASPushkinSecondSpace.selection = myASPushkinSecondSpace_selection;
        myASPushkin.add("statictext", undefined, "Пушкин");
        var myPushkinAS = myFIOGroup.add("group");
        myPushkinAS.orientation = "row";
        var pushkinAS = myPushkinAS.add("checkbox");
        // pushkinAS.value = true;
        pushkinAS_value == false ? pushkinAS.value = false : pushkinAS.value = true;
        pushkinAS.enabled = pushkinAS_state;
        myPushkinAS.add("statictext", undefined, "Пушкин");
        var myPushkinASFirstSpace = myPushkinAS.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myPushkinASFirstSpace.selection = myPushkinASFirstSpace_selection;
        myPushkinAS.add("statictext", undefined, "А.");
        var myPushkinASSecondSpace = myPushkinAS.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myPushkinASSecondSpace.selection = myPushkinASSecondSpace_selection;
        myPushkinAS.add("statictext", undefined, "С.");
        if (initials.value == false) {
            myASPushkinFirstSpace.enabled = false;
            myASPushkinSecondSpace.enabled = false;
            myPushkinASFirstSpace.enabled = false;
            myPushkinASSecondSpace.enabled = false;
            asPushkin.enabled = false;
            pushkinAS.enabled = false;
        }
        else {
            myASPushkinFirstSpace.enabled = true;
            myASPushkinSecondSpace.enabled = true;
            myPushkinASFirstSpace.enabled = true;
            myPushkinASSecondSpace.enabled = true;
            asPushkin.enabled = true;
            pushkinAS.enabled = true;
        }
        separator4 = s_options.add("panel"); // Помещаем на экран горизонтальную линию
        separator4.minimumSize.height = separator4.maximumSize.height = 1;
        var myProcGroup = s_options.add("group");
        myProcGroup.orientation = "row";
        //myProcGroup.alignChildren = ["fill", "fill"];
        myProcGroup.alignChildren = "left";
        myProcAndPromille = myProcGroup.add("statictext", undefined, "Знаки процента и промилле");
        var myProcGroupAction = myProcGroup.add("group");
        myProcGroupAction.orientation = "row";
        myProcGroupAction.alignChildren = "left";
        //myProcGroupAction.alignChildren = ["fill", "fill"];
        var slitno = myProcGroupAction.add("dropdownlist", undefined, ["без отбивки от числа", "отбиваются шпацией"], { multiselect: false });
        slitno.selection = slitno_selection;
        var slitnoIndex = slitno.selection.index;
        var ProcSpace = myProcGroupAction.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        if (slitno_selection == 0) {
            ProcSpace.enabled = false;
        }
        else {
            ProcSpace.enabled = true;
        }
        //~ //plusotbivka.value = !slitno.value;
        ProcSpace.selection = ProcSpace_selection;
        var ProcSpaceIndex = ProcSpace.selection.index;
        ////
        slitno.onActivate = function () { // slitno.onActivate
            if (slitno.selection.index == 0) ProcSpace.enabled = false
            else ProcSpace.enabled = true;
            slitnoIndex = slitno.selection.index;
        } // slitno.onActivate
        ////
        var myCurrGroup = s_options.add("group");
        myCurrGroup.orientation = "row";
        myCurrGroup.alignChildren = "left";
        //myCurrGroup.alignChildren = ["fill", "fill"];
        var myCurrency = myCurrGroup.add("statictext", undefined, "Символы обозначения валюты перед числом");
        myCurrency.helpTip = "В переменной CurrencySigns файла WordsAndUnits.jsx сейчас учтены такие варианты записи валют: " + CurrencySigns;
        var myCurrGroupAction = myCurrGroup.add("group");
        myCurrGroupAction.orientation = "row";
        myCurrGroupAction.alignChildren = "left";
        //myCurrGroupAction.alignChildren = ["fill", "fill"];
        var CurrSlitno = myCurrGroupAction.add("dropdownlist", undefined, ["без отбивки от числа", "отбиваются шпацией"], { multiselect: false });
        CurrSlitno.selection = CurrSlitno_selection;
        var CurrSlitnoIndex = CurrSlitno.selection.index;
        var CurrSpace = myCurrGroupAction.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        if (CurrSlitno_selection == 0) {
            CurrSpace.enabled = false;
        }
        else {
            CurrSpace.enabled = true;
        }
        CurrSpace.selection = CurrSpace_selection;
        var CurrSpaceIndex = CurrSpace.selection.index;
        ////
        CurrSlitno.onActivate = function () { // CurrSlitno.onActivate
            if (CurrSlitno.selection.index == 0) CurrSpace.enabled = false
            else CurrSpace.enabled = true;
            CurrSlitnoIndex = CurrSlitno.selection.index;
        } // CurrSlitno.onActivate    
        ////
        separator4N = s_options.add("panel"); // Помещаем на экран горизонтальную линию
        separator4N.minimumSize.height = separator4N.maximumSize.height = 1;
        var myMathGroup = s_options.add("group");
        myMathGroup.orientation = "column";
        //myMathGroup.alignChildren = ["fill", "fill"];
        myMathGroup.alignChildren = "left";
        ///
        var myFormulaIdentifier = myMathGroup.add("group");
        myFormulaIdentifier.orientation = "row";
        myFormulaIdentifier.alignChildren = "left";
        var myFormulaToProcess = myFormulaIdentifier.add("checkbox", undefined, "Признаки, что в абзаце формула:");
        myFormulaToProcess.value = myFormulaToProcessValue;
        var MathSignsAreTakedIntoAccount = myFormulaIdentifier.add("radiobutton", undefined, "математические знаки");  // tabSize
        MathSignsAreTakedIntoAccountValue == 1 ? MathSignsAreTakedIntoAccount.value = true : MathSignsAreTakedIntoAccount.value = false;
        MathSignsAreTakedIntoAccount.enabled = false;
        MathSignsAreTakedIntoAccount.helpTip = "Список математических знаков, которые скрипт ищет при поиске формул, хранится в файле WordsAndUnits.jsx в переменной myProcessedMathSigns. Сейчас в этом наборе следующие знаки: " + myProcessedMathSigns + ", а также дефис, минус и тире.";
        var TextColorIsTakedIntoAccount = myFormulaIdentifier.add("radiobutton", undefined, "цвет текста 'myMathFormulaColor'");  // tabSize
        TextColorIsTakedIntoAccount.value = !MathSignsAreTakedIntoAccount.value;
        TextColorIsTakedIntoAccount.enabled = false;
        ///
        var myMathSpaceInfo = myMathGroup.add("group");
        myMathSpaceInfo.enabled = false;
        myMathSpaceInfo.orientation = "row";
        if (myMathSpaceIndex < myAllSpaces.length && myMathSpaceIndex >= 0) myMathSpaceInfo_selection = myMathSpaceIndex; else myMathSpaceInfo_selection = myDefaultMathSpace;
        myMathSpaceInfo.add("statictext", undefined, "Шпации вокруг математических знаков");
        var myMathSpace = myMathSpaceInfo.add("dropdownlist", undefined, myAllSpaces, { multiselect: false });
        myMathSpace.minimumSize.width = myMathSpace.maximumSize.width = 170;
        myMathSpace.selection = myMathSpaceInfo_selection;
        myMathSpace.enabled = false;
        var myInfoAboutProcFormulas = myMathSpaceInfo.add("checkbox", undefined, "Отмечать цветом обработанные абзацы");
        //var myInfoAboutProcFormulas = myMathSpaceInfo.add ("checkbox", undefined, "Отмечать цветом...");
        myInfoAboutProcFormulasValue == 1 ? myInfoAboutProcFormulas.value = true : myInfoAboutProcFormulas.value = false;
        myInfoAboutProcFormulas.helpTip = "При установке этого флажка обработанные абзацы с формулами будут отмечены цветом 'myProcessedFormula'.";
        //===
        MathSignsAreTakedIntoAccount.onClick = function () { // MathSignsAreTakedIntoAccount.onClick
            if (MathSignsAreTakedIntoAccount.value == true) {
                MathSignsAreTakedIntoAccount.value = true;
                TextColorIsTakedIntoAccount.value = false;
            }
            else {
                MathSignsAreTakedIntoAccount.value = false;
                TextColorIsTakedIntoAccount.value = true;
            }
        } // MathSignsAreTakedIntoAccount.onClick
        ////
        TextColorIsTakedIntoAccount.onClick = function () { // TextColorIsTakedIntoAccount.onClick
            if (TextColorIsTakedIntoAccount.value == true) { // TextColorIsTakedIntoAccount.value == true 
                MathSignsAreTakedIntoAccount.value = false;
                TextColorIsTakedIntoAccount.value = true;
            } // TextColorIsTakedIntoAccount.value == true 
            else {
                MathSignsAreTakedIntoAccount.value = true;
                TextColorIsTakedIntoAccount.value = false;
            }
        } // TextColorIsTakedIntoAccount.onClick
        ///
        myFormulaToProcess.onClick = function () { // myFormulaToProcess.onClick
            if (myFormulaToProcess.value != true) { // != true
                myFormulaToProcessValue = false;
                myClean.value = ChistkaNow;
                myClean.enabled = true;
                c_options.enabled = true;
                myTypographica.value = OformlNow;
                myTypographica.enabled = true;
                t_options.enabled = true;

                myTireGroup.enabled = true;
                myCommaAndTireGroup.enabled = true;
                myFIOGroup.enabled = true;
                myProcGroup.enabled = true;
                myCurrGroup.enabled = true;
                myPhone.value = PhoneNow;
                myPhone.enabled = true;
                p_options.enabled = true;
                myQuery.value = QueryNow;
                myQuery.enabled = true;
                q_options.enabled = true;

                spationsToSpace.enabled = true;
                spaceSelSlider.enabled = true;
                mySpaceProc.enabled = true;
                slider.enabled = true;
                myTireInDialog.enabled = true;
                ///
                MathSignsAreTakedIntoAccount.enabled = false;
                TextColorIsTakedIntoAccount.enabled = false;
                myMathSpaceInfo.enabled = false;
                myMathSpace.enabled = false;
                myInfoAboutProcFormulas.enabled = false;
            } // != true
            else {
                MathSignsAreTakedIntoAccount.enabled = true;
                TextColorIsTakedIntoAccount.enabled = true;
                myMathSpaceInfo.enabled = true;
                myInfoAboutProcFormulas.enabled = true;
                myMathSpace.enabled = true;
                ///
                myFormulaToProcessValue = true;
                ChistkaNow = myClean.value; myClean.value = false; myClean.enabled = false; c_options.enabled = false;
                OformlNow = myTypographica.value; myTypographica.value = false; myTypographica.enabled = false; t_options.enabled = false;
                myTireGroup.enabled = false;
                myCommaAndTireGroup.enabled = false;
                myFIOGroup.enabled = false;
                myProcGroup.enabled = false;
                myCurrGroup.enabled = false;
                PhoneNow = myPhone.value; myPhone.value = false; myPhone.enabled = false; p_options.enabled = false;
                QueryNow = myQuery.value; myQuery.value = false; myQuery.enabled = false; q_options.enabled = false;

                spationsToSpace.enabled = false;
                spaceSelSlider.enabled = false;
                mySpaceProc.enabled = false;
                slider.enabled = false;
                myTireInDialog.enabled = false;
            }
        }  // myFormulaToProcess.onClick
        //==========================
        var phone = tpanel.add("tab", undefined, "Обработка телефонных номеров");
        phone.alignChildren = "left";
        var myPhone = phone.add("checkbox", undefined, "Выполнить выбранные операции");
        myPhone_value == 1 ? myPhone.value = true : myPhone.value = false;
        var p_options = phone.add("panel", undefined, "");
        p_options.alignChildren = ["fill", "fill"];
        ///
        NumberSeparatorInText = p_options.add("group");
        NumberSeparatorInText.alignChildren = ["fill", "fill"];
        NumberSeparatorInText.orientation = "column";
        MesssageAboutSepInText = NumberSeparatorInText.add("statictext", tabSize, "Разделитель групп цифр в обрабатываемых номерах:");
        SeparatorInTextAsRadioButtons = NumberSeparatorInText.add("group");
        SeparatorInTextAsRadioButtons.alignChildren = ["fill", "fill"];
        SeparatorInTextAsRadioButtons.orientation = "row";
        var InTextSepIsSpace = SeparatorInTextAsRadioButtons.add("radiobutton", undefined, "Пробел или фигурная шпация");
        InTextSepIsSpace_value == 1 ? InTextSepIsSpace.value = true : InTextSepIsSpace.value = false;
        var InTextSepIsDash = SeparatorInTextAsRadioButtons.add("radiobutton", undefined, "Дефис, минус, тире");
        InTextSepIsDash_value == 1 ? InTextSepIsDash.value = true : InTextSepIsDash.value = false;
        var InTextSepIsDot = SeparatorInTextAsRadioButtons.add("radiobutton", undefined, "Точка");
        InTextSepIsDot_value == 1 ? InTextSepIsDot.value = true : InTextSepIsDot.value = false;
        separatorP = p_options.add("panel"); // Помещаем на экран горизонтальную линию
        separatorP.minimumSize.height = separatorP.maximumSize.height = 1;
        var NumberSeparator = p_options.add("group");
        NumberSeparator.alignChildren = ["fill", "fill"];
        NumberSeparator.orientation = "column";
        MesssageAboutSep = NumberSeparator.add("statictext", tabSize, "Разделитель групп цифр в обработанных номерах:");
        SeparatorInProsessedTextAsRadioButtons = NumberSeparator.add("group");
        SeparatorInProsessedTextAsRadioButtons.alignChildren = ["fill", "fill"];
        var SepIsSpace = SeparatorInProsessedTextAsRadioButtons.add("radiobutton", undefined, "Фигурная шпация");
        SepIsSpace_value == 1 ? SepIsSpace.value = true : SepIsSpace.value = false;
        var SepIsDefis = SeparatorInProsessedTextAsRadioButtons.add("radiobutton", undefined, "Дефис");
        SepIsDefis_value == 1 ? SepIsDefis.value = true : SepIsDefis.value = false;
        var SepIsMinus = SeparatorInProsessedTextAsRadioButtons.add("radiobutton", undefined, "Минус");
        SepIsMinus_value == 1 ? SepIsMinus.value = true : SepIsMinus.value = false;
        var SepIsTire = SeparatorInProsessedTextAsRadioButtons.add("radiobutton", undefined, "Тире");
        SepIsTire_value == 1 ? SepIsTire.value = true : SepIsTire.value = false;
        var SepIsDot = SeparatorInProsessedTextAsRadioButtons.add("radiobutton", undefined, "Точка");
        SepIsDot_value == 1 ? SepIsDot.value = true : SepIsDot.value = false;
        separatorQ = p_options.add("panel"); // Помещаем на экран горизонтальную линию
        separatorQ.minimumSize.height = separatorQ.maximumSize.height = 1;
        var my11Digits = p_options.add("group");
        my11Digits.alignChildren = ["fill", "fill"];
        my11Digits.orientation = "column";
        var my11D = my11Digits.add("checkbox", undefined, "Одиннадцать идущих подряд цифр считать номером телефона");
        my11D_value == 1 ? my11D.value = true : my11D.value = false;
        separatorZ = p_options.add("panel"); // Помещаем на экран горизонтальную линию
        separatorZ.minimumSize.height = separatorZ.maximumSize.height = 1;
        var myNmrBreak = p_options.add("group");
        myNmrBreak.alignChildren = ["fill", "fill"];
        myNmrBreak.orientation = "column";
        var myTelNumBreak = myNmrBreak.add("checkbox", undefined, "Разрешён перенос номера на следующую строку");
        myTelNumBreak_value == 1 ? myTelNumBreak.value = true : myTelNumBreak.value = false;
        //===============================================
        var myBtnUp = File(decodeURI(myScriptFolder + "/Picts/" + "ArrowUp-16.png"));
        var myBtnDn = File(decodeURI(myScriptFolder + "/Picts/" + "ArrowDn-16.png"));
        var myBtnDel = File(decodeURI(myScriptFolder + "/Picts/" + "DelBtn.png"));
        var myBtnExp = File(decodeURI(myScriptFolder + "/Picts/" + "document-export.png"));
        var myBtnImp = File(decodeURI(myScriptFolder + "/Picts/" + "document-import.png"));
        //var query = tpanel.add ("tab", undefined, "\u00A0\u00A0Поиск-замена\u00A0\u00A0");
        var query = tpanel.add("tab", undefined, "Поиск и замена");
        //query.alignChildren = "right";
        query.alignChildren = "left";
        //query.alignChildren = ["fill", "fill"];
        var myCheckAndButton = query.add("group");
        myCheckAndButton.orientation = "row";
        myCheckAndButton.alignChildren = ["fill", "fill"];
        mySizeOfThreeButtons = [0, 0, 67, 25];
        var LeftPanelWidth;
        LeftPanelWidth = GetTheValue(LeftPanelSize);

        var myQuery = myCheckAndButton.add("checkbox", [0, 0, LeftPanelWidth, 25], "Выполнить выбранные операции");
        myQuery.helpTip = CurrentQueryInfo;
        //var myQuery = myCheckAndButton.add ("checkbox", undefined, "Выполнить выбранные операции"); 
        myQuery_value == 1 ? myQuery.value = true : myQuery.value = false;
        //try { var myUpButton = myCheckAndButton.add("iconbutton", [0,0,25,25], myBtnUp); } catch (e) { var myUpButton = myCheckAndButton.add ("button", [0,0,25,25], "U"); } 
        myUpButton = makeImageButton(myBtnUp, true, 1, myCheckAndButton, myUpButtonOnClick);
        myUpButton.helpTip = "Перемещение выбранной строки вверх";
        //try { var myDnButton = myCheckAndButton.add("iconbutton", [0,0,25,25], myBtnDn); } catch (e) { var myDnButton = myCheckAndButton.add ("button", [0,0,25,25], "D"); }
        myDnButton = makeImageButton(myBtnDn, true, 1, myCheckAndButton, myDnButtonOnClick);
        myDnButton.helpTip = "Перемещение выбранной строки вниз";
        //try { var myDelButton = myCheckAndButton.add("iconbutton", [0,0,25,25], myBtnDel); } catch (e) { var myDelButton = myCheckAndButton.add ("button", [0,0,25,25], "X"); }
        myDelButton = makeImageButton(myBtnDel, true, 1, myCheckAndButton, myDelButtonOnClick);
        myDelButton.helpTip = "Удаление выбранной строки";
        var myStartQueriesButton = myCheckAndButton.add("button", [0, 0, 25, 25], "S");
        myStartQueriesButton.helpTip = "Поместить выбранный запрос в список,\nобрабатываемый до начала работы скрипта";
        var myFinishQueriesButton = myCheckAndButton.add("button", [0, 0, 25, 25], "F");
        myFinishQueriesButton.helpTip = "Поместить выбранный запрос в список,\nобрабатываемый после работы скрипта";
        //try { var mySaveSetButton = myCheckAndButton.add("iconbutton", [0,0,25,25], myBtnExp); } catch (e) { var mySaveSetButton = myCheckAndButton.add ("button", [0,0,25,25], "S"); }
        mySaveSetButton = makeImageButton(myBtnExp, true, 1, myCheckAndButton, mySaveSetButtonOnClick);
        mySaveSetButton.helpTip = "Сохранение этого списка";
        //try { var myLoadSetButton = myCheckAndButton.add("iconbutton", [0,0,25,25], myBtnImp); } catch (e) { var myLoadSetButton = myCheckAndButton.add ("button", [0,0,25,25], "L"); }
        myLoadSetButton = makeImageButton(myBtnImp, true, 1, myCheckAndButton, myLoadSetButtonOnClick);
        myLoadSetButton.helpTip = "Загрузка подготовленного ранее списка";
        var myTreeAndList = query.add("group");
        myTreeAndList.orientation = "row";
        var q_options = myTreeAndList.add("group", undefined, "");
        q_options.alignChildren = ["fill", "fill"];
        var myTree = q_options.add("treeview", [0, 0, LeftPanelWidth, 350]);
        var myUserTextFolder = Folder(app.scriptPreferences.scriptsFolder.parent.parent + "/Find-Change Queries/Text/");
        var myUserGrepFolder = Folder(app.scriptPreferences.scriptsFolder.parent.parent + "/Find-Change Queries/Grep/");
        if (parseIntAppVersion == 5) {
            var myAppTextFolder = Folder(app.filePath + "/Presets/Find-Change Queries/Text/");
            var myAppGrepFolder = Folder(app.filePath + "/Presets/Find-Change Queries/Grep/");
        }
        else {
            var myAppTextFolder = Folder(app.filePath + "/Presets/Find-Change Queries/Text/" + $.locale);
            var myAppGrepFolder = Folder(app.filePath + "/Presets/Find-Change Queries/Grep/" + $.locale);
        }
        var myTQ = myTree.add("node", "Операции поиска-замены текста");
        myTextQueSources = [decodeURI(myAppTextFolder) + "/", decodeURI(myUserTextFolder) + "/"];
        myGrepQueSources = [decodeURI(myAppGrepFolder) + "/", decodeURI(myUserGrepFolder) + "/"];
        if (myTextQueSources.length > 0) { // myTextQueSources.length > 0
            for (i = 0; i < myTextQueSources.length; i++) { // i < myTextQueSources.length
                var myNodeT = myTQ.add("node", myTextQueSources[i]);
                var myTxtDir = new Folder(myTextQueSources[i]);
                var myListQ1 = myTxtDir.getFiles("*.xml");
                var myArrT = [];
                for (t = 0; t < myListQ1.length; t++) { // t < myListQ1.length
                    myArrT = decodeURI(myListQ1[t]).split("/");
                    myNodeT.add("item", myArrT[myArrT.length - 1]);
                } // t < myListQ1.length
            } // i < myTextQueSources.length
        } // myTextQueSources.length > 0
        var myQueryList = myTreeAndList.add("listbox", [0, 0, 240, 350]);
        for (i = 0; i < myQueCntr; i++) {
            myQueryList.add("item", mySavedQueryList[i]);
        }
        var myNmbrOfS = 0, myNmbrOfF = 0, mySepLineIndex = 0, myListHasSepLine = false, myTempQueLine;
        for (j = 0; j < myQueryList.items.length; j++) { // j < myQueryList.length
            if (myQueryList.items[j].text[0] == "S") myNmbrOfS++;
            if (myQueryList.items[j].text[0] == "F") myNmbrOfF++;
            if (myQueryList.items[j].text[0] == ">") { mySepLineIndex = j; myListHasSepLine = true; }
        } // j < myQueryList.length
        if (myQueryList.items.length == 0) StateOfControlButtons(false);
        ///
        if (myGrepQueSources.length > 0) { // myGrepQueSources.length
            var myGQ = myTree.add("node", "Обработка текста grep-запросами");
            for (i = 0; i < myGrepQueSources.length; i++) { // i < myGrepQueSources.length
                var myNodeG = myGQ.add("node", myGrepQueSources[i]);
                var myGrpDir = new Folder(myGrepQueSources[i]);
                var myListQ2 = myGrpDir.getFiles("*.xml");
                var myArrG = [];
                for (t = 0; t < myListQ2.length; t++) { // t < myListQ2.length
                    myArrG = decodeURI(myListQ2[t]).split("/");
                    myNodeG.add("item", myArrG[myArrG.length - 1]);
                } // t < myListQ2.length
            } //  i < myGrepQueSources.length
        } // myGrepQueSources.length
        ///
        myStartQueriesButton.onClick = function () { // myStartQueriesButton.onClick
            myQueryList.selection = null;
            try { if (myTree.selection.type == "node") return; } catch (e) { return; }
            var mySelectedLine = String(myTree.selection.parent);
            if (mySelectedLine.indexOf("/Find-Change Queries/GREP/") != -1 || mySelectedLine.indexOf("/Find-Change Queries/Grep/") != -1) {
                myQueryList.add("item", "S:G: " + String(myTree.selection));
                myPlaceItemsInQueList("S");
                myOKButtonState();
                return;
            }
            if (mySelectedLine.indexOf("/Find-Change Queries/Text/") != -1) {
                myQueryList.add("item", "S:T: " + String(myTree.selection));
                myPlaceItemsInQueList("S");
                myOKButtonState();
                return;
            }
            return;
        } // myStartQueriesButton.onClick
        ///
        myFinishQueriesButton.onClick = function () { // myFinishQueriesButton.onClick
            myQueryList.selection = null;
            try { if (myTree.selection.type == "node") return; } catch (e) { return; }
            var mySelectedLine = String(myTree.selection.parent);
            if (mySelectedLine.indexOf("/Find-Change Queries/GREP/") != -1 || mySelectedLine.indexOf("/Find-Change Queries/Grep/") != -1) {
                myQueryList.add("item", "F:G: " + String(myTree.selection));
                myPlaceItemsInQueList("F");
                myOKButtonState();
                return;
            }
            if (mySelectedLine.indexOf("/Find-Change Queries/Text/") != -1) {
                myQueryList.add("item", "F:T: " + String(myTree.selection));
                myPlaceItemsInQueList("F");
                myOKButtonState();
                return;
            }
            return;
        } // myFinishQueriesButton.onClick
        ///
        function myPlaceItemsInQueList(index) { // myPlaceItemsInQueList
            if (index == "F") { // index == "F"
                myNmbrOfF++;
                if (myNmbrOfS != 0 && myListHasSepLine == false) { // myListHasSepLine == false
                    myTempQueLine = myQueryList.items[myQueryList.items.length - 1].text;
                    myListHasSepLine = true;
                    myQueryList.add("item", ""); // это для строки разделителя. Её пока нет в списке   
                    myLastShiftIndex = myQueryList.items.length - 2;
                    for (var ii = myNmbrOfS - 1; ii < myLastShiftIndex; ii++) { // ii < myLastShiftIndex
                        myQueryList.items[ii + 2].text = myQueryList.items[ii].text;
                    } // ii < myLastShiftIndex
                    myQueryList.items[myNmbrOfS].text = ">>>>>>>>>>>>>>>>>>";
                    myQueryList.items[myNmbrOfS + 1].text = myTempQueLine;
                    mySepLineIndex = myNmbrOfS;
                } // myListHasSepLine == false 
                StateOfControlButtons(true);
                myOKButtonState();
                return;
            } // index == "F"
            // если добавлен в конец списка запрос, начинающийся с S, его надо поднять в верхний блок строк, перед разделительной чертой
            myNmbrOfS++;
            myTempQueLine = myQueryList.items[myQueryList.items.length - 1].text;
            if (myNmbrOfF != 0 && myListHasSepLine == false) { // myListHasSepLine == false
                myListHasSepLine = true;
                myQueryList.add("item", ""); // это для строки разделителя. Её пока нет в списке   
                myLastShiftIndex = myQueryList.items.length - 2;
                for (var ii = mySepLineIndex; ii < myLastShiftIndex; ii++) { // ii < myLastShiftIndex
                    myQueryList.items[ii + 2].text = myQueryList.items[ii].text;
                } // ii < myLastShiftIndex
                myQueryList.items[0].text = myTempQueLine;
                myQueryList.items[1].text = ">>>>>>>>>>>>>>>>>>";
                mySepLineIndex = 1;
                StateOfControlButtons(true);
                myOKButtonState();
                return;
            } // myListHasSepLine == false
            if (myListHasSepLine == true) { // myListHasSepLine == true
                myLastShiftIndex = myQueryList.items.length - 1;
                for (var jj = myLastShiftIndex; jj >= mySepLineIndex; jj--) { // jj < myLastShiftIndex
                    try { myQueryList.items[jj].text = myQueryList.items[jj - 1].text; } catch (e) { break; }
                } // jj < myLastShiftIndex
                myQueryList.items[mySepLineIndex].text = myTempQueLine;
                mySepLineIndex++;
            } // myListHasSepLine == true
            StateOfControlButtons(true);
            myOKButtonState();
            return;
        } // myPlaceItemsInQueList  
        ///
        function StateOfControlButtons(status) { // StateOfControlButtons
            myUpButton.enabled = status;
            myDnButton.enabled = status;
            myDelButton.enabled = status;
            //myStartQueriesButton.enabled = status;
            //myFinishQueriesButton.enabled = status;
            mySaveSetButton.enabled = status;
        } // StateOfControlButtons
        /////
        function myDelButtonOnClick() { // myDelButtonOnClick    
            if (myQueryList.selection == null) return; // ничего не выбрано, а кнопка нажата
            var myQLSline = myQueryList.selection;
            // по первому символу выделенной строки определяем, что выбрано -- запрос или линия разделения
            if (myQLSline.text[0] == ">" && (myNmbrOfS != 0 || myNmbrOfF != 0)) return; // выбран разделитель, но еще есть строки. Его удалять не надо
            if (myQLSline.text[0] == ">" && myNmbrOfS == 0 && myNmbrOfF == 0) { myQueryList.remove(myQueryList.items[0]); myListHasSepLine = true; myOKButtonState(); return; }
            if (myQLSline.text[0] == "S") myNmbrOfS--;
            if (myQLSline.text[0] == "F") myNmbrOfF--;
            if (myListHasSepLine == true && myQLSline.text[0] == "S") mySepLineIndex--; // разделитель после удаления строки из верхнего блока надо уменьшить на единицу
            var muSelItem = myQueryList.selection.index;
            myQueryList.remove(myQueryList.items[muSelItem]);
            if (myNmbrOfS == 0 && myListHasSepLine == true) { // myNmbrOfS == 0 && myListHasSepLine == true
                myQueryList.remove(myQueryList.items[0]); // удаляем разделитель в верхней позиции списка. Он не нужен в данном случае
                myListHasSepLine = false;
            } // myNmbrOfS == 0 && myListHasSepLine == true
            if (myNmbrOfF == 0 && myListHasSepLine == true) { // myNmbrOfF == 0 && myListHasSepLine == true
                myQueryList.remove(myQueryList.items[myQueryList.items.length - 1]); // удаляем разделитель внизу списка. Он не нужен в данном случае
                myListHasSepLine = false;
            } // myNmbrOfF == 0 && myListHasSepLine == true
            if (myNmbrOfS == 0 & myNmbrOfF == 0) StateOfControlButtons(false);
            myOKButtonState();
        }  // myDelButton.onClick
        ///
        function myUpButtonOnClick() { // myUpButtonOnClick
            if (myQueryList.selection == null) return; // ничего не выбрано, а кнопка нажата    
            var mySelIndex = myQueryList.selection.index;
            if (mySelIndex == 0) return;
            var myPrevIndex = mySelIndex;
            myPrevIndex--;
            if (myQueryList.items[mySelIndex].text[0] == ">" || myQueryList.items[myPrevIndex].text[0] == ">") return; // выбран разделитель или верхний объект второго перечня запросов
            var myTmpL = myQueryList.items[myPrevIndex].text;
            myQueryList.items[myPrevIndex].text = myQueryList.items[mySelIndex].text;
            myQueryList.items[mySelIndex].text = myTmpL;
            myQueryList.selection = [myPrevIndex];
        } //  myUpButton.onClick
        ///
        function myDnButtonOnClick() { // myDnButtonOnClick
            if (myQueryList.selection == null) return; // ничего не выбрано, а кнопка нажата    
            var mySelIndex = myQueryList.selection.index;
            if (mySelIndex == myQueryList.items.length - 1) return;
            var myNextIndex = mySelIndex;
            myNextIndex++;
            if (myQueryList.items[mySelIndex].text[0] == ">" || myQueryList.items[myNextIndex].text[0] == ">") return; // выбран разделитель или нижний объект первого перечня запросов
            var myTmpL = myQueryList.items[myNextIndex].text;
            myQueryList.items[myNextIndex].text = myQueryList.items[mySelIndex].text;
            myQueryList.items[mySelIndex].text = myTmpL;
            myQueryList.selection = [myNextIndex];
        } //  myDnButton.onClick
        ///
        function mySaveSetButtonOnClick() { // mySaveSetButtonOnClick
            if (myQueryList.items.length == 0) return;
            var myDateF = new Date;
            var myDayF = myDateF.getDate();
            if (myDayF < 10) myDayF = "0" + myDayF;
            var myMonthF = myDateF.getMonth();
            myMonthF++; // январь имеет индекс 0
            if (myMonthF < 10) myMonthF = "0" + myMonthF;
            var myHourF = myDateF.getHours();
            if (myHourF < 10) myHourF = "0" + myHourF;
            var myMinuteF = myDateF.getMinutes();
            if (myMinuteF < 10) myMinuteF = "0" + myMinuteF;
            var mySecondeF = myDateF.getSeconds();
            if (mySecondeF < 10) mySecondeF = "0" + mySecondeF;
            ///	
            mySpecialQName = "QueForDoTextOK" + "@" + myDayF + "." + myMonthF + "-" + myHourF + "." + myMinuteF + "." + mySecondeF + ".quedtok";
            var myNameTmpQ = prompt("Дайте этому списку запросов поиска/замены осмысленное имя.\nПредлагаемое имя содержит дату и время создания файла.\nДля отказа от сохранения списка нажмите кнопку 'Cancel'.", mySpecialQName, myProgramTitulWholeText);
            if (myNameTmpQ == null || myNameTmpQ.length == 0) return;
            if (myNameTmpQ.indexOf('.quedtok') == -1) myNameTmpQ += '.quedtok';
            mySpecialQName = myNameTmpQ;
            // плюс в начале названия означает, что сохраняется не только файл запроса, но и все запросы тоже. А потом и dtok-файл, в котором эта очерёдность запросов используется.
            if (myNameTmpQ[0] != "+") { // myNameTmpQ[0] != "+"
                var myFilePathQSave = decodeURI(myScriptFolder + "/" + mySpecialQName);
                var myQueSetSave = new File(myFilePathQSave);
                tt = myQueSetSave.open("w");
                myQueSetSave.writeln(myQueryList.items.length);
                for (i = 0; i < myQueryList.items.length; i++)  myQueSetSave.writeln(myQueryList.items[i]);
                myQueSetSave.close();
                CurrentQueryInfo = "Файл запросов: " + mySpecialQName;
                myQuery.helpTip = CurrentQueryInfo;
                alert("Список запросов поиска/замены сохранён в файле\n" + mySpecialQName, myProgramTitulWholeText);
            } // myNameTmpQ[0] != "+"
            else { // myNameTmpQ[0] == "+"
                // сохраним список запросов...    
                var myFilePathQSave = decodeURI(myScriptFolder + "/" + mySpecialQName);
                var myQueSetSave = new File(myFilePathQSave);
                tt = myQueSetSave.open("w");
                myQueSetSave.writeln(myQueryList.items.length);
                for (i = 0; i < myQueryList.items.length; i++)  myQueSetSave.writeln(myQueryList.items[i]);
                myQueSetSave.close();
                // ... и сами запросы
                mySpecFolderName = decodeURI(myFilePathQSave).replace(/\.quedtok$/, "");
                Folder(mySpecFolderName).create();
                mySpecTextFolder = mySpecFolderName + "/" + "Text" + "/";
                Folder(mySpecTextFolder).create();
                mySpecGrepFolder = mySpecFolderName + "/" + "Grep" + "/";
                Folder(mySpecGrepFolder).create();
                var myPlusQueSetSave = new File(mySpecFolderName + "/" + mySpecialQName);
                tt = myPlusQueSetSave.open("w");
                myPlusQueSetSave.writeln(myQueryList.items.length);
                for (i = 0; i < myQueryList.items.length; i++)  myPlusQueSetSave.writeln(myQueryList.items[i]);
                myPlusQueSetSave.close();
                var myCurQueName;
                var myCurQueRezName;
                // разносим запросы по каталогам /Text и /Grep
                for (jj = 0; jj < myQueryList.items.length; jj++) { // jj < myQueryList.items.length
                    if (myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "T") { // myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "T"
                        myCurQueName = myQueryList.items[jj].text.replace("S:T: ", "");
                        myCurQueRezName = "";
                        myCurQueRezName = myTextQueSources[0] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecTextFolder + myCurQueName);
                        myCurQueRezName = "";
                        myCurQueRezName = myTextQueSources[1] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecTextFolder + myCurQueName);
                        continue;
                    } // myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "T" 
                    if (myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "T") { // myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "T"   
                        myCurQueName = myQueryList.items[jj].text.replace("F:T: ", "");
                        myCurQueRezName = "";
                        myCurQueRezName = myTextQueSources[0] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecTextFolder + myCurQueName);
                        myCurQueRezName = "";
                        myCurQueRezName = myTextQueSources[1] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecTextFolder + myCurQueName);
                        continue;
                    }  // myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "T"  
                    if (myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "G") { // myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "G"
                        myCurQueName = myQueryList.items[jj].text.replace("S:G: ", "");
                        myCurQueRezName = "";
                        myCurQueRezName = myGrepQueSources[0] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecGrepFolder + myCurQueName);
                        myCurQueRezName = "";
                        myCurQueRezName = myGrepQueSources[1] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecGrepFolder + myCurQueName);
                        continue;
                    } // myQueryList.items[jj].text[0] == "S" && myQueryList.items[jj].text[2] == "G"
                    if (myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "G") { // myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "G"        
                        myCurQueName = myQueryList.items[jj].text.replace("F:G: ", "");
                        myCurQueRezName = "";
                        myCurQueRezName = myGrepQueSources[0] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecGrepFolder + myCurQueName);
                        myCurQueRezName = "";
                        myCurQueRezName = myGrepQueSources[1] + myCurQueName;
                        myTxtFile = File(myCurQueRezName);
                        myTxtFile.copy(mySpecGrepFolder + myCurQueName);
                        continue;
                    } // myQueryList.items[jj].text[0] == "F" && myQueryList.items[jj].text[2] == "G" 
                    if (myQueryList.items[jj].text[2] == ">") { continue; }
                    alert("Ошибка в структуре данных списка запросов");
                } // jj < myQueryList.items.length
            } // myNameTmpQ[0] == "+"
            myNeedToSaveDtokToo = true; // для сохранения dtok-файла в каталоге этого списка запросов
        } // mySaveSetButton.onClick
        ///
        //myLoadSetButton.onClick = function() { // myLoadSetButton.onClick 
        function myLoadSetButtonOnClick() { // myLoadSetButtonOnClick    
            var myScrQFolder = new Folder(myScriptFile.path);
            mySearchQMask = "*.quedtok";
            var myQueList = myScrQFolder.getFiles(mySearchQMask);
            if (myQueList.length == 0) { // myQueList.length == 0
                alert("Нет файлов с запросами поиска/замены.", myProgramTitul);
                return;
            } //  myQueList.length == 0
            if (myQueList.length > 0) { // > 0
                var mySetQFile = File(decodeURI(myScrQFolder + "/")).openDlg('Файлы запросов поиска/замены для скрипта DoTextOK', 'quedtok: *.quedtok'); //  myFilePath
                if (mySetQFile == null) return;
            } // > 0
            var myArrForQSplit = [];
            myArrForQSplit = decodeURI(mySetQFile).split("/");
            var myParaFileQName = myArrForQSplit[myArrForQSplit.length - 1];
            if (!mySetQFile.exists) { alert("Не удалось прочитать выбранный файл с запросами поиска/замены."); return; }
            else { //File.exists
                mySetQFile.open("r");
                myQueCntr = mySetQFile.readln();
                mySavedQueryList = new Array;
                for (i = 0; i < myQueCntr; i++)  mySavedQueryList[i] = mySetQFile.readln();
                mySetQFile.close();
                CurrentQueryInfo = "Файл запросов: " + myParaFileQName;
                myQuery.helpTip = CurrentQueryInfo;
            } //File.exists
            var myQueListCounter = myQueryList.items.length;
            for (k = 0; k < myQueListCounter; k++) {
                myQueryList.remove(myQueryList.items[0]);
            }
            for (i = 0; i < myQueCntr; i++) { myQueryList.add("item", mySavedQueryList[i]); }
            myNmbrOfS = 0, myNmbrOfF = 0, mySepLineIndex = 0, myListHasSepLine = false;
            for (j = 0; j < myQueryList.items.length; j++) { // j < myQueryList.length
                if (myQueryList.items[j].text[0] == "S") myNmbrOfS++;
                if (myQueryList.items[j].text[0] == "F") myNmbrOfF++;
                if (myQueryList.items[j].text[0] == ">") { mySepLineIndex = j; myListHasSepLine = true; }
            } // j < myQueryList.length
            StateOfControlButtons(true);
            myOKButtonState();
        } // myLoadSetButton.onClick 
        ////
        //===============================================
        var myAllButtonsAndCopyrightInfo = win.add("group");
        myAllButtonsAndCopyrightInfo.alignChildren = ["fill", "fill"];
        myAllButtonsAndCopyrightInfo.orientation = "row";
        var myButtonSize = [0, 0, GetTheValue(ButtonSize), 30];

        var myInfoButton = File(decodeURI(myScriptFolder + "/Picts/" + "InfoPict.png"));
        myWelcomeInfo = makeImageButton(myInfoButton, false, 4, myAllButtonsAndCopyrightInfo, myInfoAboutSites);
        //try { var myWelcomeInfo = myAllButtonsAndCopyrightInfo.add("iconbutton", [0,0,33,24], myInfo); } catch (e) { var myWelcomeInfo = myAllButtonsAndCopyrightInfo.add ("button", [0,0,33,25], "Info"); }
        //~ var SpaceAfterInfo = myAllButtonsAndCopyrightInfo.add ("statictext");
        //~ SpaceAfterInfo = myWhiteSpace;
        myOKButon = myAllButtonsAndCopyrightInfo.add("button", myButtonSize, "Обработать", { name: "ok" });
        myCancelButon = myAllButtonsAndCopyrightInfo.add("button", myButtonSize, "В другой раз", { name: "cancel" });
        myReset = myAllButtonsAndCopyrightInfo.add("button", myButtonSize, "Сброс");
        mySaveButon = myAllButtonsAndCopyrightInfo.add("button", myButtonSize, "Сохранить");

        if (myCleanValue == 0) { myClean.value = false; c_options.enabled = false; myOKButtonState(); }
        if (myCleanValue == 1) { myClean.value = true; c_options.enabled = true; myOKButtonState(); }
        if (myTypoValue == 0) { myTypographica.value = false; t_options.enabled = false; myOKButtonState(); }
        if (myTypoValue == 1) { myTypographica.value = true; t_options.enabled = true; myOKButtonState(); }
        if (myPhoneValue == 0) { myPhone.value = false; p_options.enabled = false; myOKButtonState(); }
        if (myPhoneValue == 1) { myPhone.value = true; p_options.enabled = true; myOKButtonState(); }
        if (mySpatiumValue == 0) { mySpatium.value = false; s_options.enabled = false; myOKButtonState(); }
        if (mySpatiumValue == 1) { mySpatium.value = true; s_options.enabled = true; myOKButtonState(); }
        if (myQueryValue == 0) { myQuery.value = false; myAllButtonHide(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList); myOKButtonState(); }
        if (myQueryValue == 1) { myQuery.value = true; myAllButtonShow(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList); myOKButtonState(); }
        //////////
        //~ myWelcomeInfo.onClick = function () { // myWelcomeInfo.onClick
        //~ myInfoAboutSites();
        //~ } // myWelcomeInfo.onClick 
        //////////
        myClean.onClick = function () { // myClean.onClick
            if (myClean.value != false) {
                c_options.enabled = true;
                myOKButtonState();
            }
            else {
                c_options.enabled = false;
                myOKButtonState();
            }
        } // myClean.onClick
        ////////
        my11D.onClick = function () { // my11D.onClick
            my11D_value = my11D.value;
        } // my11D
        ////////
        myTelNumBreak.onClick = function () { // myTelNumBreak.onClick
            myTelNumBreak_value = myTelNumBreak.value;
        } // myTelNumBreak
        /////////////////////////////////////
        oneStyle.onClick = function () { // oneStyle.onClick   
            oneStyle.value == false ? myList.enabled = false : myList.enabled = true;
        } // oneStyle.onClick
        ////
        setLang.onClick = function () { // setLang.onClick   
            setLang.value == false ? myLanguageList.enabled = false : myLanguageList.enabled = true;
            if (myLanguageList.selection == 0 || setLang.value == false) setquotes.enabled = false
            else setquotes.enabled = true;
        } // setLang.onClick
        ////////////////////////////////////
        hyplinks.onClick = function () { myOKButtonState(); }
        scale100.onClick = function () { myOKButtonState(); }
        setquotes.onClick = function () { myOKButtonState(); }
        fixOneLetter.onClick = function () { // fixOneLetter.onClick
            if (fixOneLetter.value != true) fixOneLetter_value = 0;
            else fixOneLetter_value = 1;
            if (fixOneLetter_value == 0 && fixTwoLetter_value == 0) DropPanel.enabled = false
            else DropPanel.enabled = true;
            myOKButtonState();
        } // fixOneLetter.onClick
        fixTwoLetter.onClick = function () { // fixTwoLetter.onClick
            if (fixTwoLetter.value != true) fixTwoLetter_value = 0;
            else fixTwoLetter_value = 1;
            //if (fixOneLetter.value == false && fixTwoLetter.value == false) DropPanel.enabled = false
            if (fixOneLetter_value == 0 && fixTwoLetter_value == 0) DropPanel.enabled = false
            else DropPanel.enabled = true;
            myOKButtonState();
        } // fixTwoLetter.onClick
        fixDigitAndWord.onClick = function () { myOKButtonState(); }
        bull2text.onClick = function () { myOKButtonState(); }
        WordAndLetterSpace.onClick = function () { myOKButtonState(); }
        nobreakSpace.onClick = function () { myOKButtonState(); }
        //////
        charStyles.onClick = function () { // charStyles.onClick
            if (charStyles.value != true) charStyles_value = 0;
            else charStyles_value = 1;
            charStyles.value == false ? noParagraphs.enabled = false : noParagraphs.enabled = true;
            myOKButtonState();
        } // charStyles.onClick
        //////
        useUnderline.onClick = function () { // useUnderline.onClick 
            if (useUnderline.value != true) useUnderline_value = 0;
            else useUnderline_value = 1;
            myOKButtonState();
        } // useUnderline.onClick
        //////
        useCapslock.onClick = function () { // useCapslock.onClick   
            if (useCapslock.value != true) useCapslock_value = 0;
            else useCapslock_value = 1;
            myOKButtonState();
        } // useCapslock.onClick
        ////////////////////////////////////
        tireAndSpatium.onClick = function () { // tireAndSpatium.onClick    
            if (tireAndSpatium.value != true) {
                tireAndSpatium_value = 0;
                myTireSpatiumGroup.enabled = false;
                //myTireInDialog.enabled = false;    
                changeSpationsToSpace.enabled = false;
            }
            else {
                tireAndSpatium_value = 1;
                myTireSpatiumGroup.enabled = true;
                //myTireInDialog.enabled = true;      
                changeSpationsToSpace.enabled = true;
            }
            myOKButtonState();
        } // tireAndSpatium.onClick
        ////////////////////////////////////
        commatire.onClick = function () { // commatire.onClick    
            if (commatire.value != true) commatire_value = 0;
            else commatire_value = 1;
            commatire.value == false ? myCommaAndTire.enabled = false : myCommaAndTire.enabled = true;
            myOKButtonState();
        } // commatire.onClick
        ///////////////////////////
        myPhone.onClick = function () { // myPhone.onClick
            if (myPhone.value != false) {
                myPhone.value = true;
                p_options.enabled = true;
            }
            else {
                myPhone.value = false;
                p_options.enabled = false;
            }
            myOKButtonState();
        } // myPhone.onClick
        ////////////////
        initials.onClick = function () { // initials.onClick    
            if (initials.value != true) {
                initials_value = 0;
                myASPushkinFirstSpace.enabled = false;
                myASPushkinSecondSpace.enabled = false;
                myPushkinASFirstSpace.enabled = false;
                myPushkinASSecondSpace.enabled = false;
                asPushkin.enabled = false;
                pushkinAS.enabled = false;
            }
            else {
                initials_value = 1;
                myASPushkinFirstSpace.enabled = true;
                myASPushkinSecondSpace.enabled = true;
                myPushkinASFirstSpace.enabled = true;
                myPushkinASSecondSpace.enabled = true;
                asPushkin.enabled = true;
                pushkinAS.enabled = true;
            }
            myOKButtonState();
        } // initials.onClick
        ////////////////////////////////////
        shortword.onClick = function () { // shortword.onClick    
            if (shortword.value != true) shortword_value = 0;
            else shortword_value = 1;
            shortword.value == false ? myShortWordSpace.enabled = false : myShortWordSpace.enabled = true;
            myOKButtonState();
        } // shortword.onClick
        ///////////////////////////////////
        //~ myProcAndPromille.onClick = function () { // myProcAndPromille.onClick    
        //~ if (myProcAndPromille.value != true ) myProcAndPromille_value = 0; 
        //~ else myProcAndPromille_value = 1;  

        //~ myProcAndPromille.value == false ? slitno.enabled = false : slitno.enabled = true;
        //~ myProcAndPromille.value == false ? plusotbivka.enabled = false : plusotbivka.enabled = true;
        //~ myProcAndPromille.value == false ? ProcSpace.enabled = false : ProcSpace.enabled = true;

        //~ myProcAndPromille.value == false ? myProcGroupAction.enabled = false : myProcGroupAction.enabled = true;
        //~ myOKButtonState();
        //~ } // myProcAndPromille.onClick
        //~ ///////////////////////////////////
        //~ myCurrency.onClick = function () { // myCurrency.onClick    
        //~ if (myCurrency.value != true ) myCurrency_value = 0; 
        //~ else myCurrency_value = 1;  

        //~ myCurrency.value == false ? CurrSlitno.enabled = false : CurrSlitno.enabled = true;
        //~ myCurrency.value == false ? CurrOtbivka.enabled = false : CurrOtbivka.enabled = true;
        //~ myCurrency.value == false ? CurrSpace.enabled = false : CurrSpace.enabled = true;

        //~ myCurrency.value == false ? myCurrGroupAction.enabled = false : myCurrGroupAction.enabled = true;
        //~ myOKButtonState();
        //~ } // myCurrency.onClick
        ////////////////////////////////////
        grekCharStyles.onClick = function () { // grekCharStyles.onClick
            if (grekCharStyles.value != true) grekCharStyles_value = 0;
            else grekCharStyles_value = 1;
            grekCharStyles_value == 1 ? grekCharStyles.value = true : grekCharStyles.value = false;
            //grekCharStyles.value == false ? mySpecCharLine.enabled = false : mySpecCharLine.enabled = true;
            myOKButtonState();
        } // grekCharStyles.onClick
        //////////////////////////////////
        noParagraphs.onClick = function () { // noParagraphs.onClick
            if (noParagraphs.value != true) noParagraphs_value = 0;
            else noParagraphs_value = 1;
            noParagraphs_value == 1 ? noParagraphs.value = true : noParagraphs.value = false;
        } // noParagraphs.onClick
        //////////////////////////////////
        myFootnoteGroup.onClick = function () { // myFootnoteGroup.onClick    
            if (myFootnoteGroup.value != true) myFootnoteGroup_value = 0;
            else myFootnoteGroup_value = 1;
            myFootnoteGroup.value == false ? footnoteselection.enabled = false : footnoteselection.enabled = true;
            myOKButtonState();
        } // myFootnoteGroup.onClick
        ///////////////////////////////////
        myTypographica.onClick = function () { // myTypographica.onClick
            if (myTypographica.value != false) t_options.enabled = true;
            else t_options.enabled = false;
            myOKButtonState();
        } // myTypographica.onClick
        ////////////////////////////////////////////////////
        mySpatium.onClick = function () { //mySpatium.onClick
            if (mySpatium.value != false) s_options.enabled = true;
            else s_options.enabled = false;
            myOKButtonState();
        } // mySpatium.onClick
        ///////////////////////////////////
        myQuery.onClick = function () { // myQuery.onClick
            if (myQuery.value == true) {
                myAllButtonShow(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList);
                myQuery.helpTip = CurrentQueryInfo;
                myTreeAndList.enabled = true;
                myLoadSetButton.enabled = true;
            }
            else {
                //myAllButtonHide(myUpButton,myDnButton,myDelButton,myStartQueriesButton,myFinishQueriesButton,mySaveSetButton,myLoadSetButton,myTreeAndList);
                myQuery.helpTip = "";
                myTreeAndList.enabled = false;
                myLoadSetButton.enabled = false;
            }
            myOKButtonState();
        } // myQuery.onClick
        ///////////////////
        //~ win.addEventListener('mouseout', leaveTestPalette);
        //~ ///-- http://forums.adobe.com/message/3462710#3462710
        //~ function leaveTestPalette(/*MouseEvent*/mev)
        //~     {
        //~     if( mev.target instanceof Window ) app.activate();
        //~     }
        ///
        mySaveButon.onClick = function () { // mySaveButon.onClick 
            var myDateF = new Date;
            var myDayF = myDateF.getDate();
            if (myDayF < 10) myDayF = "0" + myDayF;
            var myMonthF = myDateF.getMonth();
            myMonthF++; // январь имеет индекс 0
            if (myMonthF < 10) myMonthF = "0" + myMonthF;
            var myHourF = myDateF.getHours();
            if (myHourF < 10) myHourF = "0" + myHourF;
            var myMinuteF = myDateF.getMinutes();
            if (myMinuteF < 10) myMinuteF = "0" + myMinuteF;
            var mySecondeF = myDateF.getSeconds();
            if (mySecondeF < 10) mySecondeF = "0" + mySecondeF;
            ///	
            mySpecialName = "DoTextOK" + "@" + myDayF + "." + myMonthF + "-" + myHourF + "." + myMinuteF + "." + mySecondeF + ".dtok";
            var myNameTmp = prompt("Дайте этому файлу установок осмысленное имя.\nПредлагаемое имя содержит дату и время создания файла.\nДля отказа от сохранения установок нажмите кнопку 'Cancel'.", mySpecialName, myProgramTitulWholeText);
            if (myNameTmp == null || myNameTmp.length == 0) return;
            if (myNameTmp.indexOf('.dtok') == -1) myNameTmp += '.dtok';
            mySpecialName = myNameTmp;
            var myFilePathSave = decodeURI(myScriptFolder + "/" + mySpecialName);
            var mySetInfoFileSave = new File(myFilePathSave);
            mySaveInfoFile(mySetInfoFileSave);
            myResetOrRename = 2;
            alert("Выбранные установки сохранены в файле\n" + mySpecialName, myProgramTitul);
        } // mySaveButon.onClick
        ///
        myOKButon.onClick = function () { // myOKButon.onClick     
            if (myFormulaToProcessValue == true) { //myFormulaToProcess_value == true
                myClean.value = ChistkaNow;
                myClean.enabled = true;
                c_options.enabled = true;
                myTypographica.value = OformlNow;
                myTypographica.enabled = true;
                t_options.enabled = true;
                myTireGroup.enabled = true;
                myCommaAndTireGroup.enabled = true;
                myFIOGroup.enabled = true;
                myProcGroup.enabled = true;
                myPhone.value = PhoneNow;
                myPhone.enabled = true;
                p_options.enabled = true;
                myQuery.value = QueryNow;
                myQuery.enabled = true;
                q_options.enabled = true;
            } // myFormulaToProcess_value == true    
            mySaveInfoFile(mySetInfoFile);
            win.close();
        } // myOKButon.onClick
        ///////////////
        tabs2spaces.onClick = function () { // tabs2spaces.onClick
            if (tabs2spaces.value != false) {
                tabs2spaces.value = true;
            }
            else {
                tabs2spaces.value = false;
            }
        } // tabs2spaces.onClick
        ///////////////
        startTabs.onClick = function () { // startTabs.onClick
            if (startTabs.value != false) {
                startTabs.value = true;
            }
            else {
                startTabs.value = false;
            }
        } // startTabs.onClick
        ///////////////
        myOneLineIsOneAbzatz.onClick = function () { // myOneLineIsOneAbzatz.onClick
            if (myOneLineIsOneAbzatz.value != false) {
                myOneLineIsOneAbzatz.value = true;
            }
            else {
                myOneLineIsOneAbzatz.value = false;
            }
        } // myOneLineIsOneAbzatz.onClick
        //////////////
        hyphens.onClick = function () { // hyphens.onClick   
            if (hyphens.value != false) {
                hyphens.value = true;
            }
            else {
                hyphens.value = false;
            }
        } // hyphens.onClick
        ///////////////
        digAndChar.onClick = function () { // digAndChar.onClick   
            if (digAndChar.value != false) {
                digAndChar.value = true;
            }
            else {
                digAndChar.value = false;
            }
        } // digAndChar.onClick
        ///////////////
        repChar.onClick = function () { // repChar.onClick
            if (repChar.value != false) {
                repChar.value = true;
                enters.enabled = true;
                shenters.enabled = true;
                spaces.enabled = true;
            }
            else {
                repChar.value = false;
                enters.enabled = false;
                shenters.enabled = false;
                spaces.enabled = false;
            }
        } // repChar.onClick
        ///////////////
        spaces.onClick = function () { // spaces.onClick
            if (spaces.value != false) {
                spaces.value = true;
            }
            else {
                spaces.value = false;
            }
        } // spaces.onClick
        ///////////////
        enters.onClick = function () { // enters.onClick
            if (enters.value != false) {
                enters.value = true;
            }
            else {
                enters.value = false;
            }
        } // enters.onClick
        ///////////////
        shenters.onClick = function () { // shenters.onClick
            if (shenters.value != false) {
                shenters.value = true;
            }
            else {
                shenters.value = false;
            }
        } // shenters.onClick
        ////////////////
        infoAboutFootnotes.onClick = function () { // infoAboutFootnotes.onClick
            var myParent = mySelection.parent;
            if (myParent.constructor.name == "Footnote") myParent = myParent.parent;
            var infoAboutMissedFootnotes = "";
            infoAboutFootnotes.value = false;
            var myFootnotesNumber;
            var myEndnotesNumber;
            var multiParaInfo = "";
            var multiParaFootnote = false;
            var footParaInfo = "\n\nЕсть по крайней мере одна сноска, в которой число абзацев больше одного. Удостоверьтесь, что в настройках оформления сносок есть абзацный стиль для второго и последующих абзацев, и проверьте, что в настройках абзацного стиля первой сноски этот стиль указан как стиль следующего абзаца.";
            if (parseIntAppVersion > 12) { // > 12
                myFootnotesNumber = myParent.footnotes.length;
                myEndnotesNumber = myParent.endnotes.length;
                for (var i = 0; i < myFootnotesNumber; i++) { // i++
                    if (myParent.footnotes[i].paragraphs.length == 1) continue;
                    else {
                        multiParaFootnote = true;
                        break;
                    }
                } // i++
                for (var ii = 0; ii < myEndnotesNumber; ii++) { // ii++
                    if (myParent.endnotes[ii].texts[0].paragraphs.length == 1) continue;
                    else {
                        multiParaFootnote = true;
                        break;
                    }
                } // ii++    
                if (multiParaFootnote && !hiddenMessageAboutFootnotesPara) multiParaInfo = footParaInfo;
                var alertMessage = "";
                if (myFootnotesNumber == 0 && missedFootnotesSigns.length == 0 && myEndnotesNumber == 0) alertMessage = "\nВнутритекстовых и концевых сносок нет.";
                else if (myFootnotesNumber == 0 && missedFootnotesSigns.length == 0 && myEndnotesNumber > 0) alertMessage = "\nВнутритекстовых сносок нет, число концевых сносок  — " + myEndnotesNumber + ".\n" + multiParaInfo;
                else if (myFootnotesNumber == 0 && missedFootnotesSigns.length > 0) alertMessage = "\nПотеряны все внутритекстовые сноски, их число — " + missedFootnotesSigns.length + ".\nКод маркера потерянной внутритекстовой сноски <FFFD> на вкладке поиска текста.";
                else if (myFootnotesNumber > 0 && missedFootnotesSigns.length == 0 && myEndnotesNumber > 0) alertMessage = "\nЧисло внутритекстовых сносок — " + myFootnotesNumber + ", потерянных сносок нет.\nЧисло концевых сносок — " + myEndnotesNumber + ".\n" + multiParaInfo;
                else alertMessage = "\nЧисло внутритекстовых сносок в тексте — " + myFootnotesNumber + ", число потерянных сносок — " + missedFootnotesSigns.length + ".\nКод маркера потерянной внутритекстовой сноски <FFFD> на вкладке поиска текста.\nЧисло концевых сносок " + myEndnotesNumber + ".\n" + multiParaInfo;
                alert(alertMessage, myProgramTitul);
            } // > 12
            else { /// <=12
                myFootnotesNumber = myParent.footnotes.length;
                for (var i = 0; i < myFootnotesNumber; i++) { // i++
                    if (myParent.footnotes[i].paragraphs.length == 1) continue;
                    else {
                        multiParaFootnote = true;
                        break;
                    }
                } // i++    
                if (multiParaFootnote && !hiddenMessageAboutFootnotesPara) multiParaInfo = footParaInfo;
                if (myFootnotesNumber == 0 && missedFootnotesSigns.length == 0 && myEndnotesNumber == 0) alert("\nВ тексте сносок нет." + infoAboutMissedFootnotes, myProgramTitul);
                else if (myFootnotesNumber == 0 && missedFootnotesSigns.length > 0) alert("\nПотеряны все сноски, их число — " + missedFootnotesSigns.length + ".\nКод маркера потерянной внутритекстовой сноски <FFFD> на вкладке поиска текста.", myProgramTitul);
                else if (myFootnotesNumber > 0 && missedFootnotesSigns.length == 0) alert("Число сносок в тексте — " + myFootnotesNumber + ", потерянных сносок нет." + multiParaInfo, myProgramTitul);
                else alert("Число сносок в тексте — " + myFootnotesNumber + ", число потерянных сносок — " + missedFootnotesSigns.length + ".\nКод маркера потерянной внутритекстовой сноски <FFFD> на вкладке поиска текста." + multiParaInfo, myProgramTitul);
            } /// <=12
        } // infoAboutFootnotes.onClick
        ////////////////
        myReset.onClick = function () { // myReset.onClick
            mySetDefaultValues();
            myResetSettings();
            myOKButtonState();
            myResetOrRename = 1;
            var myQueListCounter = myQueryList.items.length;
            for (k = 0; k < myQueListCounter; k++) {
                myQueryList.remove(myQueryList.items[0]);
            }
            myNmbrOfS = 0;
            myNmbrOfF = 0;
            mySepLineIndex = 0;
            myStyleIndex = 1;
            myList.selection = myStyleIndex;
            myListHasSepLine = true;
            //try { if (userLanguage < app.languagesWithVendors.length) myLanguageList_selection = userLanguage; else myLanguageList_selection = 0; } catch (e) { myLanguageList_selection = 0; }
            //try { myLanguageList.selection = myLanguageList_selection; } catch (e) { myLanguageList.selection = 0;}
            myLanguageList_selection = myLanguageList.selection.index;
            myLanguageList.enabled = false; // не будем уж привязываться к setLang.value
            //myLanguageList.selection = myLanguageList_selection;
            alert("Установки программы сброшены.", myProgramTitul);
        } // myReset.onClick
        ////////////////////
        function myOKButtonState() { // myOKButtonState     
            var CTSP, p_opt, t_opt, s_opt, q_opt, c_state, t_state, s_state, p_state, CTS, CTP, CPS, TSP;
            if (myPhone.value == false) p_opt = false; else p_opt = true;
            if (myQuery.value == false) q_opt = false; else q_opt = true;
            if (tireAndSpatium.value == false && spationsToSpace.value == false && commatire.value == false && shortword.value == false && initials.value == false) s_opt = false; else s_opt = true;
            if (fixOneLetter.value == false && fixTwoLetter.value == false && fixDigitAndWord.value == false && WordAndLetterSpace.value == false && nobreakSpace.value == false &&
                myFootnoteGroup.value == false && bull2text.value == false && charStyles.value == false && grekCharStyles.value == false && useUnderline.value == false && useCapslock.value == false) t_opt = false; else t_opt = true;
            c_state = !myClean.value; //  == true, если: 1) флажок "Выполнить выбранные операции" не установлен 2) флажок "Выполнить выбранные операции" установлен, но ни одна операцияя не выбрана 
            t_state = (myTypographica.value == false) || (myTypographica.value == true && t_opt == false);
            s_state = (mySpatium.value == false) || (mySpatium.value == true && s_opt == false);
            p_state = myPhone.value == false || (myPhone.value == true && p_opt == false);
            if ((c_state != true) || (s_state == !true) || (t_state == !true) || (p_state == !true) ||
                (c_options.enabled == true) || (t_options.enabled == true && t_opt == true) || (s_options.enabled == true && s_opt == true) || (p_options.enabled == true && p_opt == true) || (q_opt == true && myQueryList.items.length > 0)) { myOKButon.enabled = true; mySaveButon.enabled = true; } else { myOKButon.enabled = false; mySaveButon.enabled = false; }
        } // myOKButtonState
        ///////////////////
        function myResetSettings() { // myResetSettings
            myClean.value = myClean_value;
            c_options.enabled = c_options_enabled;
            repChar.value = repChar_value;
            myOneLineIsOneAbzatz.value = myOneLineIsOneAbzatz_value;
            tabs2spaces.value = tabs2spaces_value;
            startTabs.value = startTabs_value;
            hyphens.value = hyphens_value;
            bull2text.value = bull2text_value;
            charStyles.value = charStyles_value;
            useUnderline.value = useUnderline_value;
            useCapslock.value = useCapslock_value;
            noParagraphs.value = noParagraphs_value;
            noParagraphs.enabled = true;
            digAndChar.value = digAndChar_value;
            oneStyle.value = oneStyle_value;
            oneStyle.value == false ? myList.enabled = false : myList.enabled = true;
            setLang.value = setLang_value;
            myTypographica.value = myTypographica_value;
            t_options.enabled = t_options_enabled;
            hyplinks.value = hyplinks_value;
            scale100.value = scale100_value;
            fixOneLetter.value = fixOneLetter_value;
            fixTwoLetter.value = fixTwoLetter_value;
            if (fixOneLetter_value == 0 && fixTwoLetter_value == 0) DropPanel.enabled = false  else DropPanel.enabled = true;
            fixDigitAndWord.value = fixDigitAndWord_value;
            WordAndLetterSpace.value = WordAndLetterSpace_value;
            nobreakSpace.value = nobreakSpace_value;
            commonTire.value = commonTire_value;
            minus.value = minus_value;
            tire.value = tire_value;
            defis.value = defis_value;
            myDPdefis.value = myDPdefis_value;
            myDPminus.value = myDPminus_value;
            myDPtire.value = myDPtire_value;
            defisN.value = defisN_value;
            mlnWithoutPoint.value = mlnWithoutPoint_value;
            mlnWithPoint.value = !mlnWithoutPoint.value;
            slitno.selection = slitno_selection;
            CurrSlitno.selection = CurrSlitno_selection;
            if (CurrSlitno_selection == 0) CurrSpace.enabled = false
            else CurrSpace.enabled = true;
            if (slitno_selection == 0) ProcSpace.enabled = false
            else ProcSpace.enabled = true;

            // 19.11.2015 -- по сбросу должен ставиться флажок "Когда рядом запятая или точка и знак сноски"
            myFootnoteGroup.value = myFootnoteGroup_value_start;
            if (myFootnoteGroup.value != true) myFootnoteGroup_value = 0;
            else myFootnoteGroup_value = 1;

            if (myStory.footnotes.length != 0) { // footnotes.length == 0
                //~     if (myFootnoteGroup.value != true ) myFootnoteGroup_value = 0; 
                //~     else  myFootnoteGroup_value = 1; 
                myFootnoteGroup.value == false ? footnoteselection.enabled = false : footnoteselection.enabled = true;
                footnote1.value = footnote1_value;
            } // footnotes.length == 0
            else footnoteselection.enabled = false;
            mySpatium.value = mySpatium_value;
            s_options.enabled = s_options_enabled;
            tireAndSpatium.value = tireAndSpatium_value;
            if (tireAndSpatium.value != true) {
                tireAndSpatium_value = 0;
                myTireSpatiumGroup.enabled = false;
                //myTireInDialog.enabled = false;    
                changeSpationsToSpace.enabled = false;
            }
            else {
                tireAndSpatium_value = 1;
                myTireSpatiumGroup.enabled = true;
                //myTireInDialog.enabled = true;        
                changeSpationsToSpace.enabled = true;
            }
            spationsToSpace.value = spationsToSpace_value;
            if (spationsToSpace.value != true) {
                spationsToSpace_value = 0;
            }
            else {
                spationsToSpace_value = 1;
            }
            setSliderState();
            ProcSpace.selection = ProcSpace_selection;
            CurrSpace.selection = CurrSpace_selection;
            TwoSpacesDrop.selection = TwoSpacesDrop_selection;
            mySpaceListBefore.selection = mySpaceListBefore_selection;
            mySpaceListAfter.selection = mySpaceListAfter_selection;
            slider.value = mySlider_value;
            mySpaceProc.text = mySlider_value;
            commatire.value = commatire_value;
            commatire.value == false ? myCommaAndTire.enabled = false : myCommaAndTire.enabled = true;
            grekCharStyles.value = grekCharStyles_value;
            //grekCharStyles.value == false ? mySpecCharLine.enabled = false : mySpecCharLine.enabled = true;
            myCommaAndTire.selection = myCommaAndTire_selection;
            shortword.value = shortword_value;
            shortword.value == false ? myShortWordSpace.enabled = false : myShortWordSpace.enabled = true;
            myShortWordSpace.selection = myShortWordSpace_selection;
            initials.value = initials_value;
            myASPushkinFirstSpace.selection = myASPushkinFirstSpace_selection;
            myASPushkinSecondSpace.selection = myASPushkinSecondSpace_selection;
            myPushkinASFirstSpace.selection = myPushkinASFirstSpace_selection;
            myPushkinASSecondSpace.selection = myPushkinASSecondSpace_selection;

            asPushkin.value = true;
            pushkinAS.value = true;

            if (initials.value != true) {
                initials_value = 0;
                myASPushkinFirstSpace.enabled = false;
                myASPushkinSecondSpace.enabled = false;
                myPushkinASFirstSpace.enabled = false;
                myPushkinASSecondSpace.enabled = false;
                asPushkin.enabled = false;
                pushkinAS.enabled = false;
            }
            else {
                initials_value = 1;
                myASPushkinFirstSpace.enabled = true;
                myASPushkinSecondSpace.enabled = true;
                myPushkinASFirstSpace.enabled = true;
                myPushkinASSecondSpace.enabled = true;
                asPushkin.enabled = true;
                pushkinAS.enabled = true;
            }
            setquotes.value = setquotes_value;
            partHE.value = partHE_value;
            if (myClean.value == true) {
                c_options.enabled = true;
            }
            else {
                c_options.enabled = false;
            }
            if (myTypographica.value == true) {
                t_options.enabled = true;
            }
            else {
                t_options.enabled = false;
            }
            if (mySpatium.value == true) {
                s_options.enabled = true;
            }
            else {
                s_options.enabled = false;
            }
            mySpecialChar = mySpecialChar_start;
            //mySpecCharLine.text = mySpecialChar_start;

            myPhone_value = myPhone_value_start; // 5.1.14

            if (myFormulaToProcess.value == true) { //myFormulaToProcess.value == true
                myClean.value = ChistkaNow;
                myClean.enabled = true;
                c_options.enabled = true;
                myTypographica.value = OformlNow;
                myTypographica.enabled = true;
                t_options.enabled = true;
                myTireGroup.enabled = true;
                myCommaAndTireGroup.enabled = true;
                myFIOGroup.enabled = true;
                myProcGroup.enabled = true;
                myPhone.value = PhoneNow;
                myPhone.enabled = true;
                p_options.enabled = true;
                myQuery.value = QueryNow;
                myQuery.enabled = true;
                q_options.enabled = true;
            } // myFormulaToProcess.value == true  
            myFormulaToProcess.value = myFormulaToProcessValue;
            MathSignsAreTakedIntoAccount.enabled = false;
            TextColorIsTakedIntoAccount.enabled = false;
            myMathSpaceInfo.enabled = false;
            myInfoAboutProcFormulas.enabled = false;

            myPhone.value = myPhone_value;
            p_options.enabled = p_options_enabled;
            hyplinks.value = hyplinks_value;
            scale100.value = scale100_value;
            InTextSepIsDash.value = InTextSepIsDash_value;
            SepIsDefis.value = SepIsDefis_value;
            p_options.enabled = false;
            myQuery.value = myQuery_value;
            myAllButtonShow(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList);
            spaces.value = spaces_value;
            enters.value = enters_value;
            shenters.value = shenters_value;
            CurrentQueryInfo = CurrentQuery_start;
            myQuery.helpTip = CurrentQueryInfo;
            //try { if (userLanguage < app.languagesWithVendors.length) myLanguageList_selection = userLanguage; else myLanguageList_selection = 0; } catch (e) { myLanguageList_selection = 0; }
            //myLanguageList.selection = myLanguageList_selection;
            //try { myLanguageList.selection = myLanguageList_selection; } catch (e) { myLanguageList.selection = 0; }
            myLanguageList_selection = myLanguageList.selection.index;
            myLanguageList.enabled = false;
            //SetFontTypeInCharStyles.value = SetFontTypeInCharStyles_start;
            //////
            mySpaceAfterTireInDialogIndex = spaceAfterTireInDialog_start;
            mySpaceAfterTireInDialog.selection = mySpaceAfterTireInDialogIndex;

            mySpaceListAfterIndex = mySpaceListAfter.selection.index;
            StateOfControlButtons(false);
            try { spationsToSpace.text = lineForSpaces } catch (e) { };
        } // myResetSettings
        ////////////////////
        function myParamsForProcessing(myPanelState, myCheckBoxState) { // myParamsForProcessing
            var myRezult;
            if (myPanelState == true) {
                myCheckBoxState == true ? myRezult = 1 : myRezult = 0;
                myNumberOfActions++;
            }
            else myRezult = 2;
            return myRezult;
        } // myParamsForProcessing
        //////////////
        function mySaveInfoFile(myPath) { // mySaveInfoFile
            var mySetInfoFile = new File(decodeURI(myPath));
            tt = mySetInfoFile.open("w");
            // для логических операций допустимо использовать 1 как истину и 0 как ложь
            myClean.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myCleanValueFromMenu = myClean.value;
            c_options.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            repChar.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            repCharFromMenu = myParamsForProcessing(myClean.value, repChar.value);

            tabs2spaces.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            tabs2spacesFromMenu = myParamsForProcessing(myClean.value, tabs2spaces.value);

            hyphens.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            hyphensFromMenu = myParamsForProcessing(myClean.value, hyphens.value);

            bull2text.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            bull2textFromMenu = myParamsForProcessing(myTypographica.value, bull2text.value);

            charStyles.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            charStylesFromMenu = myParamsForProcessing(myTypographica.value, charStyles.value);

            digAndChar.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            digAndCharFromMenu = myParamsForProcessing(myClean.value, digAndChar.value);

            setLang.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            setLangFromMenu = myParamsForProcessing(myTypographica.value, setLang.value);

            myTypographica.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myTypographicaValueFromMenu = myTypographica.value;
            t_options.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            hyplinks.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            hyplinksFromMenu = myParamsForProcessing(myClean.value, hyplinks.value);

            fixOneLetter.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            fixOneLetterFromMenu = myParamsForProcessing(myTypographica.value, fixOneLetter.value);

            fixTwoLetter.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            fixTwoLetterFromMenu = myParamsForProcessing(myTypographica.value, fixTwoLetter.value);

            fixDigitAndWord.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            fixDigitAndWordFromMenu = myParamsForProcessing(myTypographica.value, fixDigitAndWord.value);

            commonTire.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            commonTireFromMenu = myParamsForProcessing(myClean.value, commonTire.value);

            minus.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            minusFromMenu = myParamsForProcessing(myClean.value, minus.value);

            mlnWithoutPoint.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            mlnWithoutPointFromMenu = myParamsForProcessing(myClean.value, mlnWithoutPoint.value);

            //~ slitno.value== true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            //~ slitnoFromMenu = myParamsForProcessing(mySpatium.value,slitno.value);

            mySetInfoFile.writeln(slitno.selection.index);
            slitnoFromMenu = slitno.selection.index;

            myFootnoteGroup.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            footnote1.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            footnote1FromMenu = myParamsForProcessing(myFootnoteGroup.value, footnote1.value);
            try {
                if (myStory.footnotes.length == 0) footnote1FromMenu = 2;
            }
            catch (e) { } // в случае, когда ничего не выбрано (для случая обработки всех статей документа) проверка  myStory.footnotes.length == 0 смысла не имеет

            ParaIndexFromMenu = myList.selection.index;
            oneStyleFromMenu = oneStyle.value;
            mySetInfoFile.writeln(myParaStyleNames[ParaIndexFromMenu]);

            mySpatium.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            s_options.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            mySpatiumValueFromMenu = mySpatium.value;

            tireAndSpatium.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            tireAndSpatiumFromMenu = myParamsForProcessing(mySpatium.value, tireAndSpatium.value);

            mySetInfoFile.writeln(mySpaceListBefore.selection.index);
            mySpaceListBeforeFromMenu = mySpaceListBefore.selection.index;

            mySetInfoFile.writeln(mySpaceListAfter.selection.index);
            mySpaceListAfterFromMenu = mySpaceListAfter.selection.index;

            mySetInfoFile.writeln(slider.value);
            mySliderValueFromMenu = slider.value;

            commatire.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            commatireFromMenu = myParamsForProcessing(mySpatium.value, commatire.value);
            mySetInfoFile.writeln(myCommaAndTire.selection.index);
            myCommaAndTireFromMenu = myCommaAndTire.selection.index;
            grekCharStyles.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            grekCharStylesFromMenu = myParamsForProcessing(myTypographica.value, grekCharStyles.value);
            shortword.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            shortwordFromMenu = myParamsForProcessing(mySpatium.value, shortword.value);
            mySetInfoFile.writeln(myShortWordSpace.selection.index);
            myShortWordSpaceFromMenu = myShortWordSpace.selection.index;
            initials.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            initialsFromMenu = myParamsForProcessing(mySpatium.value, initials.value);

            asPushkin.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            asPushkinFromMenu = asPushkin.value;
            asPushkin.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            pushkinAS.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            pushkinASFromMenu = pushkinAS.value;
            pushkinAS.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            mySetInfoFile.writeln(myASPushkinFirstSpace.selection.index);
            myASPushkinFirstSpaceFromMenu = myASPushkinFirstSpace.selection.index;
            mySetInfoFile.writeln(myASPushkinSecondSpace.selection.index);
            myASPushkinSecondSpaceFromMenu = myASPushkinSecondSpace.selection.index;
            mySetInfoFile.writeln(myPushkinASFirstSpace.selection.index);
            myPushkinASFirstSpaceFromMenu = myPushkinASFirstSpace.selection.index;
            mySetInfoFile.writeln(myPushkinASSecondSpace.selection.index);
            myPushkinASSecondSpaceFromMenu = myPushkinASSecondSpace.selection.index;
            setquotes_valueFromMenu = myParamsForProcessing(myTypographica.value, setquotes.value);
            setquotes.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            // 18.10.2013 -- пока оставлю сохранение строки mySpecCharLine исключительно радо того, чтобы не нарушить очередность записи и считывания установок. Но теперь она определяется только в файле WordsAndUnits.jsx. Возможность установки в скрипте исключена.
            //mySpecialChar = mySpecCharLine.text;
            var myUnicodeInfo = [];
            var myLineLength = mySpecialChar.length;
            for (i = 0; i < myLineLength; i++) { //  i < myLineLength
                myUnicodeInfo[i] = mySpecialChar.charCodeAt(i);
            } //  i < myLineLength
            var myUnicodeLine = myUnicodeInfo.join(',');
            mySetInfoFile.writeln(myUnicodeLine);
            myPhone.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myPhoneValueFromMenu = myPhone.value;
            p_options.enabled == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsSpace.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsSpaceFromMenu = myParamsForProcessing(myPhone.value, SepIsSpace.value);
            SepIsDefis.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsDefisFromMenu = myParamsForProcessing(myPhone.value, SepIsDefis.value);
            SepIsMinus.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsMinusFromMenu = myParamsForProcessing(myPhone.value, SepIsMinus.value);
            SepIsTire.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsTireFromMenu = myParamsForProcessing(myPhone.value, SepIsTire.value);
            SepIsDot.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            SepIsDotFromMenu = myParamsForProcessing(myPhone.value, SepIsDot.value);
            myOneLineIsOneAbzatz.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myOneLineIsOneAbzatzFromMenu = myParamsForProcessing(myTypographica.value, myOneLineIsOneAbzatz.value);
            InTextSepIsSpace.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            InTextSepIsSpaceFromMenu = myParamsForProcessing(myPhone.value, InTextSepIsSpace.value);
            InTextSepIsDash.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            InTextSepIsDashFromMenu = myParamsForProcessing(myPhone.value, InTextSepIsDash.value);
            InTextSepIsDot.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            InTextSepIsDotFromMenu = myParamsForProcessing(myPhone.value, InTextSepIsDot.value);
            my11D.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            my11DFromMenu = myParamsForProcessing(myPhone.value, my11D.value);
            myTelNumBreak.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myTelNumBreakFromMenu = myParamsForProcessing(myPhone.value, myTelNumBreak.value);
            myQuery.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myQueryValueFromMenu = myQuery.value;
            mySetInfoFile.writeln(myQueryList.items.length);
            myQueCntr = myQueryList.items.length;
            for (i = 0; i < myQueryList.items.length; i++) { mySetInfoFile.writeln(myQueryList.items[i]); mySavedQueryList[i] = myQueryList.items[i]; }
            // 27.12.2013 добавим в конец сохранение двух добавленных флажков
            spaces.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            enters.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            shenters.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            mySetInfoFile.writeln(CurrentQuery);

            noParagraphs.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            noParagraphsFromMenu = myParamsForProcessing(myTypographica.value, noParagraphs.value);

            mySetInfoFile.writeln(myLanguageList.selection.index);
            myLanguageListFromMenu = myLanguageList.selection.index;

            MathSignsAreTakedIntoAccount_valueFromMenu = MathSignsAreTakedIntoAccount.value;
            MathSignsAreTakedIntoAccount.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            myMathSpaceIndexFromMenu = myMathSpace.selection.index;
            mySetInfoFile.writeln(myMathSpace.selection.index);

            myInfoAboutProcFormulasFromMenu = myInfoAboutProcFormulas.value;
            myInfoAboutProcFormulas.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            /// следующая строка -- сохранение флажка "Присвоить тексту один стиль". Как ни сопротивлялся, уговорили... :)
            oneStyle.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);

            tire.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            tireFromMenu = myParamsForProcessing(myClean.value, tire.value);

            defis.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            defisFromMenu = myParamsForProcessing(myClean.value, defis.value);

            defisN.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            defisNFromMenu = myParamsForProcessing(myClean.value, defisN.value);

            mySetInfoFile.writeln(TwoSpacesDrop.selection.index);
            TwoSpacesDropFromMenu = TwoSpacesDrop.selection.index;

            mySetInfoFile.writeln(ProcSpace.selection.index);
            ProcSpaceFromMenu = ProcSpace.selection.index;
            /////

            //~ CurrSlitno.value== true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            //~ CurrSlitnoFromMenu = myParamsForProcessing(mySpatium.value,CurrSlitno.value);

            mySetInfoFile.writeln(CurrSlitno.selection.index);
            CurrSlitnoFromMenu = CurrSlitno.selection.index;

            mySetInfoFile.writeln(CurrSpace.selection.index);
            CurrSpaceFromMenu = CurrSpace.selection.index;

            mySetInfoFile.writeln(mySpaceAfterTireInDialog.selection.index);
            mySpaceAfterTireInDialogFromMenu = mySpaceAfterTireInDialog.selection.index;

            scale100.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            scale100FromMenu = myParamsForProcessing(myClean.value, scale100.value);

            WordAndLetterSpace.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            WordAndLetterSpaceFromMenu = myParamsForProcessing(myTypographica.value, WordAndLetterSpace.value);

            nobreakSpace.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            nobreakSpaceFromMenu = myParamsForProcessing(myTypographica.value, nobreakSpace.value);

            spationsToSpace.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            spationsToSpaceFromMenu = myParamsForProcessing(mySpatium.value, spationsToSpace.value);

            //SetFontTypeInCharStyles.value== true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            //SetFontTypeInCharStylesFromMenu = myParamsForProcessing(myTypographica.value,SetFontTypeInCharStyles.value);

            useUnderline.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            useUnderlineFromMenu = myParamsForProcessing(myTypographica.value, useUnderline.value);

            useCapslock.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            useCapslockFromMenu = myParamsForProcessing(myTypographica.value, useCapslock.value);

            startTabs.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            startTabsFromMenu = myParamsForProcessing(myClean.value, startTabs.value);

            myDPdefis.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myDPdefisFromMenu = myParamsForProcessing(myClean.value, myDPdefis.value);

            myDPminus.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myDPminusFromMenu = myParamsForProcessing(myClean.value, myDPminus.value);

            myDPtire.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            myDPtireFromMenu = myParamsForProcessing(myClean.value, myDPtire.value);

            partHE.value == true ? mySetInfoFile.writeln(1) : mySetInfoFile.writeln(0);
            partHEFromMenu = myParamsForProcessing(myTypographica.value, partHE.value);

            setsFromParaFromMenu = setsFromPara.value; // это значение не сохраняется в файле. Оно нужно только в процессе обработки.
            procEndnotesFromMenu = procEndnotes.value; // это значение не сохраняется в файле. Оно нужно только в процессе обработки.

            /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            myFormulaToProcessFromMenu = myFormulaToProcess.value; // этот параметр не надо сохранять на будущее. Он важен только сейчас
            ///
            ///##>>> Следующие переменные сохраняются для возможного "разбора полётов", почему скрипт неправильно обрабатывает формулы :)
            var myUnicodeProcMathInfo = [];
            var myProcMathLineLength = myProcessedMathSigns.length;
            for (var ii = 0; ii < myProcMathLineLength; ii++) { //  ii < myProcMathLineLength
                myUnicodeProcMathInfo[ii] = myProcessedMathSigns.charCodeAt(ii);
            } //  ii < myProcMathLineLength
            var myUnicodeProcMathLine = myUnicodeProcMathInfo.join(',');
            mySetInfoFile.writeln(myUnicodeProcMathLine);
            mySetInfoFile.writeln(myUserVars);
            ///##>>>
            mySetInfoFile.close();
            if (myNeedToSaveDtokToo == true) { // myNeedToSaveDtokToo == true
                myDtokSpecName = mySpecialQName.replace(/\.quedtok$/, ".dtok");
                mySetInfoFile.copy(mySpecFolderName + "/" + myDtokSpecName);
            } // myNeedToSaveDtokToo == true
        } // mySaveInfoFile
        ///////////////////
        if (myFastUsage == true) mySaveInfoFile(mySetInfoFile); // имитация нажатия клавиши ОК.  Для случая обработки всех статей
        return win;
    } // myScriptWindow
    //////////////////*** выбор сделан ***////////////////////////////
    var myDate = new Date;
    var myMinutes = myDate.getMinutes();
    if (myMinutes < 10) myMinutes = "0" + myMinutes;
    var mySecondes = myDate.getSeconds();
    var myHour = myDate.getHours();
    if (myMinutes == 0) myHour = myDate.getHours(); // какая-то странная ошибка: было время 21:59, стало 22:00, а тут результат 21:00. Будто часы не успевают за минутами. Попробуем принудительно читать часы еще раз, когда минуты начала часа уже стоят.
    if (myHour < 10) myHour = "0" + myHour;
    //if (myMinutes <10) myMinutes = "0" + myMinutes;
    // добавим необходимые стили
    addStyles();
    ///
    var myStartQueArray = [];
    var myFinishQueArray = [];
    var myStartTextQueArray = [];
    var myFinishTextQueArray = [];
    var myStartGrepQueArray = [];
    var myFinishGrepQueArray = [];
    if (myQueryValueFromMenu == true) { // myQueryValueFromMenu == true
        for (j = 0; j < myQueCntr; j++) { // j < myQueCntr
            if (mySavedQueryList[j].text[0] == "S") myStartQueArray.push(mySavedQueryList[j].text);
            if (mySavedQueryList[j].text[0] == "F") myFinishQueArray.push(mySavedQueryList[j].text);
        } // j < myQueCntr
        /// >>>  ||  Ниже идут процедуры извлечения имён запросов из строк правого окна вкладки 'Поиск и замена'. 
        ///  В результате в массивах myStartTextQueArray, myStartGrepQueArray, myFinishTextQueArray, myFinishGrepQueArray будут собраны имена всех запросов.
        ///  Важно, что в эти массивы помещаются не полные имена, а только их левая часть, процедуре app.loadFindChangeQuery расширение '.xml' не нужно. 
        ///   Более того, если передать запрос на исполнение, указав не только имя, но и расширение, он обработан не будет.  || <<<
        var myQObject = app.activeDocument.textFrames.add();
        myQText = myQObject.parentStory;
        myQText.texts[0].applyParagraphStyle(app.activeDocument.paragraphStyles[1], false); //   [основной абзац]       
        for (i = 0; i < myStartQueArray.length; i++) { //  i < myStartQueArray.length
            myQObject.contents = myStartQueArray[i];
            if (myQText.characters[2].contents == "T") { // T
                myMakeQueLineUsingGREP(myQText, "(S:T: )(\.+)(\\.xml)", "$2");
                myStartTextQueArray.push(myQText.contents);
            } // T
            else if (myQText.characters[2].contents == "G") { // T
                myMakeQueLineUsingGREP(myQText, "(S:G: )(\.+)(\\.xml)", "$2");
                myStartGrepQueArray.push(myQText.contents);
            } // T
            myQText.contents = "";
        } //  i < myStartQueArray.length
        for (i = 0; i < myFinishQueArray.length; i++) { //  i < myFinishQueArray.length
            myQObject.contents = myFinishQueArray[i];
            if (myQText.characters[2].contents == "T") { // T
                myMakeQueLineUsingGREP(myQText, "(F:T: )(\.+)(\\.xml)", "$2");
                myFinishTextQueArray.push(myQText.contents);
            } // T
            else if (myQText.characters[2].contents == "G") { // G
                myMakeQueLineUsingGREP(myQText, "(F:G: )(\.+)(\\.xml)", "$2");
                myFinishGrepQueArray.push(myQText.contents);
            } // G
            myQText.contents = "";
        } //  i < myFinishQueArray.length
        myQObject.remove();
        /// >>>  ||   массивы myStartTextQueArray, myStartGrepQueArray, myFinishTextQueArray, myFinishGrepQueArray укомлектованы  || <<<
    } // myQueryValueFromMenu == true
    ///
    if (mySelection != undefined) { // mySelection !=undefined 
        if (myFragment == true) { // myFragment == true
            mySelection = app.selection[0];
            /// вызываем функцию с возможностью отмены одной командой
            //   if (myUndoState == true) { // myUndoState == true
            app.doScript(
                myTextProcessingAction,                     // The script to execute. Can accept: File, String or JavaScript Function.
                ScriptLanguage.JAVASCRIPT,    // The language of the script to execute.
                [],                           // An array of arguments passed to the function 
                UndoModes.ENTIRE_SCRIPT, // How to undo this script.
                'myTextProcessingAction'                    // The name of the undo step for entire script undo mode. 
            );
            //     } // myUndoState == true
            // else /*  myUndoState == false */
            //    myTextProcessingAction(); 
        } // myFragment == true
        else { // myFragment == false
            /// вызываем функцию с возможностью отмены одной командой
            myText.characters.itemByRange(0, (myText.length - 1)).select();
            mySelection = app.selection[0];
            //  if (myUndoState == true) { // myUndoState == true
            app.doScript(
                myTextProcessingAction,                     // The script to execute. Can accept: File, String or JavaScript Function.
                ScriptLanguage.JAVASCRIPT,    // The language of the script to execute.
                [],                           // An array of arguments passed to the function 
                UndoModes.ENTIRE_SCRIPT, // How to undo this script.
                'myTextProcessingAction'                    // The name of the undo step for entire script undo mode. 
            );
            //       } // myUndoState == true
            //   else  /*  myUndoState == false */
            //      myTextProcessingAction();
        } // myFragment == false
    } // mySelection !=undefined
    else { // сюда можно попасть только в случае, когда запускается скрипт UseCurrentSet и ничего не выбрано. В этом случае в соответствии с текущими установками будут обрабатываться все статьи.
        //~      app.doScript(
        //~             myTextProcessingAction,                     // The script to execute. Can accept: File, String or JavaScript Function.
        //~             ScriptLanguage.JAVASCRIPT,    // The language of the script to execute.
        //~             [],                           // An array of arguments passed to the function 
        //~             UndoModes.ENTIRE_SCRIPT, // How to undo this script.
        //~             'myTextProcessingAction'                    // The name of the undo step for entire script undo mode. 
        //~             );
        myTextProcessingAction();
    }
    try { myDocument.textPreferences.deleteEmptyPages = myDelEmptyPagesStatus } catch (e) { }
    if (BatchProcessingOK1 == false) {
        //alert ("Запустите скрипт ещё раз.[1]");
        exit();
    }
    else if (BatchProcessingOK2 == false) {
        //alert ("Запустите скрипт ещё раз.[2]");
        exit();
    }
    var myDate = new Date;
    var myHourFinis = myDate.getHours();
    var myMinutesFinis = myDate.getMinutes();
    var mySecondesFinis = myDate.getSeconds();
    myHourFinis = myHourFinis - myHour;
    myMinutesFinis = myMinutesFinis - myMinutes;
    mySecondesFinis = mySecondesFinis - mySecondes;
    if (myHourFinis < 0) myHourFinis += 24;
    if (mySecondesFinis < 0) { //mySecondesFinis <0
        myMinutesFinis--;
        if (mySecondesFinis != 0) { mySecondesFinis = 60 + mySecondesFinis; }
    } //mySecondesFinis <0
    if (myMinutesFinis < 0) { //myMinutesFinis < 0
        myHourFinis--;
        if (myMinutesFinis != 0) { myMinutesFinis = 60 + myMinutesFinis; }
    } //myMinutesFinis < 0
    if (myHourFinis < 10) myHourFinis = "0" + myHourFinis;
    if (myMinutesFinis < 10) myMinutesFinis = "0" + myMinutesFinis;
    if (mySecondesFinis < 10) mySecondesFinis = "0" + mySecondesFinis;
    if (myProblemsWithStartTextQueryProcessing == true || myProblemsWithStartGrepQueryProcessing == true || myProblemsWithFinishTextQueryProcessing == true || myProblemsWithFinishGrepQueryProcessing == true) {  /// if (myProblemsWithStartTextQueryProcessing == true...
        alert(myMessageAboutQueryProcessingProblems + "\nФайл с перечнем этих запросов называется InfoAboutQueryProblem.txt\nи находится в том же каталоге, где и скрипт DoTextOK.", myProgramTitul);
        myInfName = "InfoAboutQueryProblem.txt";
        var myFileInfoSave = decodeURI(myScriptFolder + "/" + myInfName);
        var myInfoSave = new File(myFileInfoSave);
        myInfoSave.open("w");
        myInfoSave.writeln(myMessageAboutQueryProcessingProblems);
        myInfoSave.close();
    } /// if (myProblemsWithStartTextQueryProcessing == true...
    ///
    try { pBar.close(); } catch (e) { }
    var myInfoBtn = File(decodeURI(myScriptFolder + "/Picts/" + "InfoPictN.png"));
    var InfWindowName;
    if (SingleStory == false) InfWindowName = "Обработка всех статей документа" else InfWindowName = myProgramTitulWholeText;
    //var myWindow = new Window ("dialog", InfWindowName, undefined,{closeButton: false});
    var myWindow = new Window("palette", InfWindowName, undefined, { closeButton: true });
    myWindow.alignChildren = "left";
    var LogoAndInfo = myWindow.add("group");
    LogoAndInfo.orientation = "row";
    makeImageButton(myInfoBtn, false, 4, LogoAndInfo, myInfoAboutSites);
    ///
    //~ mySoftInfo.onClick = function () { // mySoftInfo.onClick   
    //~ myInfoAboutSites(); 
    //~ } // mySoftInfo.onClick
    var ProcDoneInfo = LogoAndInfo.add("group");
    if (myResetOrRename == 1 || myResetOrRename == 2 || myResetOrRename == 3) ProcDoneInfo.orientation = "column";
    else ProcDoneInfo.orientation = "row";
    ProcDoneInfo.alignChildren = "left";
    var TimeProcessing = ProcDoneInfo.add("statictext");
    //MessLength = 40;
    //TimeProcessing.characters = MessLength;
    if (SingleStory == true) TimeProcessing.text = "Время обработки [ч:м:с] " + myHourFinis + ":" + myMinutesFinis + ":" + mySecondesFinis;
    var mySampleInfo = ProcDoneInfo.add("statictext");
    //mySampleInfo.characters = MessLength;
    var myRealUsedSet;
    if (myResetOrRename == 1) myRealUsedSet = "Установки сброшены, использовался файл параметров " + myDefSetName;
    else if (myResetOrRename == 2) myRealUsedSet = "Обработка выполнена созданным сейчас шаблоном " + mySpecialName;
    else myRealUsedSet = "Файл параметров: " + myParaFileName;
    mySampleInfo.text = myRealUsedSet;
    var myRedColor = myWindow.graphics.newPen(myWindow.graphics.PenType.SOLID_COLOR, [1.0, 0.0, 0.0], 1);
    //var myGreenColor = myWindow.graphics.newPen (myWindow.graphics.PenType.SOLID_COLOR, [0.0,0.7,0.0],1);
    myDocument.recompose();
    if (SingleStory == false) { // SingleStory == false
        TmpHaveNonJoiner = 0;
        TmpHaveNotNonJoiner = 0;
        for (var s = 0; s < myDocument.stories.length; s++) { //// s++ 
            // if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath"  || myDocument.stories[s].textContainers[0].parentPage == null) continue;
            if (parseIntAppVersion > 6) if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
            if (parseIntAppVersion == 6) if (myDocument.stories[s].textContainers[0].parent.constructor.name == "Spread" || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread") continue;
            if (myDocument.stories[s].textContainers[0].locked == true || myDocument.stories[s].textContainers[0].itemLayer.locked == true || myDocument.stories[s].textContainers[0].itemLayer.visible == false) continue; // статьи в блокированных фреймах на блокированных или скрытых слоях не обрабатываются
            //if (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || mySelection.parent.lockState != LockStateValues.NONE || (mySelection.parent.lockState == LockStateValues.CHECKED_IN_STORY && myInCopyIsUsed == true)) continue;
            if (parseIntAppVersion > 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) continue; // при групповой обработке InCopyIsUsed не учитываем
            if (parseIntAppVersion == 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) continue; // при групповой обработке InCopyIsUsed не учитываем        
            if (myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER) TmpHaveNonJoiner++;
            else TmpHaveNotNonJoiner++;
        } /// s++
        var myS = myWindow.add("statictext");
        if (TmpHaveNotNonJoiner != 0) myS.text = "Число обработанных статей " + String(TmpHaveNonJoiner) + ", осталось обработать " + String(TmpHaveNotNonJoiner);
        else myS.text = "Все статьи обработаны";
        //myS.graphics.foregroundColor = myRedColor;
    }  // SingleStory == false
    if (TmpHaveNotNonJoiner == 0) { // TmpHaveNotNonJoiner == 0
        for (var s = 0; s < myDocument.stories.length; s++) { //// s++ 
            if (myDocument.stories[s].length == 0) continue;
            if (parseIntAppVersion > 6) if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
            if (parseIntAppVersion == 6) if (myDocument.stories[s].textContainers[0].parent.constructor.name == "Spread" || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread") continue;
            //      if (myDocument.stories[s].length == 0 || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
            if (myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER) myDocument.stories[s].characters[-1].remove();
        } //// s++
    } // TmpHaveNotNonJoiner == 0
    var buttons = myWindow.add("group");
    buttons.orientation = "row";
    var Info = buttons.add("statictext");
    Info.text = "DoTextOK (" + myCurrentVersionData_xx_xx_xx + ") | © Михаил Иванюшин | adobeindesign.ru";
    //myOKButon = buttons.add ("button", undefined, "OK", {name: "ok"});
    try { Info.graphics.font = dialogFont + ":11"; } catch (e) { }
    //Info.graphics.foregroundColor = Info.graphics.newPen (Info.graphics.PenType.SOLID_COLOR, [0, 0,1, 1], 1);
    //myWindow.addEventListener ("keydown", function (k) { /*myWindow.close(); */ });
    //myWindow.show();
    if (testST(sleepTime) == true) st = sleepTime  else st = 2000;
    $.sleep(st);
    ////
    function testST(st) {
        if (isNaN(Number(st))) return null;
        if ((Number(st) <= 0) || (Number(st) > 3000)) return null else return true;
    }
    ////
    myWindow.close();
    //if (myEditCurSet == true) { // myEditCurSet 
    if (myFastUsage == false) { //myFastUsage = false;    
        if (missedFootnotesSigns.length > 0) { // .length > 0
            app.findChangeTextOptions.includeFootnotes = true;
            app.findTextPreferences = NothingEnum.nothing;
            app.changeTextPreferences = NothingEnum.nothing;
            app.findTextPreferences.findWhat = "<FFFD>"; // ищем символ потерянной сноски     
            alert("Скрипт подготовил текст к вёрстке, но к ней приступать нельзя, так как в работе есть потерянные сноски. Их число — " + missedFootnotesSigns.length + ".\nИщите сейчас места потерянных сносок и восстанавливайте по оригиналу текста. Символы <FFFD>, код маркера потерянной внутритектстовой сноски, уже есть на вкладке поиска текста.", myProgramTitul);
        } // .length > 0
    } // myEditCurSet
    /// >>> 
    // Удаление служебных цветов
    // RemoveCustomColors - размещенный в файле WordsndUnits.jsx флажок опции удаления из вёрстки служебных цветов. 
    // Если он в состоянии true, все цвета, собранные в массиве myRemovedColors, будут удалены из вёрстки.
    // Этой опцией надо пользоваться только тогда, когда вы уверены в её целесообразности.
    // Так, при назначении символьных стилей знаки и слова красятся цветом myInfoColor, и это цветовое выделение помогает в процессе вёрстки.
    // А работа с математическими формулами предполагает присутствие в вёрстке двух информационых цветов.
    // И тем не менее, если есть понимание, что эти цвета не нужны, вот флажок для удаления их. Цвет окрашенных символов станет чёрным.
    // Но при этом и в свойствах символьных стилей яркий цвет поменяется на чёрный. И останется таким и после возврата RemoveCustomColors в значение false.
    // Для того, чтобы символьные цвета снова стали цветными, после экспериментов с флажком RemoveCustomColors их надо все удалить, чтобы скрипт создал их заново.
    if (insertionPointIsActive && myParentPage != null) app.activeWindow.activePage = myParentPage; // myParentPage = null в случае, если был выбран фрейм с тектстом на рабочем слоле
    if (typeof RemoveCustomColors == "undefined") exit();
    //var myRemovedColors = ["myInfoColor","myMathFormulaColor","myProcessedFormula","myProblemQuoteColor","myRightYOColor","myProblemYOColor"];
    if (RemoveCustomColors && !myFormulaToProcessFromMenu) { // RemoveCustomColors
        var myDoct = app.documents.item(0);
        for (var i = 0; i < myRemovedColors.length; i++) { // i
            try { // try
                myDoct.colors.item(myRemovedColors[i]).remove();
            } // try
            catch (e) { }
        }  // i
    } // RemoveCustomColors

    /// >>>
    exit();
    /////////////////////////////////////////////
    ///  <<< (c) Константин Смородский 
    function addStyles() { // addStyles()
        // добавим специальный цвет
        //~ 	if (charStylesFromMenu == 1 || 
        //~ 		grekCharStylesFromMenu == 1 ||
        //~          myOneLineIsOneAbzatzFromMenu == 1 || 
        //~ 		footnote1FromMenu != 2) {
        //  21.01.2013 -- этот цвет безусловно добавляется в палитру цветов		
        addDocumentCollectionElement("colors", {
            name: "myInfoColor",
            model: ColorModel.process,
            space: ColorSpace.CMYK,
            colorValue: myInfoColorSample
        });
        //~ 	}
        ////== 12.11.2014 -- еще два обязательных цвета
        addDocumentCollectionElement("colors", {
            name: "myMathFormulaColor",
            model: ColorModel.process,
            space: ColorSpace.CMYK,
            colorValue: myFormulaToProcessSample
        });

        addDocumentCollectionElement("colors", {
            name: "myProcessedFormula",
            model: ColorModel.process,
            space: ColorSpace.CMYK,
            colorValue: myProcessedFormulaSample
        });
        ////==
        // добавим необходимые символьные стили
        //~     if (charStylesFromMenu == 1) { // удалим символьные стили
        //~         var myListCharStyles = ["myFootnotes", "mySymbolChars", "mySupSymbolChars", "mySubSymbolChars", "mySubSpecialChars", "mySupSpecialChars", "mySpecialChars", "myBoldItalicChars", "myItalicChars", "myBoldChars", "mySubChars", "mySupChars"];
        //~          for (cc = 0; cc < myListCharStyles.length; cc++)  { try { myDocument.characterStyles.item(myListCharStyles[cc]).remove(); } catch (e) { } }
        //~         }  // удалим символьные стили
        if (RemoveCustomColors == false) { // !RemoveCustomColors
            if (charStylesFromMenu == 1) { // charStylesFromMenu == 1
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupChars",
                    position: Position.SUPERSCRIPT,
                    //fontStyle: "Regular",
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubChars",
                    position: Position.SUBSCRIPT,
                    //fontStyle: "Regular",
                    fillColor: "myInfoColor"
                });
                //~         if (SetFontTypeInCharStyles.value) { // SetFontTypeInCharStyles.value1
                //~             addDocumentCollectionElement("characterStyles", {
                //~ 			name:      "myBoldChars",
                //~               fontStyle: "Bold",            
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value1
                //~         else { // e1
                addDocumentCollectionElement("characterStyles", {
                    name: "myBoldChars",
                    fontStyle: "Bold",
                    fillColor: "myInfoColor"
                });
                //            } // e1
                //~         if (SetFontTypeInCharStyles.value) { // SetFontTypeInCharStyles.value2
                //~             addDocumentCollectionElement("characterStyles", {
                //~                 name:      "myItalicChars",
                //~                 fontStyle: "Italic",               
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value2
                //~         else { // e2
                addDocumentCollectionElement("characterStyles", {
                    name: "myItalicChars",
                    fontStyle: "Italic",
                    fillColor: "myInfoColor"
                });
                //            } // e2
                //~         if (SetFontTypeInCharStyles.value) { //  SetFontTypeInCharStyles.value3     
                //~             addDocumentCollectionElement("characterStyles", {
                //~                 name:      "myBoldItalicChars",
                //~                 fontStyle: "BoldItalic",                  
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value3
                //~         else { // e3
                addDocumentCollectionElement("characterStyles", {
                    name: "myBoldItalicChars",
                    fontStyle: "Bold Italic",
                    fillColor: "myInfoColor"
                });
                //            } // e3
            } // charStylesFromMenu == 1
        } // !RemoveCustomColors
        else { // RemoveCustomColors
            if (charStylesFromMenu == 1) { // charStylesFromMenu == 1
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupChars",
                    position: Position.SUPERSCRIPT,
                    //fontStyle: "Regular",
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubChars",
                    position: Position.SUBSCRIPT,
                    //fontStyle: "Regular",
                    //fillColor: "myInfoColor"
                });
                //~         if (SetFontTypeInCharStyles.value) { // SetFontTypeInCharStyles.value1
                //~             addDocumentCollectionElement("characterStyles", {
                //~ 			name:      "myBoldChars",
                //~               fontStyle: "Bold",            
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value1
                //~         else { // e1
                addDocumentCollectionElement("characterStyles", {
                    name: "myBoldChars",
                    fontStyle: "Bold",
                    //fillColor: "myInfoColor"
                });
                //            } // e1
                //~         if (SetFontTypeInCharStyles.value) { // SetFontTypeInCharStyles.value2
                //~             addDocumentCollectionElement("characterStyles", {
                //~                 name:      "myItalicChars",
                //~                 fontStyle: "Italic",               
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value2
                //~         else { // e2
                addDocumentCollectionElement("characterStyles", {
                    name: "myItalicChars",
                    fontStyle: "Italic",
                    //fillColor: "myInfoColor"
                });
                //            } // e2
                //~         if (SetFontTypeInCharStyles.value) { //  SetFontTypeInCharStyles.value3     
                //~             addDocumentCollectionElement("characterStyles", {
                //~                 name:      "myBoldItalicChars",
                //~                 fontStyle: "BoldItalic",                  
                //~                 fillColor: "myInfoColor"
                //~                 });
                //~             } // SetFontTypeInCharStyles.value3
                //~         else { // e3
                addDocumentCollectionElement("characterStyles", {
                    name: "myBoldItalicChars",
                    fontStyle: "Bold Italic",
                    //fillColor: "myInfoColor"   
                });
                //            } // e3
            } // charStylesFromMenu == 1       
        } // RemoveCustomColors
        if (grekCharStylesFromMenu == 1) { // специальные символы
            if (RemoveCustomColors == false) { // RemoveCustomColors == false
                addDocumentCollectionElement("characterStyles", {
                    name: "mySpecialChars",
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupSpecialChars",
                    position: Position.SUPERSCRIPT,
                    //   fontStyle: "Regular",
                    //  appliedFont: "Minion Pro",
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubSpecialChars",
                    position: Position.SUBSCRIPT,
                    //fontStyle: "Regular",
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySymbolChars",
                    // fontStyle: "Regular",
                    // appliedFont: myUsedGreckFont,         
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubSymbolChars",
                    position: Position.SUBSCRIPT,
                    // fontStyle: "Regular",
                    fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupSymbolChars",
                    position: Position.SUPERSCRIPT,
                    // fontStyle: "Regular",
                    fillColor: "myInfoColor"
                });
            } // RemoveCustomColors == false
            else { ///  RemoveCustomColors == true
                addDocumentCollectionElement("characterStyles", {
                    name: "mySpecialChars",
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupSpecialChars",
                    position: Position.SUPERSCRIPT,
                    //   fontStyle: "Regular",
                    //  appliedFont: "Minion Pro",
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubSpecialChars",
                    position: Position.SUBSCRIPT,
                    //fontStyle: "Regular",
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySymbolChars",
                    // fontStyle: "Regular",
                    // appliedFont: myUsedGreckFont,         
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySubSymbolChars",
                    position: Position.SUBSCRIPT,
                    // fontStyle: "Regular",
                    //fillColor: "myInfoColor"
                });
                addDocumentCollectionElement("characterStyles", {
                    name: "mySupSymbolChars",
                    position: Position.SUPERSCRIPT,
                    // fontStyle: "Regular",
                    //fillColor: "myInfoColor"
                });
            } ///  RemoveCustomColors == true

            FontWithSymbols = true;
            try { myDocument.characterStyles.item("mySymbolChars").appliedFont = myUsedGreckFont } catch (e) { FontWithSymbols = false; }
            try { myDocument.characterStyles.item("mySymbolChars").fontStyle = "Regular" } catch (e) { }
            try { myDocument.characterStyles.item("mySubSymbolChars").appliedFont = myUsedGreckFont } catch (e) { FontWithSymbols = false; }
            try { myDocument.characterStyles.item("mySubSymbolChars").fontStyle = "Regular" } catch (e) { }
            try { myDocument.characterStyles.item("mySupSymbolChars").appliedFont = myUsedGreckFont } catch (e) { FontWithSymbols = false; }
            try { myDocument.characterStyles.item("mySupSymbolChars").fontStyle = "Regular" } catch (e) { }
            var MessageAboutFonts = "";
            if (FontWithSymbols == false) MessageAboutFonts = "Не найден указанный в файле WordAndUnits.jsx шрифт описания символов: '" + myUsedGreckFont + "'.\n";
            if (MessageAboutFonts.length != 0) { // MessageAboutFonts.length !=0
                MessageAboutFonts += "\nДля получения предсказуемых результатов целесообразно остановить обработку текста, привести в порядок файл WordAndUnits.jsx и запустить скрипт снова."
                var winf = new Window("dialog", "Ошибка в указании имени шрифта", undefined, { closeButton: true });
                winf.alignChildren = ["fill", "fill"];
                var infof = winf.add("statictext", undefined, "", { multiline: true });
                try { infof.graphics.font = dialogFont + ":11"; } catch (e) { }
                infof.text = MessageAboutFonts;
                var buttonGroupF = winf.add("panel");
                buttonGroupF.orientation = "row";
                myButtonGroupFSize = [0, 0, 220, 30];
                myOKf = buttonGroupF.add("button", myButtonGroupFSize, "Завершить обработку", { name: "cancel" });
                myCancelf = buttonGroupF.add("button", myButtonGroupFSize, "Продолжить", { name: "ok" });
                if (winf.show() == 2) { // == 2
                    try { myDocument.characterStyles.item("mySymbolChars").remove(); } catch (e) { }
                    try { myDocument.characterStyles.item("mySupSymbolChars").remove(); } catch (e) { }
                    try { myDocument.characterStyles.item("mySubSymbolChars").remove(); } catch (e) { }
                    exit();
                } // == 2
            } // MessageAboutFonts.length !=0
        } // специальные символы

        if (footnote1FromMenu != 2) { // сноски
            if (RemoveCustomColors == false) {
                addDocumentCollectionElement("characterStyles", {
                    name: "myFootnotes",
                    underline: false,
                    capitalization: Capitalization.NORMAL,
                    position: Position.SUPERSCRIPT,
                    fillColor: "myInfoColor"
                });
            }
            else {
                addDocumentCollectionElement("characterStyles", {
                    name: "myFootnotes",
                    underline: false,
                    capitalization: Capitalization.NORMAL,
                    position: Position.SUPERSCRIPT,
                    //fillColor: "myInfoColor"
                });
            }
        } // сноски
        if (mySpatiumValueFromMenu == 1 && tireAndSpatiumFromMenu == 1 && mySliderValueFromMenu < 100) { // масштабирование
            try { myDocument.characterStyles.item("myHorizontalScaleForEmDashSpaceBefore").remove(); } catch (e) { }
            try { myDocument.characterStyles.item("myHorizontalScaleForEmDashSpaceAfter").remove(); } catch (e) { }
            addDocumentCollectionElement("characterStyles", {
                name: "myHorizontalScaleForEmDashSpaceBefore",
                horizontalScale: mySliderValueFromMenu,
                noBreak: true
                /*  fillColor: "myInfoColor"  */
            });
            addDocumentCollectionElement("characterStyles", {
                name: "myHorizontalScaleForEmDashSpaceAfter",
                horizontalScale: mySliderValueFromMenu,
                /*  fillColor: "myInfoColor"  */
            });
        } // масштабирование
        if (my11DFromMenu == 1) {
            addDocumentCollectionElement("characterStyles", {
                name: "myElevenDigitsTelNumber",
                //fillColor: "myInfoColor"
            });
        }
    } // addStyles()
    ///////////////////////////////////////////////////////////////////////////
    function myTextProcessingAction() { // myTextProcessingAction()
        myDocument.textPreferences.deleteEmptyPages = false;
        footnoteOnlyProc = false;
        if (myFastUsage == true && mySelection == undefined) { // myFastUsage == true && mySelection == undefined
            myFragment = false;
            var myDateG = new Date;
            var myHourG = myDateG.getHours();
            if (myHourG < 10) myHourG = "0" + myHourG;
            var myMinutesG = myDateG.getMinutes();
            if (myMinutesG < 10) myMinutesG = "0" + myMinutesG;
            var myDocumentStoriesLength = myDocument.stories.length;
            var myObject = app.activeDocument.textFrames.add();
            myObject.texts[0].applyParagraphStyle(app.activeDocument.paragraphStyles[1], false); //   [основной абзац]    
            myText = myObject.parentStory;
            pBar = new ProgressBar(myProgramTitul);
            pBar.reset("", myDocumentStoriesLength);
            for (var s = myDocumentStoriesLength - 1; s >= 0; s-- , pBar.hit()) { // s++     
                if (parseIntAppVersion > 6 && (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null)) continue;
                if (parseIntAppVersion == 6 && (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parent == null)) continue;
                if (myDocument.stories[s].textContainers[0].locked == true || myDocument.stories[s].textContainers[0].itemLayer.locked == true || myDocument.stories[s].textContainers[0].itemLayer.visible == false) { LockedOrHiddenLayerStories++; continue; } // статьи на блокированных или скрытых слоях не обрабатываются
                if (parseIntAppVersion > 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) continue;
                if (parseIntAppVersion == 6 && (myDocument.stories[s].length == 0 || myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE)) continue;
                //    try { ///try
                var CurrentProcessedStory = myDocument.stories[s].contents;
                var myDateQ = new Date;
                myHourQ = myDateQ.getHours();
                if (myHourQ < 10) myHourQ = "0" + myHourQ;
                myMinutesQ = myDateQ.getMinutes();
                if (myMinutesQ < 10) myMinutesQ = "0" + myMinutesQ;
                myDocument.stories[s].characters.itemByRange(0, -1).select();
                mySubSelection = app.selection[0];
                myScriptWindow(); // для оценки числа шагов прогрессбара 
                if (mySubSelection.characters[0].parentTextFrames[0].constructor.name != "EndnoteTextFrame") { //  != "EndnoteTextFrame"
                    try { myText.characters.itemByRange(0, -1).remove(); } catch (e) { }
                    mySubSelection.duplicate(LocationOptions.AFTER, myText);
                    // информация о времени нужна для вывода ее в шапке прогресс-бара
                    var CurrNumber = Number(myDocumentStoriesLength - s); // цикл идет в порядке убывания, а отображать номер обрабатываемой статьи всё равно будем в порядке возрастания номеров. :)  Так пользователям привычнее...
                    myTxtProcessing(pBar, myText, "Время начала текущей обработки статей [ч:м] " + myHourG + ":" + myMinutesG + " | Всего статей " + myDocumentStoriesLength + ", сейчас обрабатывается " + String(CurrNumber) + "-я", myHourQ, myMinutesQ, "t");
                    // копируем обратно
                    try { mySubSelection.remove(); } catch (e) { } // выбранный для обработки текст удаляется, т.к. на это место будет возвращён обработанный текст.   
                    myText.duplicate(LocationOptions.AFTER, mySubSelection);
                } //  != "EndnoteTextFrame"
                else {
                    myTextE = mySubSelection.parentStory;
                    var CurrNumber = Number(myDocumentStoriesLength - s); // цикл идет в порядке убывания, а отображать номер обрабатываемой статьи всё равно будем в порядке возрастания номеров. :)  Так пользователям привычнее...               
                    if (procEndnotesFromMenu) { // procEndnotesFromMenu
                        endnotesProc(myTextE, "Обработка концевых сносок");
                        if (myStory.endnotes.length > 0) { // myStory.endnotes.length > 0
                            for (e = myStory.endnotes.length - 1; e >= 0; e--) { // e--
                                var cureEn = myStory.endnotes[e];
                                var spCh = cureEn.characters[0];
                                if (spCh.contents == SpecialCharacters.HAIR_SPACE) spCh.remove();
                            } // e--
                        } // myStory.endnotes.length > 0                    
                    } // procEndnotesFromMenu
                }
                myDocument.stories[s].insertionPoints[-1].contents = SpecialCharacters.ZERO_WIDTH_NONJOINER;
                myDocument.recompose();
            }  // s++
            myObject.remove(); // удален вспомогательный фрейм
            try { pBar.close(); } catch (e) { }
            // Проверка полноты проверки
            for (var s = 0; s < myDocumentStoriesLength; s++) { //// s++ 
                //if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath"  || myDocument.stories[s].textContainers[0].parentPage == null) continue; 
                if (parseIntAppVersion > 6) if (myDocument.stories[s].textContainers[0].constructor.name == "TextPath" || myDocument.stories[s].textContainers[0].parentPage == null || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread") continue;
                if (parseIntAppVersion == 6) if (myDocument.stories[s].textContainers[0].parent.constructor.name == "Spread" || myDocument.stories[s].textContainers[0].parent.parent.constructor.name == "MasterSpread") continue;
                if (myDocument.stories[s].textContainers[0].locked == true || myDocument.stories[s].textContainers[0].itemLayer.locked == true || myDocument.stories[s].textContainers[0].itemLayer.visible == false) { LockedOrHiddenLayerStories++; continue; } // статьи на блокированных или скрытых слоях не обрабатываются
                if (myDocument.stories[s].length == 0 || myDocument.stories[s].characters[-1].contents == SpecialCharacters.ZERO_WIDTH_NONJOINER || myDocument.stories[s].textContainers[0].parentPage.parent.constructor.name == "MasterSpread" || myDocument.stories[s].lockState != LockStateValues.NONE) continue;
                BatchProcessingOK2 = false;
                try { myDocument.textPreferences.deleteEmptyPages = myDelEmptyPagesStatus } catch (e) { }
                alert("Нужно запустить скрипт повторно (" + String(s) + "/" + String(myDocument.stories.length) + ") [4]");
                break;
            } //// s++
            app.documents[0].select(NothingEnum.nothing); // ... и снимем выделение
            return;
        } // myFastUsage == true && mySelection == undefined
        else { // обработка отдельной статьи или выделенного текста
            //  mySelection -- выделенный текст перед вызовом этой процедуры		
            //if ((mySelection.characters[0].contents != SpecialCharacters.FOOTNOTE_SYMBOL) && mySelection.characters[0].parentTextFrames[0].constructor.name != "EndnoteTextFrame") { //  != "EndnoteTextFrame"  ||  mySelection.characters[0].contents != SpecialCharacters.FOOTNOTE_SYMBOL -- куросор не в тексте сноски
            if (/*(mySelection.parent.constructor.name != "Footnote") && */ mySelection.characters[0].parentTextFrames[0].constructor.name != "EndnoteTextFrame") { //  != "EndnoteTextFrame"  ||  mySelection.characters[0].contents != SpecialCharacters.FOOTNOTE_SYMBOL -- куросор не в тексте сноски        
                // при запуске скрипта курсор был в основном тексте
                if (mySelection.characters[0].contents == SpecialCharacters.FOOTNOTE_SYMBOL) {
                    footnoteOnlyProc = true;
                    procEndnotesFromMenu = false; // если выбрана обработка обычной сноски, блок концевых сносок не обрабатывается
                }
                if (procEndnotesFromMenu) {  // procEndnotesFromMenu
                    if (mySelection.parent.endnotes.length > 0) { // .length > 0
                        myTextE = mySelection.parentStory.endnotes[0].texts[0].insertionPoints[0].parentTextFrames[0].parentStory;
                        myTextE.texts[0].applyParagraphStyle(app.activeDocument.paragraphStyles[1], false); //   [основной абзац]
                        myTextE.insertionPoints[0].contents = "\r";
                        endnotesProc(myTextE, "Обработка концевых сносок");
                        if (myStory.endnotes.length > 0) { // myStory.endnotes.length > 0
                            for (e = myStory.endnotes.length - 1; e >= 0; e--) { // e--
                                var cureEn = myStory.endnotes[e];
                                var spCh = cureEn.characters[0];
                                if (spCh.contents == SpecialCharacters.HAIR_SPACE) spCh.remove();
                            } // e--
                        } // myStory.endnotes.length > 0
                    }  // .length > 0
                } // procEndnotesFromMenu
                // создадим временный текстовый фрейм
                var myObject = app.activeDocument.textFrames.add();
                var myText = myObject.parentStory;
                myText.texts[0].applyParagraphStyle(app.activeDocument.paragraphStyles[1], false); //   [основной абзац]    
                //myText.insertionPoints[-1].contents = "\r"; // поместим перевод строки в начале текста тут и уберем его из процедуры обработки для учета случаев, когда первый выделенный абзац имеет стиль с опцией Bullets and Numbering
                mySelection.duplicate(LocationOptions.AFTER, myText);
                myText.insertionPoints[0].contents = "\r"; // поместим перевод строки в начале текста тут и уберем его из процедуры обработки для учета случаев, когда первый выделенный абзац имеет стиль с опцией Bullets and Numbering
                mySelection.remove(); // выбранный для обработки текст удаляется, т.к. на это место будет возвращён обработанный текст.
                // информация о времени нужна для вывода ее в шапке прогресс-бара
                if (myFragment == true) {
                    //        myText.insertionPoints[-1].contents = "\r";
                    myTxtProcessing(pBar, myText, "Обработка выделенного текста", myHour, myMinutes, "t");
                }
                else myTxtProcessing(pBar, myText, "Обработка выбранной статьи", myHour, myMinutes, "t");
                // копируем обратно
                try { if (myLastSelectedCharIsLastCharOfStory == true && myText.characters[-1].contents == myEnter) myText.characters.lastItem().remove(); } catch (e) { }
                var myNewText = myText.duplicate(LocationOptions.AFTER, mySelection);
                myObject.remove(); // удален вспомогательный фрейм   
                myDocument.recompose();
                myNewText.insertionPoints[0].select(); // выделим первую точку вставки...
                var ASP = app.selection[0].parentTextFrames[0];
                if (parseIntAppVersion == 6) {
                    if (app.selection[0].parentTextFrames[0].parent.constructor.name == "Page") app.activeWindow.activePage = app.selection[0].parentTextFrames[0].parent;
                }
                else if (app.selection[0].parentTextFrames[0].constructor.name == "TextPath" || app.selection[0].parentTextFrames[0].parentPage != null) app.activeWindow.activePage = app.selection[0].parentTextFrames[0].parentPage; // ... чтобы сделать активной страницу, на которой размещен фрейм с обработанным текстом...
                if (myFormulaToProcessFromMenu == true) { // myFormulaToProcessFromMenu == true
                    app.selection[0].parentTextFrames[0].select(); // ...выделим фрейм, чтобы поставить его по центру экрана...
                    try {
                        app.documents[0].layoutWindows[0].zoomPercentage = myZoom;
                    }
                    catch (e) { }
                } // myFormulaToProcessFromMenu == true
            }  //  != "EndnoteTextFrame"
            else { // при запуске курсор был в фрейме концевых сносок
                footnoteOnlyProc = true;
                if (procEndnotesFromMenu) { // procEndnotesFromMenu
                    myTextE = mySelection.parentStory;
                    myTextE.insertionPoints[0].contents = "\r";
                    endnotesProc(myTextE, "Обработка ТОЛЬКО концевых сносок");
                } // procEndnotesFromMenu
                else alert("Выбран текст с концевыми сносками, но его обработка отключена: сброшен флажок 'Обрабатывать концевые сноски' на первой вкладке программы.", " Подготовка текста к вёрстке ");
            } // при запуске курсор был в фрейме концевых сносок    
        } // обработка отдельной статьи или выделенного текста
        app.documents[0].select(NothingEnum.nothing); // снимем выделение
    } // myTextProcessingAction()
    ///
    function endnotesProc(text, mess) { // endnotesProc
        myTxtProcessing(pBar, text, mess, myHour, myMinutes, "f");  //
        mySimpleChange(text, "<FEFF><FEFF>", "");
        mySimpleChange(text, "<FEFF>", "");
        mySimpleChange(text, "^p^p", "")
    } // endnotesProc
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    function myTxtProcessing(pBar, procText, PrefixInfo, myHourC, myMinutesC, t_f) { // myTxtProcessing    ||  t_f == t  это текст
        var myText = procText;
        var myFileNoteProc = File(decodeURI(myScriptFolder + "/BIN/" + "SmartNoteProc.jsxbin"));
        if (myFileNoteProc.exists && setsFromParaFromMenu && !footnoteOnlyProc) { // myFileNoteProc.exists && setsFromParaFromMenu && !footnoteOnlyProc
            var fnL = myText.footnotes.length;
            if (fnL > 0) { // fnL > 0 
                for (var f = fnL - 1; f >= 0; f--) { // f--
                    // если в тексте после знака сноски есть знаки табуляции, или шпации, заменим последовательность этих знаков на пробел
                    var curFootnote = myText.footnotes[f].texts[0];
                    //var cFlength = curFootnote.characters.length;
                    curFootnote.texts[0].characters.itemByRange(0, -1).select();
                    var selF = app.selection[0];
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = "[\\t~m~>~f~|~S~s~<~/~.~3~4~%]+";
                    app.changeGrepPreferences.changeTo = " ";
                    selF.changeGrep(); // заменили все шпации на пробелы
                    ///
                    //~                 var thePatternFind = "(?<=~F)([\\t~m~>~f~|~S~s~<~/~.~3~4~% ])+"; // положительный просмотр назад при поиске последовательности шпаций и табуляций после знака сноски
                    //~                 var thePatternChange = " "; // заменяем на пробел
                    //~                 app.findGrepPreferences = NothingEnum.nothing;
                    //~                 app.changeGrepPreferences = NothingEnum.nothing;
                    //~                 app.findGrepPreferences.findWhat = thePatternFind;
                    //~                 app.changeGrepPreferences.changeTo = thePatternChange; 
                    //~                 selF.changeGrep(); 
                }  // f--
            } // fnL > 0 
            if (parseIntAppVersion > 12 && procEndnotesFromMenu == true) { // parseIntAppVersion > 12
                //enL = myText.endnotes.length; 
                enL = myText.endnoteRanges.length; // в parentStory есть endnotes, в текущем выделенном тексте endnoteRanges
                //  var eR = myText.endnoteRanges[0];  //   enL.sourceEndnote.texts[0].contents
                //  a=0;
                if (enL > 0) { //enL > 0 
                    for (var f = enL - 1; f >= 0; f--) { // f--
                        // если в тексте после знака сноски есть знаки табуляции, или шпации, заменим последовательность этих знаков на пробел
                        var curEndnote = myText.endnoteRanges[f].sourceEndnote;
                        //var cFlength = curEndnote.characters.length;
                        curEndnote.texts[0].characters.itemByRange(0, -1).select();
                        var selF = app.selection[0];
                        app.findGrepPreferences = NothingEnum.nothing;
                        app.changeGrepPreferences = NothingEnum.nothing;
                        app.findGrepPreferences.findWhat = "[\\t~m~>~f~|~S~s~<~/~.~3~4~%]+";
                        app.changeGrepPreferences.changeTo = " ";
                        selF.changeGrep(); // заменили все шпации на пробелы
                        ///                    
                        //~                     var thePatternFind = "(?<=~F)([\\t~m~>~f~|~S~s~<~/~.~3~4~% ])+"; // положительный просмотр назад при поиске последовательности шпаций и табуляций после знака сноски
                        //~                     var thePatternChange = " "; // заменяем на пробел
                        //~                     app.findGrepPreferences = NothingEnum.nothing;
                        //~                     app.changeGrepPreferences = NothingEnum.nothing;
                        //~                     app.findGrepPreferences.findWhat = thePatternFind;
                        //~                     app.changeGrepPreferences.changeTo = thePatternChange; 
                        //~                     selF.changeGrep(); 
                    }  // f--
                } // enL > 0    
            } // parseIntAppVersion > 12

            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.doScript(myFileNoteProc);
            smartNoteProc2(myText);
            smartNoteProc3(myText);
        } // myFileNoteProc.exists && setsFromParaFromMenu && !footnoteOnlyProc  
        //var pBar = new ProgressBar(myProgramTitul);
        //if (ShowProgressbarSingleStory == 1) ShowProgressbarSingleStory = 2;
        var myProcMathCharPattern;
        var myChangePattern;
        // если myFormulaToProcessFromMenu = true, то:
        // MathSignsAreTakedIntoAccount_valueFromMenu = true - "математические знаки";   = false - "цвет текста"
        // myMathSpaceIndexFromMenu - индекс нужной шпации в массиве myAllSpacesValues
        // myInfoAboutProcFormulasFromMenu = true - "обработанные формулы отмечать цветом"
        if (myFormulaToProcessFromMenu == true) { // myFormulaToProcessFromMenu 
            myFindChangeUsingGREP(myText, "(=)(" + mySep + "*|" + mySep + "+)(-)", "$1" + " " + "–", pBar, " Замена дефиса на минус");
            myFindChangeUsingGREP(myText, "(\\[|\\(|\\{)(" + mySep + "*|" + mySep + "+)(-)", "$1" + "–", pBar, " Замена дефиса после скобки на минус");
            myFindChangeUsingGREP(myText, "(\\r)(-)(\\d)", "$1" + "–" + myAllSpacesValues[myMathSpaceIndexFromMenu] + "$3", pBar, " Замена дефиса после перевода строки на минус");
            if (MathSignsAreTakedIntoAccount_valueFromMenu == false) { // ищем окрашенные цветом 'myMathFormulaColor' абзацы
                myText.insertionPoints[-1].contents = myEnter; // в штатном режиме подготовки текста к вёрстке перевод строки в конце текста удаляется. Но для обработки формул при поиске окрашенного текста он нужен. Ну раз нужен - добавим. Кто бы спорить стал...  :) Всё равно он будет удалён при завершении работы скрипта.
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findGrepPreferences.findWhat = '(\.|"+mySep+")+'; // ищем выделенные фрагменты с формулами...        
                app.findGrepPreferences.fillColor = "myMathFormulaColor"; // ... окрашенный цветом "myMathFormulaColor"
                myFoundSamples = myText.findGrep();
                var myProcMathCharArray = [];
                myProcMathCharArray = myProcessedMathSigns.split("");
                var myProcMathCharLine = myProcMathCharArray.join("|");
                //myProcMathCharPattern = "(?<=([\\u|\\l|\\d|\\)|\\(|\\]|\\[|}|{]|￼))("+mySep+"*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])("+mySep+"*)((?=[￼|\\u|\\l|\\d|\\)|\\(|\\]|\\[|}|{|+|–]))";  // это, пожалуй, избыточный набор. :) После открывающих скобок и перед закрывающими скобками ожидать метематические знаки, это моветон.       
                myProcMathCharPattern = "(?<=([\\u|\\l|\\d|\\)|\\]|}|￼]))(" + mySep + "*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])(" + mySep + "*)((?=[￼|\\u|\\l|\\d|\\(|\\[|{|+|–]))";
                myChangePattern = myAllSpacesValues[myMathSpaceIndexFromMenu] + "$3" + myAllSpacesValues[myMathSpaceIndexFromMenu];
                pBar.reset("Время начала обработки статьи [ч:м] " + myHourC + ":" + myMinutesC, myFoundSamples.length);
                pBar.sqn("Приведение в порядок оформления математических формул.");
                pBar.info(" Перед началом обработки абзацы с формулами были отмечены цветом 'myMathFormulaColor'");
                if (myInfoAboutProcFormulasFromMenu) pBar.fClr(" После обработки абзацы с формулами будут отмечены цветом 'myProcessedFormula'")
                else pBar.fClr(" После обработки цвет абзацев с формулами не изменится")
                for (i = myFoundSamples.length - 1, j = 0; i >= 0; i-- , j++) { // myFoundSamples.length - 1    
                    var myFound = myFoundSamples[i];
                    myFound.select();
                    var myMathSel = app.selection[0];
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    //app.findGrepPreferences.fillColor = "myMathFormulaColor";  // цвет уже тот, что надо, тут можно не акцентировать
                    app.findGrepPreferences.findWhat = myProcMathCharPattern;
                    app.changeGrepPreferences.changeTo = myChangePattern;
                    myMathSel.changeGrep();
                    // приведём в порядок дефисы и тире, если они стоят там, где должен быть знак минус                
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    app.findGrepPreferences.findWhat = "(" + myAllSpacesValues[myMathSpaceIndexFromMenu] + ")" + "([\\x{002D}|\\x{2011}|-|–|—|])" + "(" + myAllSpacesValues[myMathSpaceIndexFromMenu] + ")";
                    app.changeGrepPreferences.changeTo = "$1" + "–" + "$3"; // неважно, что там дефис, минус, тире, всё равно знак будет минус
                    myMathSel.changeGrep();
                    myNextStep(pBar, j);
                    if (myInfoAboutProcFormulasFromMenu == true) { // myInfoAboutProcFormulasFromMenu
                        myMathSel.select(); // поскольку в процессе приведения в порядок уравнения в него могли быть добавлены шпации, строка myMathSel.fillColor= "myProcessedFormula" не окрасит все символы строки,
                        // поэтому надо снова выделить этот абзац, а потом уже красить
                        app.selection[0].fillColor = "myProcessedFormula";
                    } // myInfoAboutProcFormulasFromMenu
                }  // myFoundSamples.length - 1   
            } // ищем окрашенные цветом 'myMathFormulaColor' абзацы
            //////////    
            else { // ищем математические знаки  
                var myProcMathCharArray = [];
                var myProcMathCharArray = myProcessedMathSigns.split("");
                var myProcMathCharLine = myProcMathCharArray.join("|");
                var myNormalEnterPlaceholder = "ξςχξςχ"; // символы перевода сроки попадают в множество \h, но их надо сохранить, если эти знаки на границе разрыва формулы, когда последний математический знак в строке повторяется на следующей строке, где пишется продолжение этой формулы.
                var myLineBreakPlaceholder = "τφλτφλ"; //  Очень мала вероятность того, что такая абракадабра будет в реальном тексте :)
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "([" + myProcMathCharLine + "])(" + mySep + "*)(\\r)(" + mySep + "*)([" + myProcMathCharLine + "])";
                app.changeGrepPreferences.changeTo = "$1" + myNormalEnterPlaceholder + "$5";
                myText.changeGrep();
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "([" + myProcMathCharLine + "])(" + mySep + "*)(\\n)(" + mySep + "*)([" + myProcMathCharLine + "])";
                app.changeGrepPreferences.changeTo = "$1" + myLineBreakPlaceholder + "$5";
                myText.changeGrep();
                ////
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                //app.findGrepPreferences.findWhat='\\r'; // ищем перевод строки...        
                app.findGrepPreferences.findWhat = '\$'; // ищем конец абзаца...    ||  ?????        
                myFoundSamples = myText.findGrep();
                pBar.reset("Время начала обработки статьи [ч:м] " + myHourC + ":" + myMinutesC, myFoundSamples.length);
                pBar.sqn("Приведение в порядок оформления найденных в тексте математических формул.");
                pBar.info(" Предполагается, что формула содержит хоть один из этих математических символов: " + myProcessedMathSigns);
                if (myInfoAboutProcFormulasFromMenu) pBar.fClr(" После обработки абзацы с формулами будут отмечены цветом 'myProcessedFormula'");
                else pBar.fClr(" После обработки цвет абзацев с формулами не изменится");
                try {
                    myTmp = myUserVars;
                }
                catch (e) {
                    alert("Не найдена переменная myUserVars.");
                    try { myDocument.textPreferences.deleteEmptyPages = myDelEmptyPagesStatus } catch (e) { }
                    return;
                }
                var UserVarsArray = new Array;
                UserVarsArray = myUserVars.split("|");
                for (i = myFoundSamples.length - 1, j = 0; i >= 0; i-- , j++) { // myFoundSamples.length - 1              
                    var myFound = myFoundSamples[i];
                    if (myFound.texts.length == 0) continue;
                    if (myFound.parent.constructor.name == "Note") continue;
                    myFound.paragraphs[0].select();
                    var myMathSel = app.selection[0];
                    //myProcMathCharPattern = "(?<=([α-ω|a-z|A-Z|\\d|\\)|\\]|}|￼]))("+mySep+"*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])("+mySep+"*)(?=([α-ω|a-z|A-Z|\\d|￼|\\(|\\[|{|+|–]))"; // это шаблон поиска переменных, набранных латинскими буквами, чисел скобок и привязанных объектов, стоящих рядом с математическими знаками    
                    myProcMathCharPattern = "(?<=([" + myDefaultVars + "|\\)|\\]|}|￼]))(" + mySep + "*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])(" + mySep + "*)(?=([" + myDefaultVars + "|￼|\\(|\\[|{|+|–]))"; // это шаблон поиска переменных, набланных латинскими буквами, чисел скобок и привязанных объектов, стоящих рядом с математическими знаками    
                    myChangePattern = myAllSpacesValues[myMathSpaceIndexFromMenu] + "$3" + myAllSpacesValues[myMathSpaceIndexFromMenu];
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    app.findGrepPreferences.findWhat = myProcMathCharPattern;
                    app.changeGrepPreferences.changeTo = myChangePattern;
                    myMathSel.changeGrep();
                    if (myUserVars.length != 0) { // myUserVars.length != 0
                        for (var f = 0; f < UserVarsArray.length; f++) { // f
                            //myProcMathCharPattern = "(?<=(" + UserVarsArray[f] + "))("+mySep+"*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])("+mySep+"*)"; 
                            myProcMathCharPattern = "(?<=(\\b" + UserVarsArray[f] + "\\b))(" + mySep + "*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])(" + mySep + "*)"; // \\b" + UserVarsArray[f] + "\\b  -- так определяется, что в строке myUserVars собраны  полные слова названий элементов формул
                            app.findGrepPreferences = NothingEnum.nothing;
                            app.changeGrepPreferences = NothingEnum.nothing;
                            app.findChangeGrepOptions.includeFootnotes = true;
                            app.findGrepPreferences.findWhat = myProcMathCharPattern;
                            myChangePattern = myAllSpacesValues[myMathSpaceIndexFromMenu] + "$3" + myAllSpacesValues[myMathSpaceIndexFromMenu];
                            app.changeGrepPreferences.changeTo = myChangePattern;
                            myMathSel.changeGrep();
                            //////
                            //myProcMathCharPattern = "("+mySep+"*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])("+mySep+"*)(?=(" + UserVarsArray[f] + "))"; 
                            myProcMathCharPattern = "(" + mySep + "*)([" + myProcMathCharLine + "|\\x{2011}|\\x{002D}|-|–|—])(" + mySep + "*)(?=(\\b" + UserVarsArray[f] + "\\b))";
                            app.findGrepPreferences = NothingEnum.nothing;
                            app.changeGrepPreferences = NothingEnum.nothing;
                            app.findChangeGrepOptions.includeFootnotes = true;
                            app.findGrepPreferences.findWhat = myProcMathCharPattern;
                            myChangePattern = myAllSpacesValues[myMathSpaceIndexFromMenu] + "$2" + myAllSpacesValues[myMathSpaceIndexFromMenu];
                            app.changeGrepPreferences.changeTo = myChangePattern;
                            myMathSel.changeGrep();
                        } // f
                    } // myUserVars.length != 0
                    // приведём в порядок дефисы и тире, если они стоят там, где должен быть знак минус
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    app.findGrepPreferences.findWhat = "(" + myAllSpacesValues[myMathSpaceIndexFromMenu] + ")" + "([\\x{002D}|\\x{2011}|-|–|—|])" + "(" + myAllSpacesValues[myMathSpaceIndexFromMenu] + ")";
                    app.changeGrepPreferences.changeTo = "$1" + "–" + "$3";
                    myMathSel.changeGrep();
                    //    return;
                    if (myInfoAboutProcFormulasFromMenu == true) { // myInfoAboutProcFormulasFromMenu
                        myFound.select(); // поскольку в процессе приведения в порядок уравнения в него могли быть добавлены шпации, строка myMathSel.fillColor= "myProcessedFormula" не окрасит все символы строки
                        // Поэтому надо снова выделить этот абзац, а потом уже красить
                        myMathSel.fillColor = "myProcessedFormula";
                        //   app.selection[0].fillColor= "myProcessedFormula";
                    } // myInfoAboutProcFormulasFromMenu
                    myNextStep(pBar, j);
                }  // myFoundSamples.length - 1
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "(" + mySep + "*)" + myNormalEnterPlaceholder + "(" + mySep + "*)";
                app.changeGrepPreferences.changeTo = "\\r";
                myText.changeGrep();
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "(" + mySep + "*)" + myLineBreakPlaceholder + "(" + mySep + "*)";
                app.changeGrepPreferences.changeTo = "\\n";
                myText.changeGrep();
            } // ищем математические знаки
            if (myText.characters[0].contents == "\r") myText.characters[0].remove(); // этот символ остается при начале обработки формул. В штатном режиме он на каком-то этапе удаляется, а тут придется в этой строке с ним расстаться.
            try { myDocument.textPreferences.deleteEmptyPages = myDelEmptyPagesStatus } catch (e) { }
            return;
        } // myFormulaToProcessFromMenu
        /////
        if (ShowProgressbarSingleStory == true) { // ShowProgressbarSingleStory == true
            pBar.reset("Время начала обработки статьи [ч:м] " + myHourC + ":" + myMinutesC, myNumberOfActions);
        } // ShowProgressbarSingleStory == true
        pBar.sqn(PrefixInfo);
        if (myStartTextQueArray.length > 0) { // myStartTextQueArray.length > 0
            for (i = 0; i < myStartTextQueArray.length; i++) { // i < myStartTextQueArray.length
                try { app.loadFindChangeQuery(myStartTextQueArray[i], SearchModes.textSearch); } catch (e) { myProblemsWithStartTextQueryProcessing = true; myMessageAboutQueryProcessingProblems += "S:T: " + myStartTextQueArray[i] + "\\\n"; continue; }
                pBar.info(" Выполняется запрос S:T: " + myStartTextQueArray[i]);
                myText.changeText();
            } // i < myStartTextQueArray.length
        } // myStartTextQueArray.length > 0    
        if (myStartGrepQueArray.length > 0) { // myStartGrepQueArray.length > 0
            for (i = 0; i < myStartGrepQueArray.length; i++) { // i < myStartGrepQueArray.length
                try { app.loadFindChangeQuery(myStartGrepQueArray[i], SearchModes.grepSearch); } catch (e) { myProblemsWithStartGrepQueryProcessing = true; myMessageAboutQueryProcessingProblems += "S:G: " + myStartGrepQueArray[i] + "\n"; continue; }
                pBar.info(" Выполняется запрос S:G: " + myStartGrepQueArray[i]);
                myText.changeGrep();
            } // i < myStartGrepQueArray.length
        } // myStartGrepQueArray.length > 0  

        if (hyplinksFromMenu != 2) { // hyplinksFromMenu != 2
            myCurrActionNumber++;
            myNextStep(pBar, myCurrActionNumber);
            if (hyplinksFromMenu == 1) { pBar.info(" Удаление гиперссылок"); myRemoveHyperLinks(myText); }
        } // hyplinksFromMenu != 2
        ///
        if (scale100FromMenu != 2) { // scale100FromMenu != 2
            myCurrActionNumber++;
            myNextStep(pBar, myCurrActionNumber);
            if (scale100FromMenu == 1) { pBar.info(" Приведение в порядок масштаба букв"); rightCharScale(myText); }
        } // scale100FromMenu != 2
        ///
        myText.insertionPoints[-1].contents = "\r";
        if (myCleanValueFromMenu == 1) { // myCleanValueFromMenu == 1
            myCurrActionNumber++;
            myNextStep(pBar, myCurrActionNumber);
            myFindChangeUsingGREP(myText, "[" + myLineOfSpaces + "]", mySingleSpace, pBar, " Замена шпаций на пробелы");
            //myFindChangeUsingGREP ("([ТтЕеЛл]\\.?)(\\d)","$1" + mySpace + "$2", pBar," Пробел после 'тел.' ");
            myFindChangeUsingGREP(myText, "([(Тел)|(тел)|(ТЕЛ)]{3}\\.?)(\\d)", "$1" + mySpace + "$2", pBar, " Пробел после 'тел.' "); // тоже не совсем удачная конструкция в том плане, что она найдёт и ллл, еее и ттт. Спасает, что таких сочетаний, да ещё чтобы перед номерами, не встречается.    
            myFindChangeUsingGREP(myText, "(\\d)([\\x{002D}|-|–|—])(\\d)", "$1" + myRealDigitSeparator + "$3", pBar, " Между цифрами тире, минус или дефис "); // между цифрами минус
            if (myOneLineIsOneAbzatzFromMenu == 1) { // myOneLineIsOneAbzatzFromMenu == 1
                // В таких текстах, когда каждая строка является одним абзацем, критерием истинного начала абзаца служит два или три пробела после знака Enter.
                // Очевидно, что после первого запуска текст станет нормальным, и эти повторяющиеся пробелы исчезнут.
                // Но если вновь запустить скрипт, то текст превратится в один сплошной абзац.
                // Чтобы избежать этого кошмара, надо перед выполнением обработки убедиться, что в тексте есть хоть одно появление Enter-пробел-пробел.
                app.findGrepPreferences = NothingEnum.nothing;
                app.findGrepPreferences.findWhat = "(\\r  )";
                myFoundSamples = myText.findGrep();
                if (myFoundSamples.length != 0) { // найдены 'Enter-пробел-пробел'
                    pBar.info(" Сборка однострочных абзацев в нормальный текст");
                    try {
                        myColor = myDocument.colors.item("myInfoColor");
                        myName = myColor.name;
                    }
                    catch (myError) {
                        myColor = myDocument.colors.add({ name: "myInfoColor", model: ColorModel.process, space: ColorSpace.CMYK, colorValue: myInfoColorSample });
                    }
                    try { myDocument.characterStyles.item("myDefisOrHyphen").name; }
                    catch (myError) { myDocument.characterStyles.add({ name: "myDefisOrHyphen" }); }
                    myDocument.characterStyles.item("myDefisOrHyphen").fillColor = "myInfoColor";
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = "(-\\r)";
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                            myLine = myFoundSamples[j];
                            myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("myDefisOrHyphen");
                            myLine.characters[1].remove();
                        } // j >= 0; j--
                    } // myFoundSamples.length != 0
                    else myDocument.characterStyles.item("myDefisOrHyphen").remove();
                    //PlaceHolderForEnter = "Abzatz#";
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = "(\\r\\r)";
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        PlaceHolderForEnter = "Abzatz#";
                        for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                            myLine = myFoundSamples[j];
                            myLine.contents = PlaceHolderForEnter;
                        } // j >= 0; j--
                    } // myFoundSamples.length != 0
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = "(\\r  )";
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                            myLine = myFoundSamples[j];
                            myLine.contents = PlaceHolderForEnter;
                        } // j >= 0; j--
                    } // myFoundSamples.length != 0
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = "(\\r)";
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                            myLine = myFoundSamples[j];
                            myLine.characters[0].contents = " ";
                        } // j >= 0; j--
                    } // myFoundSamples.length != 0
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = PlaceHolderForEnter;
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                            myLine = myFoundSamples[j];
                            myLine.contents = "\r";
                        } // j >= 0; j--
                    } // myFoundSamples.length != 0
                } // найдены 'Enter-пробел-пробел'
            } // myOneLineIsOneAbzatzFromMenu == 1

            //~ myFindChangeUsingGREP("\\]","] ",pBar," Порядок в оформлении скобок ]");
            //~ myFindChangeUsingGREP("\\["," [",pBar," Порядок в оформлении скобок [");
            //~ myFindChangeUsingGREP("\\)",") ",pBar," Порядок в оформлении скобок )");
            //~ myFindChangeUsingGREP("\\("," (",pBar," Порядок в оформлении скобок ("); 
            //~ myFindChangeUsingGREP("\\}","} ",pBar," Порядок в оформлении скобок }");
            //~ myFindChangeUsingGREP("\\{"," {",pBar," Порядок в оформлении скобок {");
            /////>>>>>>
            //myFindChangeUsingGREP("(„|“|«|»|”|‚|‘|’|\'|\")( )(\\[|\\(|\\{)","$1" + "$3",pBar," Удаление пробела между кавычкой и открывающей скобкой");
            //myFindChangeUsingGREP("( \\]|\\)|\\})( )(„|“|«|»|”|‚|‘|’|\'|\")","$1" + "$3",pBar," Удаление пробела между закрывающей скобкой и кавычкой");
            myFindChangeUsingGREP(myText, "(»|”|’)(\\[|\\(|\\{)", "$1" + " " + "$2", pBar, " Добавление пробела между закрывающей кавычкой и открывающей скобкой");
            myFindChangeUsingGREP(myText, "(=)(" + mySep + "*|" + mySep + "+)(-)", "$1" + " " + "–", pBar, " Замена дефиса на минус");
            myFindChangeUsingGREP(myText, "(\\[|\\(|\\{)(" + mySep + "*|" + mySep + "+)(-)", "$1" + "–", pBar, " Замена дефиса после скобки на минус");

            if (repCharFromMenu == 1 && spaces.value == 1) {
                myFindChangeUsingGREP(myText, myMultipleSpaces, mySingleSpace, pBar, " Избавление от повторяющихся пробелов ");
                myFindChangeUsingGREP(myText, "([\\r\\n])( )", "$1", pBar, " Удаление пробелов в начале строки...");
                if (myText.characters.firstItem().contents == " ") { myText.characters.firstItem().remove();  /* alert("2647 : myText.characters.firstItem().remove()"); */ }
            }
            myFindChangeUsingGREP(myText, "(д\\.)(\\d)", "$1" + " " + "$2", pBar, " Отбивка между 'д.' и номером");
            myFindChangeUsingGREP(myText, "(д\\.)( )(\\d)", "$1" + myThinSpace + "$3", pBar, " Отбивка между 'д.' и номером");
            //myFindChangeUsingGREP ("([[:blank:]]*)",mySingleSpace); // эта строка и табуляцию учитывает. А тут это не допустимо
            myFindChangeUsingGREP(myText, myNonbreakingHyphen, "-", pBar, " Замена неразрывных дефисов на обычные");
            if (repCharFromMenu != 2) { // repCharFromMenu != 2      
                if (repCharFromMenu == 1 && shenters.value == 1) { //  && shenters.value == 1
                    myCurrActionNumber++;
                    myNextStep(pBar, myCurrActionNumber);
                    myFindChangeUsingGREP(myText, "\\n{2,}", "\\n", pBar, " Избавление от повторяющихся принудительных переводов строки");
                } //  && shenters.value == 1
                if (repCharFromMenu == 1 && enters.value == 1) { //  && enters.value == 1
                    myCurrActionNumber++;
                    myNextStep(pBar, myCurrActionNumber);
                    myFindChangeUsingGREP(myText, "\\r{2,}", mySingleReturn, pBar, " Избавление от повторяющихся обычных переводов строки");
                } //  && enters.value == 1
                if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 1) { //  se 11
                    myFindChangeUsingGREP(myText, "\\n\\r", "\\n", pBar, " Избавление от повторяющихся переводов строки");
                    myFindChangeUsingGREP(myText, "\\r\\n", "\\r", pBar, " Избавление от повторяющихся переводов строки");
                }  //  se 11
                if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 0) { //  se 10 
                    myFindChangeUsingGREP(myText, "\\r\\n", "\\r", pBar, " Избавление от повторяющихся переводов строки");
                }  //  se 10
                if (repCharFromMenu == 1 && shenters.value == 0 && enters.value == 1) { //  se 01
                    myFindChangeUsingGREP(myText, "\\n\\r", "\\n", pBar, " Избавление от повторяющихся переводов строки");
                }  //  se 01
                try { while (myText.characters[-1].contents == "\u000D" || myText.characters[-1].contents == SpecialCharacters.FORCED_LINE_BREAK || myText.characters[-1].contents == " ") myText.characters[-1].remove(); } catch (e) { }
                // удаление переводов строки и одиночных пробелов в начале и конце ячеек таблиц
                var myCellData;
                var myCellDataCont = "";
                for (var i = 0; i < myText.tables.length; i++) { // i
                    for (var j = 0; j < myText.tables[i].cells.length; j++) { // j
                        myCellData = myText.tables[i].cells[j].texts[0];
                        myCellDataCont = myCellData.contents;
                        if (myCellDataCont.length == 0) continue;
                        if (repCharFromMenu == 1 && shenters.value == 1) { try { mySimpleFindChangeUsingGREP(myCellData.texts[0], "\\n{2,}", "\\n"); } catch (e) { } }
                        if (repCharFromMenu == 1 && enters.value == 1) { try { mySimpleFindChangeUsingGREP(myCellData, "\\r{2,}", "\\r"); } catch (e) { } }
                        if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 1) { //  se 11
                            try { mySimpleFindChangeUsingGREP(myCellData, "\\n\\r", "\\n"); } catch (e) { }
                            try { mySimpleFindChangeUsingGREP(myCellData, "\\r\\n", "\\r"); } catch (e) { }
                        }  //  se 11
                        if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 0) { try { mySimpleFindChangeUsingGREP(myCellData, "\\r\\n", "\\r"); } catch (e) { } }
                        if (repCharFromMenu == 1 && shenters.value == 0 && enters.value == 1) { try { mySimpleFindChangeUsingGREP(myCellData, "\\n\\r", "\\n"); } catch (e) { } }
                        if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 1) { // shenters.value == 1  && enters.value == 1
                            try { while (myCellData.characters[-1].contents == "\u000D" || myCellData.characters[-1].contents == SpecialCharacters.FORCED_LINE_BREAK || myCellData.characters[-1].contents == " ") myCellData.characters[-1].remove(); } catch (e) { }
                            try { while (myCellData.characters[0].contents == "\u000D" || myCellData.characters[0].contents == SpecialCharacters.FORCED_LINE_BREAK || myCellData.characters[0].contents == " ") myCellData.characters[0].remove(); } catch (e) { }
                        } // shenters.value == 1  && enters.value == 1
                        else if (repCharFromMenu == 1 && shenters.value == 1 && enters.value == 0) {
                            try { while (myCellData.characters[-1].contents == SpecialCharacters.FORCED_LINE_BREAK || myCellData.characters[-1].contents == " ") myCellData.characters[-1].remove(); } catch (e) { }
                            try { while (myCellData.characters[0].contents == SpecialCharacters.FORCED_LINE_BREAK || myCellData.characters[0].contents == " ") myCellData.characters[0].remove(); } catch (e) { }
                        }
                        else if (repCharFromMenu == 1 && shenters.value == 0 && enters.value == 1) {
                            try { while (myCellData.characters[-1].contents == "\u000D" || myCellData.characters[-1].contents == " ") myCellData.characters[-1].remove(); } catch (e) { }
                            try { while (myCellData.characters[0].contents == "\u000D" || myCellData.characters[0].contents == " ") myCellData.characters[0].remove(); } catch (e) { }
                        }
                    } // j
                } // i
                // удаление переводов строки в конце сноски
                var myFootnote;
                var myFootnoteCont;
                for (var i = 0; i < myText.footnotes.length; i++) { // i
                    myFootnote = myText.footnotes[i];
                    myFootnoteCont = myFootnote.contents;
                    if (myFootnoteCont.length != 0) { // != 0
                        if (myFootnote.characters.lastItem().contents == mySingleReturn) { try { myFootnote.paragraphs.lastItem().characters.lastItem().remove(); } catch (e) { } }
                        if (myFootnote.characters.lastItem().contents == " ") { try { myFootnote.paragraphs.lastItem().characters.lastItem().remove(); } catch (e) { } }
                    } // != 0  
                } // i
            } // repCharFromMenu != 2
            if (startTabsFromMenu != 2) { // startTabsFromMenu != 2
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (startTabsFromMenu == 1) {
                    myFindChangeUsingGREP(myText, "([\\r\\n])(\\t+)", "$1", pBar, " Удаление табуляции в начале абзаца...");
                }
            } // startTabsFromMenu != 2      
            if (tabs2spacesFromMenu != 2) { // tabs2spacesFromMenu != 2
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (tabs2spacesFromMenu == 1) {
                    myFindChangeUsingGREP(myText, "\t", mySingleSpace, pBar, " Замена одиночных табуляций на пробелы..");
                    //if (repCharFromMenu == 1) { myFindChangeUsingGREP ("([\\r\\n])( )","$1",pBar," Удаление пробелов в начале строки...");  /* alert("2725 # tabs2spacesFromMenu : пробелы в начале строки..."); */}
                    if (repCharFromMenu == 1 && spaces.value == 1) myFindChangeUsingGREP(myText, myMultipleSpaces, mySingleSpace, pBar, " Избавление от повторяющихся пробелов ");
                    if (myText.characters.firstItem().contents == " ") { myText.characters.firstItem().remove(); /* alert("2727 # tabs2spacesFromMenu : myText.characters.firstItem()");*/ }
                }
            } // tabs2spacesFromMenu != 2   
            //  ~e -- это многоточие
            myFindChangeUsingGREP(myText, "\\.\\.\\.", "~e", pBar, " Замена трех точек на многоточие");
            //myFindChangeUsingGREP("\\.\\.\\.\\.","~e ",pBar," Четыре точки на многоточие и пробел");
            myFindChangeUsingGREP(myText, "~e\\.", "~e ", pBar, " Многоточие и точка на многоточие и пробел");
            myFindChangeUsingGREP(myText, "\\.~e", "\\. ~e", pBar, " Точка и многоточие на точку пробел и многоточие");
            //myFindChangeUsingGREP(",\\.\\.\\.",",\.\. ",pBar," Запятая и три точки");
            //myFindChangeUsingGREP(",~e",",\.\. ",pBar," Запятая и многоточие");
            //myFindChangeUsingGREP("!\\.\\.\\.","!\.\. ",pBar," Восклицательный знак и три точки");
            //myFindChangeUsingGREP("!~e","!\.\. ",pBar," Восклицательный знак и многоточие"); 
            //myFindChangeUsingGREP("\\?\\.\\.\\.","?\.\. ",pBar," Вопросительный знак и три точки"); 
            //myFindChangeUsingGREP("\\?~e","?\.\. ",pBar," Вопросительный знак и многоточие");  
            myFindChangeUsingGREP(myText, myChar0x2212, "–", pBar, " Замена минуса (знак с кодом 0х2212) на короткое тире");
            if (repCharFromMenu == 1) { myFindChangeUsingGREP(myText, "(\\r|\\n)( )", "$1", pBar, " Удаление пробела после перевода строки"); /* alert ("2742"); */ }
            if (hyphensFromMenu != 2) { // hyphensFromMenu != 2
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (hyphensFromMenu == 1) { // == 1
                    //=- 18.10.2013 -- оказалось, что моя процедура myFindChangeUsingGREP не работает корректно, когда операнд замены ничего не содержит. Пришлось вернуть из версии 208-2010 для этих двух случаев старый проверенный модуль простой замены :))
                    //=- не будет, правда, вывода на экран сообщения о текущей выполняемой операции, ну и ... обойдемся, в общем.
                    //myFindChangeUsingGREP(myDiscretionaryHyphen,"",pBar," Удаление переносов");  // удаляем переносы, которые могли остаться из кварковских файлов
                    mySimpleChange(myText, myDiscretionaryHyphen, ""); // удаляем расставленные переносы
                    //myFindChangeUsingGREP(myWinWordHyphen,"",pBar," Удаление переносов"); // удаляем переносы, которые могли быть в вордовских файлах
                    mySimpleChange(myText, myWinWordHyphen, ""); // удаляем переносы программы WinWord
                } // == 1
            } // hyphensFromMenu != 2      
            myFindChangeUsingGREP(myText, "(\\([\\l\\u]{1,2})( )", "$1" + myNonBreakableSpaceVariableWidth, pBar, " Скобка и одно- двухбуквенное слово не должны оставаться в конце строки");
            var myRealTire;
            commonTireFromMenu == 0 ? myRealTire = "–" : myRealTire = "—";
            //minusFromMenu == 0 ? myMinusChar =  "—" : myMinusChar =  "–" ;
            //~ if (minusFromMenu == 1 && tireFromMenu == 0 && defisFromMenu == 0)  myMinusChar =  "–" 
            //~ else if (minusFromMenu == 0 && tireFromMenu == 1 && defisFromMenu == 0) myMinusChar =  "—"
            //~ else if (minusFromMenu == 0 && tireFromMenu == 0 && defisFromMenu == 1) myMinusChar =  "-"
            //~ else myMinusChar =  "–";

            if (minusFromMenu == 1 && tireFromMenu == 0 && defisFromMenu == 0 && defisNFromMenu == 0) myRealDigitSeparator = "–"
            else if (minusFromMenu == 0 && tireFromMenu == 1 && defisFromMenu == 0 && defisNFromMenu == 0) myRealDigitSeparator = "—"
            else if (minusFromMenu == 0 && tireFromMenu == 0 && defisFromMenu == 1 && defisNFromMenu == 0) myRealDigitSeparator = "-"
            else if (minusFromMenu == 0 && tireFromMenu == 0 && defisFromMenu == 0 && defisNFromMenu == 1) myRealDigitSeparator = myNonbreakingHyphen;
            else myRealDigitSeparator = "–";
            app.findGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = "\\r";
            myFound = myText.findGrep();
            for (var j = 0; j < myFound.length; j++) { // j < myFound.length	
                var myC = myFound[j];
                var myIndx = myC.index;
                try { myC.parent.characters[myIndx].fontStyle = "Regular"; } catch (e) { }
                pBar.info(" Присвоение всем знакам перевода строки светлого начертания " + j + "/" + myFound.length);
            } //  j < myFound.length
            myFindChangeUsingGREP(myText, "(°)( *)([CС])", "$1" + "C", pBar, " Приведение в порядок написания температуры по Цельсию"); // русская и латинская буквы С
            myFindChangeUsingGREP(myText, "(\\d)(°C)", "$1" + " " + "$2", pBar, " Приведение в порядок написания температуры по Цельсию");
            myFindChangeUsingGREP(myText, "--", "—", pBar, " Замена двух подряд идущих дефисов на тире");
            myFindChangeUsingGREP(myText, "([\\(\\[\\{])( )", "$1", pBar, " Удаление пробела после открывающей скобки");
            myFindChangeUsingGREP(myText, "( )([\\)\\]\\}])", "$2", pBar, " Удаление пробела перед закрывающей скобкой");
            //myFindChangeUsingGREP("([\\r\\n \\(])([-—])(\\d)","$1" + myMinusChar + "$3",pBar," Ищем пробел и тире (или дефис) перед цифрой и ставим перед цифрой минус"); 
            myFindChangeUsingGREP(myText, "([\\r\\n \\(])([-—])(\\d)", "$1" + "–" + "$3", pBar, " Ищем пробел и тире (или дефис) перед цифрой и ставим перед цифрой минус");
            myFindChangeUsingGREP(myText, myNonbreakingHyphen + myNonbreakingHyphen, "—", pBar, " Замена двух подряд идущих неразрывных дефисов на тире");
            myFindChangeUsingGREP(myText, "-" + myNonbreakingHyphen, "—", pBar, " Замена обычного дефиса и неразрывного на тире");
            myFindChangeUsingGREP(myText, myNonbreakingHyphen + "-", "—", pBar, " Замена неразрывного дефиса и обычного на тире");
            //myFindChangeUsingGREP("(,|\\.)( *)(-|–|—)","$1" + "—",pBar," Удаление пробела после запятой(или точки) перед тире (попутно минус или дефис превращаем в тире)"); 
            myFindChangeUsingGREP(myText, "(,|\\.)( *)(-|–|—)( )", "$1" + "— ", pBar, " Удаление пробела после запятой(или точки) перед тире (попутно минус или дефис превращаем в тире)");
            myFindChangeUsingGREP(myText, "([\\l\\u])(—)([\\l\\u])", "$1" + " — " + "$3", pBar, "  Разделяющий слова минус превращаем в тире)");
            myFindChangeUsingGREP(myText, " - ", " — ", pBar, " Замена дефиса, отбитого пробелами, на тире со стандартными отбивками");
            myFindChangeUsingGREP(myText, " – ", " — ", pBar, " Замена минуса, отбитого пробелами, на тире со стандартными отбивками");
            //myFindChangeUsingGREP("( *)([,;:!\\?\\)\\]\\}%‰])","$2",pBar," Удаление пробелов перед знаками пунктуации, кроме точки, скобками, знаками % и ‰");
            myFindChangeUsingGREP(myText, "( *)([,;:!\\?\\)\\]\\}%‰])", "$2", pBar, " Удаление пробелов перед скобками и знаками пунктуации, кроме точки");
            myFindChangeUsingGREP(myText, "( *)(\\.)([ \\l\\u\\r\\n—])", "$2$3", pBar, " Удаление пробелов перед точкой, если за ней не идёт цифра, а идут пробел и буква, тире или перевод строки        ");
            var sep2defis = "–";
            startCharsLine = "(\\u|\\l|„|“|«|»|”|‚|‘|’|\'|\"|~e)";
            if (myDPdefisFromMenu == 1) sep2defis = "-";
            if (myDPminusFromMenu == 1) sep2defis = "–";
            // if (myDPtireFromMenu == 1) sep2defis = myRealTire;    
            if (myDPtireFromMenu == 1) sep2defis = "—";
            myFindChangeUsingGREP(myText, "(\\r|\\n)([-–—])( *)" + startCharsLine, "$1" + sep2defis + " " + "$4", pBar, " Замена дефиса после перевода строки");
            //myFindChangeUsingGREP("(\\r|\\n)( *)([-–—])( *)(\\u|\\l|„|“|«|»|”|‚|‘|’|\'|\"|~e)","$1" + myRealTire + myAllSpacesValues[mySpaceAfterTireInDialogFromMenu] + "$5",pBar," Дефис или минус в начале абзаца заменяется на тире, после выбранная пользователем шпация");
            myFindChangeUsingGREP(myText, "(\\r|\\n)( *)([-–—])( *)" + startCharsLine, "$1$3" + myAllSpacesValues[mySpaceAfterTireInDialogFromMenu] + "$5", pBar, " Дефис или минус в начале абзаца заменяется на тире, после выбранная пользователем шпация");
            myFindChangeUsingGREP(myText, "([!\\?])(\\u)", "$1" + " " + "$2", pBar, " Восстановление потерянного пробела после ! или ?");
            //myFindChangeUsingGREP("([~e,:;])([\\l\\u])","$1"+" "+"$2",pBar," Восстановление потерянного пробела после знаков пунктуации");
            var punctseq = "([,:;])";
            if (addSpaceAfterDot == true) punctseq = "([,:;.])";
            myFindChangeUsingGREP(myText, punctseq + "([\\l\\u])", "$1" + " " + "$2", pBar, " Восстановление потерянного пробела после знаков пунктуации"); // 4/1/2015  из этого списка знаков пунктуации исключили многоточие
            myFindChangeUsingGREP(myText, "([~e,.])([–—])( *)([\\l\\u])", "$1" + " " + "$2" + " " + "$4", pBar, " Восстановление потерянного пробела перед тире");  // строка изменена 22.09.2016.: до этого тут был и дефис. И неожиданный пробел после дефиса совершенно не нужен.
            myFindChangeUsingGREP(myText, "(\\d)( *)(г\\.|гг\\.|г\\.г\\.)", "$1" + myNonbreakingSpace + "$3", pBar, " Неразрывный изменяемый пробел перед 'г.' или 'гг.'");
            //myFindChangeUsingGREP("(І|I|V|X|Х|L|M|М|C|С)( )" + myWordsAfterRomanDigits,"$1" + myNonbreakingSpace + "$3",pBar," Неразрывный изменяемый пробел между римской цифрой и 'в./вв./век'" ); // XХ MМ CС  -- русские и латинские буквы   myTwoSpacesValues[TwoSpacesDropFromMenu]
            myFindChangeUsingGREP(myText, "(І|I|V|X|Х|L|M|М|C|С)( )" + myWordsAfterRomanDigits, "$1" + myTwoSpacesValues[TwoSpacesDropFromMenu] + "$3", pBar, " Неразрывный изменяемый пробел между римской цифрой и 'в./вв./век'"); // XХ MМ CС  -- русские и латинские буквы  
            myFindChangeUsingGREP(myText, "(І|I|V|X|Х|L|M|М|C|С)(-|–|—| —| -| –| —|- |– |— )(І|I|V|X|Х|L|M|М|C|С)", "$1" + myRealDigitSeparator + "$3", pBar, " Тире, минус или дефис между римскими цифрами"); // ІI  -- белорусские и латинские буквы,  XХ MМ CС  -- русские и латинские буквы
            //myFindChangeUsingGREP("(\\u\\l+)( )(І|I|V|X|Х|L|M|М|C|С)","$1" + myNonbreakingSpaceFixedWidth + "$3",pBar," Неразрывный изменяемый пробел между Именем и римской цифрой"); // XХ MМ CС  -- русские и латинские буквы
            myFindChangeUsingGREP(myText, "(\\u\\l+)( )([І|I|V|X|Х]+\\b)", "$1" + myNonbreakingSpaceFixedWidth + "$3", pBar, " Неразрывный фиксированный пробел между Именем и римской цифрой"); // ІI  -- белорусские и латинские буквы, XХ  -- русские и латинские буквы
            //myFindChangeUsingGREP("(\?<=[а-я]) (\?=(\?-i)[І|I|V|X|Х]+\\b)",myNonbreakingSpaceFixedWidth,pBar," Неразрывный изменяемый пробел между Именем и римской цифрой I, V или Х"); // за основу взят grep-запрос Алексея Чмеля, добавлена русская буква Х
            //~ И ещё я когда-то разработал для себя вот такой греп-запрос. Он отлавливает "нумерованных" латиницей царей-королей:
            //~ Найти: (?<=[а-я])\h(?=(?-i)[I|V|X]+\b(?!(\hвек|\hстолет|\hтысячелет|\hв\.|\hвв\.|~=|~_|-|~~)))
            //~ Заменить на: ~S
            //  18.10.2013 -- этот запрос не делает различия между строчными и прописными, поэтому используется другой вариант
            myFindChangeUsingGREP(myText, "( )([І|I|V|X|Х|L|M|М|C|С]+\\b)( )(\\u\\l+)", "$1" + "$2" + myNonbreakingSpaceFixedWidth + "$4", pBar, " Неразрывный фиксированный пробел между числом из римских цифр и словом с прописной буквы"); // ІI  -- белорусские и латинские буквы, XХ  -- русские и латинские буквы
            myFindChangeUsingGREP(myText, "([№§])", "$1" + myNonbreakingSpaceFixedWidth, pBar, " Неразрывный фиксированный пробел после № или §");
            myFindChangeUsingGREP(myText, myNonbreakingSpaceFixedWidth + " ", myNonbreakingSpaceFixedWidth, pBar, " Неразрывный фиксированный пробел после № или §"); // на случай, если до выполнения операции предыдущей строки перед номером и параграфом был пробел
            // if (spaceAfterBracketInList == true) myFindChangeUsingGREP(myText,"(\\s)([[:alpha:][:digit:]]+)(\\))( )","$1$2$3"+ myNonbreakingSpace,pBar," Неразрывный пробел после скобки в списке");
            if (spaceAfterBracketInList == true) myFindChangeUsingGREP(myText, "(\\s)([[:digit:]]{1,2}|[[:alnum:]]{1})(\\))( )", "$1$2$3" + myNonbreakingSpace, pBar, " Неразрывный пробел после скобки в списке");
            if (commonTireFromMenu != 2) { // commonTireFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (commonTireFromMenu == 0) {  // в качестве тире выбран минус
                    myFindChangeUsingGREP(myText, " — ", " – ", pBar, " Замена тире на минус");
                    myFindChangeUsingGREP(myText, "— ", "– ", pBar, " Замена тире и пробела на минус");
                    myFindChangeUsingGREP(myText, " —", " –", pBar, " Замена пробела и тире на минус");
                }
            } // commonTireFromMenu != 2    
            //minusFromMenu == 0  ?  myRealDigitSeparator = "—"   : myRealDigitSeparator = "–" ;
            //~ if (minusFromMenu == 1 && tireFromMenu == 0 && defisFromMenu == 0 && defisNFromMenu == 0)  myRealDigitSeparator =  "–" 
            //~ else if (minusFromMenu == 0 && tireFromMenu == 1 && defisFromMenu == 0 && defisNFromMenu == 0) myRealDigitSeparator =  "—"
            //~ else if (minusFromMenu == 0 && tireFromMenu == 0 && defisFromMenu == 1 && defisNFromMenu == 0) myRealDigitSeparator =  "-"
            //~ else if (minusFromMenu == 0 && tireFromMenu == 0 && defisFromMenu == 0 && defisNFromMenu == 1) myRealDigitSeparator =  myNonbreakingHyphen
            //~ else myRealDigitSeparator =  "–";
            //
            // для единообразия оформления: если после числа есть пробел, а затем в верхнем регистре минус или плюс и число, то этот пробел тоже будет в верхнем регистре
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findGrepPreferences.findWhat = "(\\d)( )([+-–—])";
            myFoundSamples = myText.findGrep();
            for (var q = myFoundSamples.length - 1; q >= 0; q--) { // q--
                myFoundSamples[q].characters[1].position = myFoundSamples[q].characters[2].position;
            } // q--
            // Минус между цифрами
            myFindChangeUsingGREP(myText, "(\\d)(\\x{002D}|-|–|—| — | —|— | – | –|– | -|- )(\\d)", "$1" + myRealDigitSeparator + "$3", pBar, " Тире, минус или дефис между цифрами"); // есть пробелы до и/или после

            /////////////////////////>>>>>>>>>>>>
            // следующие две строки -- учет ситуации, что при обработке последовательности цифр, разделенных дефисами, вторая цифра попала в grep-анализ, и дефис после неё обнаружен не будет.
            // Поэтому если этих строк не будет, то 1-2-3-4-5 будет выглядеть так: 1—2-3—4-5.
            // А с ними: 1—2—3—4—5
            //~ if (myRealDigitSeparator == "—") myFindChangeUsingGREP("(\\d)(\\x{002D}|-|–| – | –|– | -|- )(\\d)","$1" + myRealDigitSeparator + "$3",pBar," Минус между цифрами");
            //~ if (myRealDigitSeparator == "–") myFindChangeUsingGREP("(\\d)(\\x{002D}|-|—| — | —|— | -|- )(\\d)","$1" + myRealDigitSeparator + "$3",pBar," Минус между цифрами");
            myFindChangeUsingGREP(myText, "(\\d)(\\x{002D}|-|–| – | –|– | -|- )(\\d)", "$1" + myRealDigitSeparator + "$3", pBar, " Тире, минус или дефис между цифрами");
            myFindChangeUsingGREP(myText, "(\\d)(\\x{002D}|-|—| — | —|— | -|- )(\\d)", "$1" + myRealDigitSeparator + "$3", pBar, " Тире, минус или дефис между цифрами");

            ///  В наращениях года:1950-x и пр. этот дефис делаем неразрывным. Эта обработка несколько похожа, конечно, на упорядочение наращивания чисел, но вынесена отдельно, чтобы быть выполненной независимо от выбора пользователя - упорядочивать наращение чисел или нет.
            //myFindChangeUsingGREP("(\\d)(\\x{002D}|-|—|–)(\\l)","$1" + myNonbreakingHyphen + "$3",pBar," Неразрывный дефис после цифры и буквенного наращения");
            myFindChangeUsingGREP(myText, "(\\l|\\u)(\\x{002D}|-|—|–)(\\d)", "$1" + myNonbreakingHyphen + "$3", pBar, " Неразрывный дефис между буквой и цифрой"); // Т-34,  Ил-62
            myFindChangeUsingGREP(myText, "(\\u)(\\x{002D}|-|—|–)(\\l)", "$1" + myNonbreakingHyphen + "$3", pBar, " Неразрывный дефис между цифрой и буквой"); // в 1935-м  
            ///
            mySetNoBreakRealDigitSeparator(myText, "^9" + myRealDigitSeparator + "^9", pBar);
            mySetNoBreakDefis(myText, "^9" + "-" + "^$", pBar);
            //myFindChangeUsingGREP("( в| во|\\rв|\\nв|\\rво|\\nво)(\\x{002D}|-|–|—| — | —|— | – | –|– | -|- )(\\l)", "$1" + myNonbreakingHyphen + "$3",pBar," Неразрывный дефис после частицы 'в' или 'во'");
            myFindChangeUsingGREP(myText, "( в| во|\\rв|\\nв|\\rво|\\nво)(-)(\\l)", "$1" + myNonbreakingHyphen + "$3", pBar, " Неразрывный дефис после частицы 'в' или 'во'");
            if (digAndCharFromMenu != 2) { // digAndCharFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (digAndCharFromMenu == 1) { // digAndCharFromMenu == 1
                    //myAugment(pBar); 
                    //function (pBar) { //myAugment
                    // Augment -- наращение. Ищем в тексте неправильные наращения, например, 5-ого, 14-ых, и исправляем их: 5-го, 14-х
                    //~ var mySearchedTwoCharacters = "(\\d-ье[,.;:!?"+mySep+"]|\\d-ое[,.;:!?"+mySep+"]|\\d-ая[,.;:!?"+mySep+"]|\\d-ый[,.;:!?"+mySep+"]|\\d-ой[,.;:!?"+mySep+"]|\\d-ий[,.;:!?"+mySep+"]|\\d-ым[,.;:!?"+mySep+"]|\\d-им[,.;:!?"+mySep+"]|\\d-ом[,.;:!?"+mySep+"]|\\d-ем[,.;:!?"+mySep+"]|\\d-ых[,.;:!?"+mySep+"]|\\d-их[,.;:!?"+mySep+"]|\\d-ые[,.;:!?"+mySep+"]|\\d-ьи[,.;:!?"+mySep+"]|\\d-ех[,.;:!?"+mySep+"]|\\d-ёх[,.;:!?"+mySep+"])";
                    //~ var mySearchedThreeCharacters = "(\\d-ого[,.;:!?"+mySep+"]|\\d-его[,.;:!?"+mySep+"]|\\d-ому[,.;:!?"+mySep+"]|\\d-ему[,.;:!?"+mySep+"]|\\d-ыми[,.;:!?"+mySep+"]|\\d-ими[,.;:!?"+mySep+"])";
                    var mySearchedTwoCharacters = "(\\d-ье[,.;:!?\\s]|\\d-ое[,.;:!?\\s]|\\d-ая[,.;:!?\\s]|\\d-ый[,.;:!?\\s]|\\d-ой[,.;:!?\\s]|\\d-ий[,.;:!?\\s]|\\d-ым[,.;:!?\\s]|\\d-им[,.;:!?\\s]|\\d-ом[,.;:!?\\s]|\\d-ем[,.;:!?\\s]|\\d-ых[,.;:!?\\s]|\\d-их[,.;:!?\\s]|\\d-ые[,.;:!?\\s]|\\d-ьи[,.;:!?\\s]|\\d-ех[,.;:!?\\s]|\\d-ёх[,.;:!?\\s])";
                    var mySearchedThreeCharacters = "(\\d-ого[,.;:!?\\s]|\\d-его[,.;:!?\\s]|\\d-ому[,.;:!?\\s]|\\d-ему[,.;:!?\\s]|\\d-ыми[,.;:!?\\s]|\\d-ими[,.;:!?\\s])";
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = mySearchedTwoCharacters;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // 1
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) {
                            myLine = myFoundSamples[j];
                            myLine.characters[1].contents = myNonbreakingHyphen;
                            myLine.characters.itemByRange(2, 2).remove();	// удаляем букву после дефиса
                            //         myLine.characters[1].contents = myNonbreakingHyphen;
                            var tt = myFoundSamples.length - j;
                            pBar.info(" Порядок в двухбуквенном наращении чисел (5-ый > 5-й и пр.)... " + tt + " / " + myFoundSamples.length);
                        }
                    } // 1
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.findGrepPreferences.findWhat = mySearchedThreeCharacters;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    myFoundSamples = myText.findGrep();
                    if (myFoundSamples.length != 0) { // 2
                        // цикл по числу элементов коллекции. Движение снизу вверх
                        for (j = myFoundSamples.length - 1; j >= 0; j--) {
                            myLine = myFoundSamples[j];
                            myLine.characters[1].contents = myNonbreakingHyphen;
                            myLine.characters.itemByRange(2, 2).remove();	// удаляем букву после дефиса   
                            //        myLine.characters[1].contents = myNonbreakingHyphen;
                            var tt = myFoundSamples.length - j;
                            pBar.info(" Порядок в трёхбуквенном наращении чисел (4-ыми > 4-ми и пр.)... " + tt + " / " + myFoundSamples.length);
                        }
                    } // 2
                    //} //myAugment            
                } // digAndCharFromMenu == 1
                ///////////////////////////////////       
            } // digAndCharFromMenu != 2
            if (setquotes_valueFromMenu != 2) { // setquotes_valueFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (setquotes_valueFromMenu == 1 && setLangFromMenu == 1) { pBar.info(" Обработка кавычек"); myAllQuoteProcessing(myText, pBar); }
            } // setquotes_valueFromMenu != 2    
            // mlnWithoutPointFromMenu = 2 - этот случай не анализируется, т.к. он возможен только, когда myCleanValueFromMenu = 0, но тогда не выполняются все команды  { // myCleanValueFromMenu == 1 .......  } // myCleanValueFromMenu == 1
            if (mlnWithoutPointFromMenu == 0) myFindChangeUsingGREP(myText, "(млн|млрд|трлн)( |,)", "$1" + "\." + "$2", pBar, " Добавление точки после млн, млрд, трлн");
            else if (mlnWithoutPointFromMenu == 1) myFindChangeUsingGREP(myText, "(млн|млрд|трлн)(.)( |, )(\\l|\\d)", "$1" + "$3" + "$4", pBar, " Удаление точки после млн., млрд., трлн."); // (\\l|\\d) -- критерий, что точка после сокращения не является концом предложения
            //myFindChangeUsingGREP("( )(\\r|\\n)", "$2",pBar," Удаление пробела перед знаком перевода строки"); < -- эта строка на стыке абзацев разных стилей работает некорректно: следующему за знаком перевода строки абзацу присваивается стиль абзаца, в котором удаляется пробел перед знаком перевода строки
            // Вот это решение свободно это этой проблемы
            app.findGrepPreferences = NothingEnum.nothing;
            app.findGrepPreferences.findWhat = " \r";
            myFoundSamples = myText.findGrep();
            if (myFoundSamples.length != 0) { // 1
                // цикл по числу элементов коллекции. Движение снизу вверх
                for (var jj = myFoundSamples.length - 1; jj >= 0; jj--) {
                    myLine = myFoundSamples[jj];
                    myLine.characters[0].remove();	// удаляем пробел
                    var tt = myFoundSamples.length - jj;
                    pBar.info(" Удаление пробела перед знаком перевода строки ... (текущий знак/общее число знаков) " + tt + "/" + myFoundSamples.length);
                }
            } // 1
            //myFindChangeUsingGREP("(\\r|\\n)(-)( *)([\\u|\\l])", "$1" + myRealTire + " " + "$4",pBar," Замена дефиса после перевода строки на тире");
            // Удаление пробелов перед знаком сноски
            myRemoveSpacesBeforeFootnoteSign(myText);
            myFindChangeUsingGREP(myText, "( |\\()(г\\.)( *)(\\u)", "$1" + "$2" + myNonbreakingSpaceFixedWidth + "$4", pBar, " Востанавливаем пробел между сокращением 'г.' и названием города");
            myFindChangeUsingGREP(myText, "(=)(\\x{002D}|-|–|—)(\\d)", "$1" + " –" + "$3", pBar, " Восстанавливаем пробел между знаком равенства и отрицательным числом");
        } // myCleanValueFromMenu == 1
        ////
        if (myTypographicaValueFromMenu == 1) { // myTypographicaValueFromMenu == 1    
            try {
                MustBeWith = MustBeWithNextWord;
            }
            catch (e) {
                MustBeWith = MustBeWithNextDigit;
            }
            //try { myFindChangeUsingGREP(MustBeWith + "("+mySep+"+)*(\\d)","$1" + myNonbreakingSpace + "$3",pBar," Запрет отрывать однобуквенные сокращения"); } catch (e) { } // на случай,если пользователь захочет отключить эту операцию и закомментирует строку MustBeWithNextWord в файле WordsAndUnits.jsx
            //try { myFindChangeUsingGREP(MustBeWith + "(\\p{zs}+)*(\\d)","$1" + myNonbreakingSpace + "$3",pBar," Запрет отрывать однобуквенные сокращения"); } catch (e) { } // на случай,если пользователь захочет отключить эту операцию и закомментирует строку MustBeWithNextWord в файле WordsAndUnits.jsx
            try { myFindChangeUsingGREP(myText, "(" + mySep + "[\\(\\[]*)" + MustBeWith + "(\\p{zs}+)*(\\d)", "$1" + "$2" + myNonbreakingSpace + "$4", pBar, " Запрет отрывать однобуквенные сокращения"); } catch (e) { } // на случай,если пользователь захочет отключить эту операцию и закомментирует строку MustBeWithNextWord в файле WordsAndUnits.jsx    
            if (fixOneLetterFromMenu != 2) { // fixOneLetterFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (fixOneLetterFromMenu == 1) {
                    myFindChangeUsingGREP(myText, "(\\r|\\n| )" + SpaceLetterNonbreakingSpace + "( )", "$1" + "$2" + myTwoSpacesValues[TwoSpacesDropFromMenu], pBar, " Запрет отрывать однобуквенные слова");
                    myFindChangeUsingGREP(myText, "(\\r|\\n| )" + NonbreakingSpaceLetterSpace + "( )", myTwoSpacesValues[TwoSpacesDropFromMenu] + "$2" + "$3", pBar, " Запрет отрывать однобуквенные слова");
                    //myFindChangeUsingGREP("( "+"|" + myTwoSpacesValues[TwoSpacesDropFromMenu] +")" + NonbreakingSpaceLetterSpace + "( )",myTwoSpacesValues[TwoSpacesDropFromMenu] + "$2" + "$3" ,pBar," Запрет отрывать однобуквенные слова"); 
                    //myFindChangeUsingGREP("(" + " " +"|" + myTwoSpacesValues[TwoSpacesDropFromMenu] +")" + NonbreakingSpaceLetterSpace + "( )",myTwoSpacesValues[TwoSpacesDropFromMenu] + "$2" + "$3" ,pBar," Запрет отрывать однобуквенные слова");         
                    // повтор проверки, чтобы учесть вставленные только что неразрывные пробелы
                    myFindChangeUsingGREP(myText, "(\\r|\\n| )" + SpaceLetterNonbreakingSpace + "(" + myTwoSpacesValues[TwoSpacesDropFromMenu] + ")" + SpaceLetterNonbreakingSpace + "( )", "$1" + "$2" + "$3" + "$4" + myTwoSpacesValues[TwoSpacesDropFromMenu], pBar, " Запрет отрывать однобуквенные слова");
                }
            } // fixOneLetterFromMenu != 2
            if (fixTwoLetterFromMenu != 2) { // fixTwoLetterFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (fixTwoLetterFromMenu == 1) {
                    //myFindChangeUsingGREP("(" + " " +"|" + myTwoSpacesValues[TwoSpacesDropFromMenu] +")" + SpaceTwoLetterNonbreakingSpace + "( )","$1" + "$2" + myTwoSpacesValues[TwoSpacesDropFromMenu],pBar," Запрет отрывать двухбуквенные слова");            
                    myFindChangeUsingGREP(myText, "(\\r|\\n| |" + myTwoSpacesValues[TwoSpacesDropFromMenu] + ")" + SpaceTwoLetterNonbreakingSpace + "( )", "$1" + "$2" + myTwoSpacesValues[TwoSpacesDropFromMenu], pBar, " Запрет отрывать двухбуквенные слова");
                    //myFindChangeUsingGREP("( )" + SpaceTwoLetterNonbreakingSpace + "( )","$1" + "$2" + myTwoSpacesValues[TwoSpacesDropFromMenu],pBar," Запрет отрывать двухбуквенные слова");
                    myFindChangeUsingGREP(myText, "(\\r|\\n| )" + NonbreakingSpaceTwoLetterSpace + "(" + " " + "|" + myTwoSpacesValues[TwoSpacesDropFromMenu] + ")", myTwoSpacesValues[TwoSpacesDropFromMenu] + "$2" + "$3", pBar, " Запрет отрывать двухбуквенные слова");
                    // повтор проверки, чтобы учесть вставленные только что неразрывные пробелы
                    myFindChangeUsingGREP(myText, "(\\r|\\n| )" + SpaceTwoLetterNonbreakingSpace + "(" + myTwoSpacesValues[TwoSpacesDropFromMenu] + ")" + SpaceTwoLetterNonbreakingSpace + "( )", "$1" + "$2" + "$3" + "$4" + myTwoSpacesValues[TwoSpacesDropFromMenu], pBar, " Запрет отрывать однобуквенные слова");
                }
            } // fixTwoLetterFromMenu != 2
            if (bull2textFromMenu != 2) { // bull2textFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (bull2textFromMenu == 1) { pBar.info(" Преобразование буллитов и нумерации в текст"); myText.convertBulletsAndNumberingToText(); }
            } // bull2textFromMenu != 2

            //~     if (opticMarginAlignFromMenu != 2) { // opticMarginAlignFromMenu !=2
            //~         if (opticMarginAlignFromMenu == 1) { // opticMarginAlignFromMenu == 1
            //~             myText.storyPreferences.opticalMarginAlignment = true;
            //~             } // opticMarginAlignFromMenu == 1
            //~         } // opticMarginAlignFromMenu != 2

            if (WordAndLetterSpaceFromMenu != 2) { // WordAndLetterSpaceFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (WordAndLetterSpaceFromMenu == 1) { // WordAndLetterSpaceFromMenu == 1
                    ///>>> Стандартные значения интервалов, на случай, если не удастся получить правильные пользовательские значения
                    defWrdMin = 95;
                    defWrdDesired = 100;
                    defWrdMax = 130;
                    defLtrMin = -5;
                    defLtrDesired = 0;
                    defLtrMax = 10;
                    glyphMin = 96;
                    glyphDesired = 100;
                    glyphMax = 104;
                    ///>>> 
                    var WrdSpArr = [];
                    var LtrSpArr = [];
                    var GlhSpArr = [];
                    //while (WrdSpArr.length > 0) WrdSpArr.shift();
                    //while (LtrSpArr.length > 0) LtrSpArr.shift();
                    WordSpacingIsMissing = false;
                    try {
                        var test = WordSpacing;
                    }
                    catch (e) {
                        WordSpacingIsMissing = true;
                        SetWordSpace(myText, defWrdMin, defWrdDesired, defWrdMax);
                    }
                    LetterSpacingIsMissing = false;
                    try {
                        var test = LetterSpacing;
                    }
                    catch (e) {
                        LetterSpacingIsMissing = true;
                        SetLetterSpace(myText, defLtrMin, defLtrDesired, defLtrMax);
                    }
                    GlyphScalingIsMissing = false;
                    try {
                        var test = GlyphScaling;
                    }
                    catch (e) {
                        GlyphScalingIsMissing = true;
                        SetGlyphSpace(myText, glyphMin, glyphDesired, glyphMax);
                    }
                    if (WordSpacingIsMissing == false) { // WordSpacingIsMissing == false
                        WrdSpArr = WordSpacing.split("/");
                        var rW = testSpace(WrdSpArr, "w");
                        if (rW == null) { }
                        else {
                            defWrdMin = rW[0];
                            defWrdDesired = rW[1];
                            defWrdMax = rW[2];
                        }
                        SetWordSpace(myText, defWrdMin, defWrdDesired, defWrdMax);
                    }  // WordSpacingIsMissing == false
                    ////    
                    if (LetterSpacingIsMissing == false) { // LetterSpacingIsMissing == false
                        LtrSpArr = LetterSpacing.split("/");
                        var rL = testSpace(LtrSpArr, "c");
                        if (rL == null) { }
                        else {
                            defLtrMin = rL[0];
                            defLtrDesired = rL[1];
                            defLtrMax = rL[2];
                        }
                        SetLetterSpace(myText, defLtrMin, defLtrDesired, defLtrMax);
                    } //LetterSpacingIsMissing == false
                    ////
                    if (GlyphScalingIsMissing == false) { // GlyphScalingIsMissing == false
                        GlhSpArr = GlyphScaling.split("/");
                        var rG = testSpace(GlhSpArr, "g");
                        if (rG == null) { }
                        else {
                            glyphMin = rG[0];
                            glyphDesired = rG[1];
                            glyphMax = rG[2];
                        }
                        SetGlyphSpace(myText, glyphMin, glyphDesired, glyphMax);
                    } //GlyphScalingIsMissing == false
                    for (var t = 0; t < myText.tables.length; t++) { // t++
                        for (var c = 0; c < myText.tables[t].cells.length; c++) { // c++
                            //var cellStory = myText.tables[t].cells[c].texts[0].parentStory;
                            var cellStory = myText.tables[t].cells[c].texts[0];
                            if (cellStory.length == 0) continue;
                            SetWordSpace(cellStory, defWrdMin, defWrdDesired, defWrdMax);
                            SetLetterSpace(cellStory, defLtrMin, defLtrDesired, defLtrMax);
                            SetGlyphSpace(cellStory, glyphMin, glyphDesired, glyphMax);
                        } // c++
                    } // t++
                    for (var f = 0; f < myText.footnotes.length; f++) { // f++
                        var currFootnote = myText.footnotes[f].texts[0];
                        if (currFootnote.length == 0) continue;
                        SetWordSpace(currFootnote, defWrdMin, defWrdDesired, defWrdMax);
                        SetLetterSpace(currFootnote, defLtrMin, defLtrDesired, defLtrMax);
                        SetGlyphSpace(currFootnote, glyphMin, glyphDesired, glyphMax);
                    } // f++            
                    ///
                    function testSpace(myArr, ch) { // testSpace
                        rezOK = true;
                        for (var i = 0; i < myArr.length; i++) { // i++
                            var wv = myArr[i];
                            if (isNaN(Number(wv)) == true) { // isNaN
                                rezOK = false;
                                break;
                            } // isNaN
                            else { // else
                                myArr[i] = (Number(wv));
                                continue;
                            } // else
                        } // i++
                        //if (rezOK == false || myArr[0] > myArr[1] || myArr[0] > myArr[2] || myArr[1] > myArr[2] || myArr[0] < 0 || myArr[1] < 0 || myArr[2] < 0 ) return null;
                        if (rezOK == false || myArr[0] > myArr[1] || myArr[0] > myArr[2] || myArr[1] > myArr[2]) return null;
                        if (ch == "w" || ch == "g" && myArr[0] < 0 || myArr[1] < 0 || myArr[2] < 0) return null; // интервалы слов и глифов не могут быть отрицательными
                        return myArr;
                    } // testSpace    
                    ///
                    function SetWordSpace(mySel, wmin, wdes, wmax) { // SetDefaultWrdSpace
                        try { mySel.minimumWordSpacing = mySel.desiredWordSpacing = mySel.maximumWordSpacing = 100; } catch (e) { }// своего рода сброс 
                        try { mySel.minimumWordSpacing = wmin; } catch (e) { }
                        try { mySel.maximumWordSpacing = wmax; } catch (e) { }
                        try { mySel.desiredWordSpacing = wdes; } catch (e) { }
                    } // SetDefaultWordSpace    
                    /////
                    function SetLetterSpace(mySel, lmin, ldes, lmax) { // SetDefaultLetterSpace
                        try { mySel.minimumLetterSpacing = mySel.desiredLetterSpacing = mySel.maximumLetterSpacing = 0; } catch (e) { } // тоже сброс
                        try { mySel.minimumLetterSpacing = lmin; } catch (e) { }
                        try { mySel.maximumLetterSpacing = lmax; } catch (e) { }
                        try { mySel.desiredLetterSpacing = ldes; } catch (e) { }
                    } // SetDefaultLetterSpace    
                    /////     
                    function SetGlyphSpace(mySel, gmin, gdes, gmax) { // SetDefaultGlyphSpace
                        try { mySel.minimumGlyphScaling = mySel.desiredGlyphScaling = mySel.maximumGlyphScaling = 100; } catch (e) { }// тоже сброс
                        try { mySel.minimumGlyphScaling = gmin; } catch (e) { }
                        try { mySel.maximumGlyphScaling = gmax; } catch (e) { }
                        try { mySel.desiredGlyphScaling = gdes; } catch (e) { }

                    } // SetDefaultGlyphSpace   
                    /////
                }  // WordAndLetterSpaceFromMenu == 1
            }  // WordAndLetterSpaceFromMenu != 2  

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////   
            if (fixDigitAndWordFromMenu != 2) { // fixDigitAndWordFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (fixDigitAndWordFromMenu == 1) { // fixDigitAndWordFromMenu == 1
                    myFindChangeUsingGREP(myText, myUnits, "$1" + myNonbreakingSpace + "$3", pBar, " Неразрывный изменяемый пробел между числом и единицей измерения [1]");
                    //myFindChangeUsingGREP (myWordsBeforeDigit, "$1" + myNonbreakingSpace + "$3",pBar," Неразрывный изменяемый пробел между словом и числом");
                    // myFindChangeUsingGREP ("(["+mySep+"\\r\\n])" + myWordsBeforeDigit +"("+mySep+"+)*" + "(\\d)", "$1" + "$2"+ myNonbreakingSpace + "$4",pBar," Неразрывный изменяемый пробел между словом и числом");      
                    myFindChangeUsingGREP(myText, "([" + mySep + "\\r\\n][\\(\\[]*)" + myWordsBeforeDigit + "(" + mySep + "+)*" + "(\\d)", "$1" + "$2" + myNonbreakingSpace + "$4", pBar, " Неразрывный изменяемый пробел между словом и числом"); // учтем, что перед словом может быть круглая или квадратная скобка              
                    if (ProcessMultyWordsUnits) { // ProcessMultyWordsUnits
                        myFindChangeUsingGREP(myText, my2WordsUnits, "$1" + myNonbreakingSpace + "$3" + myNonbreakingSpace + "$5", pBar, " Неразрывный изменяемый пробел между числом и единицей измерения [2]");  // my2WordsUnits = "(\\d|\\l)( )(тыс.|млн\.*)( )(Гкал|ккал|км|устройств)";
                        myFindChangeUsingGREP(myText, my3WordsUnits, "$1" + myNonbreakingSpace + "$3" + myNonbreakingSpace + "$5" + myNonbreakingSpace + "$7", pBar, " Неразрывный изменяемый пробел между числом и единицей измерения [3]");
                    } // ProcessMultyWordsUnits
                } // fixDigitAndWordFromMenu == 1
            } // fixDigitAndWordFromMenu != 2
            //myFindChangeUsingGREP ("( )" + "/", myNonbreakingSpace + "/",pBar," Неразрывный изменяемый пробел перед наклонной чертой");    
            mySetNoBreakDoubleSlachAndChar(myText, "//.", pBar);
            //myFindChangeUsingGREP ("(^\\d+\\))" + "("+mySep+"+)*", "$1" + " ",pBar," Пробел после скобки с перечислениями");     
            myFindChangeUsingGREP(myText, "(\\))" + "(\"[\\l\\.,]|\\'[\\l\\.,;])", "$1" + " " + "$2", pBar, " Пробел между закрывающей скобкой и кавычкой");
            myFindChangeUsingGREP(myText, "([\\l\\u]\"|\\')" + "(\\()", "$1" + " " + "$2", pBar, " Пробел между кавычкой и открывающей скобкой");
            myFindChangeUsingGREP(myText, "(\\d+\\))" + "(\\u|\\l)", "$1" + " " + "$2", pBar, " Пробел после скобки с перечислениями");
            if (charStylesFromMenu != 2) { // charStylesFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (charStylesFromMenu == 1) { pBar.info(myBoldItalicIndexInfo); myBoldItalicAndIndexSelection(myText, pBar.info); }
            } // charStylesFromMenu != 2
            if (grekCharStylesFromMenu != 2) { // grekCharStylesFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (grekCharStylesFromMenu == 1) myGrekChar(myText);
            } // grekCharStylesFromMenu != 2
            underlineAndCapslock(myText);
            if (footnote1FromMenu != 2) { // footnote1FromMenu != 2
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (footnote1FromMenu == 1) {  //  footnote1FromMenu == 1  
                    pBar.info(" Приведение в порядок очерёдности знаков пунктуации и сносок"); FootnoteSignMustBe(myText, "BeforePoint");   // ищем случаи, когда сперва точка/запятая, потом знак сноски, и меняем их местами
                }  //  footnote1FromMenu == 1
                else { pBar.info(" Приведение в порядок очерёдности знаков пунктуации и сносок"); FootnoteSignMustBe(myText, "AfterPoint"); }    // ищем случаи, когда сперва знак сноски, потом  точка/запятая, и меняем их местами
                myAddSpacesBeforeFootnoteSign(myText); // перед знаком сноски ставим волосяную шпацию
            } // footnote1FromMenu != 2
            MakeSlashNoBreak(myText, pBar);   // ищем случаи ц/га, руб./долл. и пр. и присваиваем наклонной черте атрибут NoBreak
            ///----  (c) Борис Кащеев
            ////if (oneStyleFromMenu == true) myText.paragraphs.itemByRange(0,-1).appliedParagraphStyle = myDocument.paragraphStyles[ParaIndexFromMenu];
            if (oneStyleFromMenu == true) myText.paragraphs.itemByRange(0, -1).appliedParagraphStyle = getParagraphStyleByName(myParaStyleNames[ParaIndexFromMenu]);
            ///----- 
            if (setLangFromMenu == 1) { // setLangFromMenu == 1
                var myTextObject = myText.texts.item(0);
                try {
                    myTextObject.appliedLanguage = app.languagesWithVendors[myLanguageListFromMenu];
                }
                catch (e) {
                    alert("Не удалось присвоить тексту язык " + app.languagesWithVendors[myLanguageListFromMenu].name, myProgramTitul);
                }
            } // setLangFromMenu == 1
            //~ 	// заменим все реразрывные гибкие пробелы на обычные с атрибутом Nobreak
            //~     app.findGrepPreferences = NothingEnum.nothing;
            //~     app.changeGrepPreferences = NothingEnum.nothing;
            //~     app.findChangeGrepOptions.includeFootnotes = true;
            //~     app.findGrepPreferences.findWhat = myNonBreakableSpaceVariableWidth;
            //~     app.changeGrepPreferences.changeTo = " ";    
            //~     app.changeGrepPreferences.noBreak = true;
            //~     myText.changeGrep();     
            if (partHEFromMenu == 1) { // partHEFromMenu == 1
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "(?<=( ))(не\\l)";
                //var rr = myText.findGrep();
                app.changeGrepPreferences.noBreak = true;
                myText.changeGrep();
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "(\\lне)(?=([ .,]))";
                //var rr = myText.findGrep();
                app.changeGrepPreferences.noBreak = true;
                myText.changeGrep();
            } // partHEFromMenu == 1
        }  // myTypographicaValueFromMenu == 1
        /*
        if (myCleanValueFromMenu == 1) { // myCleanValueFromMenu == 1  (вторая проверка)
        app.findGrepPreferences = NothingEnum.nothing;
        //app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "(\\l\\d)";				
        myFoundSamples = myText.findGrep();
        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            if (myFoundSamples[i].characters[1].parent.constructor.name != "Footnote" && myFoundSamples[i].characters[1].position == Position.SUPERSCRIPT)
            myFoundSamples[i].insertionPoints[1].contents = HairSpace;
        } // myFoundSamples.length - 1
        } //   (вторая проверка)
        */
        /////
        if (mySpatiumValueFromMenu == 1) { // mySpatiumValueFromMenu == 1
            if (tireAndSpatiumFromMenu != 2) { // tireAndSpatiumFromMenu != 2   
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                var myRealTire;
                commonTireFromMenu == 0 ? myRealTire = "–" : myRealTire = "—";
                if (tireAndSpatiumFromMenu == 1) { // tireAndSpatiumFromMenu == 1

                    myFindChangeScaleUsingGREP(myText, "( )(-)(\\r)", myAllSpacesValues[mySpaceListBeforeFromMenu] + myRealTire + "$3", myRealTire, pBar, " Обработка дефиса в конце строки");

                    if (curLineAboutSpaces == lineForSpatios && spationsToSpaceFromMenu == 1) { // lineForSpatios && 1
                        // замена шпаций до и после тире на пробелы. Дискреционный разрыв не ставится. Масштабирование пробелов будет позднее.
                        myFindChangeScaleUsingGREP(myText, "([" + myLineOfSpaces + "])(" + myRealTire + ")([" + myLineOfSpaces + "](" + myDiscrLineBreak + "?)" + ")", myAllSpacesValues[1] + myRealTire + myAllSpacesValues[1], myRealTire, pBar, " Обработка шпаций до и после тире");
                    } // lineForSpatios && 1
                    if (curLineAboutSpaces == lineForSpatios && spationsToSpaceFromMenu == 0) { // lineForSpatios && 0
                        myFindChangeScaleUsingGREP(myText, "([" + myLineOfSpaces + "])(" + myRealTire + ")([" + myLineOfSpaces + "](" + myDiscrLineBreak + "?)" + ")", myAllSpacesValues[mySpaceListBeforeFromMenu] + myRealTire + myAllSpacesValues[mySpaceListAfterFromMenu] + myDiscrLineBreak, myRealTire, pBar, " Обработка шпаций до и после тире");
                        //myFindChangeScaleUsingGREP("([" + myLineOfSpaces + "])(" + myRealTire + ")([" + myLineOfSpaces + "](" + myDiscrLineBreak + "?)" + ")",myAllSpacesValues[mySpaceListBeforeFromMenu] + myRealTire + myAllSpacesValues[mySpaceListAfterFromMenu],myRealTire,pBar," Обработка шпаций до и после тире");
                    }  // lineForSpatios && 0
                    if (curLineAboutSpaces == lineForSpaces && spationsToSpaceFromMenu == 1) { // lineForSpaces && 1
                        myFindChangeScaleUsingGREP(myText, "([" + " " + "])(" + myRealTire + ")([" + " " + "](" + myDiscrLineBreak + "?)" + ")", myAllSpacesValues[1] + myRealTire + myAllSpacesValues[1], myRealTire, pBar, " Обработка шпаций до и после тире");
                    }  // lineForSpaces && 1
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    //app.findGrepPreferences.findWhat = "(,|\\.|~e)([" + myLineOfSpaces + "]*)(—|–)";
                    app.findGrepPreferences.findWhat = "([" + myLineOfSpaces + "]" + myRealTire + ")";
                    app.changeGrepPreferences.noBreak = true; // пробел перед тире должен быть неразрывным (это повторное присвоение на случай, если масштаб не выбран)
                    myText.changeGrep();
                } // tireAndSpatiumFromMenu == 1
            } // tireAndSpatiumFromMenu != 2    
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findGrepPreferences.findWhat = "(\\d)( )(\\d{3})";
            myFoundSamples = myText.findGrep();
            for (var q = myFoundSamples.length - 1; q >= 0; q--) { // q--
                // if (myFoundSamples[q].characters[0].position == Position.NORMAL && myFoundSamples[q].characters[2].position == Position.NORMAL) myFoundSamples[q].characters[1].contents = myThinSpace;
                if (myFoundSamples[q].characters[0].position == Position.NORMAL && myFoundSamples[q].characters[2].position == Position.NORMAL) myFoundSamples[q].characters[1].contents = "\u2009";
            } // q--
            //~     app.findChangeGrepOptions.includeFootnotes = true;
            //~     app.findGrepPreferences = NothingEnum.nothing;
            //~     app.changeGrepPreferences = NothingEnum.nothing;
            //~     app.findGrepPreferences.findWhat = "(\\d)( )(\\d)";      
            //~     myFoundSamples = myText.findGrep();
            //~     for (var q = myFoundSamples.length-1; q >= 0; q--) { // q--
            //~         //if (myFoundSamples[q].characters[0].position == Position.NORMAL && myFoundSamples[q].characters[2].position == Position.NORMAL) myFoundSamples[q].characters[1].contents = myThinSpace;
            //~         if (myFoundSamples[q].characters[0].position == Position.NORMAL && myFoundSamples[q].characters[2].position == Position.NORMAL) myFoundSamples[q].characters[1].contents = "\u200A";        
            //~         } // q--    
            //~     myFindChangeUsingGREP("(\\d)( )(\\d)","$1" +myThinSpace + "$3",pBar," Тонкая шпация между цифрами");  
            //~     myFindChangeUsingGREP("(\\d)( )(\\d)","$1" +myThinSpace + "$3",pBar," Тонкая шпация между цифрами");  // эту процедуру надо выполнить дважды, т.к. первая пропустит второй пробел в таком примере 4 5 6
            //myFindChangeUsingGREP("(\\d\\d\\d\\d)( )(год[ау])","$1" +myNonbreakingSpace + "$3",pBar," Неразрывный изменяемый пробел между числом года и словом 'год...'"); 
            myFindChangeUsingGREP(myText, "(І|I|V|X|Х|L|M|М|C|С)" + myNonbreakingSpace + myRealDigitSeparator + "( )(І|I|V|X|Х|L|M|М|C|С)", "$1" + myRealDigitSeparator + "$5", pBar, " Тире, минус или дефис между римскими цифрами"); //  ІI -- белорусские и латинские буквы,   XХ MМ CС  -- русские и латинские буквы 
            if (commatireFromMenu != 2) { // commatireFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                //myFindChangeUsingGREP("(\\.)(—|–)","$1" + " " + myRealTire,pBar," Шпация между точкой и тире");    
                if (commatireFromMenu == 1) { // commatireFromMenu == 1
                    myFindChangeUsingGREP(myText, "(,|\\.|~e)([" + myLineOfSpaces + "]*)(—|–)", "$1" + myAllSpacesValues[myCommaAndTireFromMenu] + myRealTire, pBar, " Шпация между запятой, точкой, многоточием и тире");
                    //myFindChangeUsingGREP("(,|~e)([" + myLineOfSpaces + "]*)(—|–)","$1" + myAllSpacesValues[myCommaAndTireFromMenu] + myRealTire,pBar," Шпация между запятой, многоточием и тире");          
                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    app.findGrepPreferences.findWhat = "(,|\\.|~e)([" + myLineOfSpaces + "]*)(—|–)";
                    app.changeGrepPreferences.noBreak = true;
                    myText.changeGrep();

                    app.findGrepPreferences = NothingEnum.nothing;
                    app.changeGrepPreferences = NothingEnum.nothing;
                    app.findChangeGrepOptions.includeFootnotes = true;
                    app.findGrepPreferences.findWhat = "~e";
                    app.changeGrepPreferences.noBreak = true; // многоточие не отрывать от след. знака
                    myText.changeGrep();

                    //myText.recompose();            
                } // commatireFromMenu == 1
            } // commatireFromMenu != 2
            if (shortwordFromMenu != 2) { // shortwordFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (shortwordFromMenu == 1) myFindChangeUsingGREP(myText, "([\\n" + myLineOfSpaces + "\\[\\(])(\\l\\.)([" + myLineOfSpaces + "]*)(\\l\\.)", "$1" + "$2" + myAllSpacesValues[myShortWordSpaceFromMenu] + "$4", pBar, " Шпация в сокращениях (т.к., т.п., т.д.)");
                if (shortwordFromMenu == 0) myFindChangeUsingGREP(myText, "(\\l\\.)([" + myLineOfSpaces + "]*)(\\l\\.)", "$1" + "$3", pBar, " Удаление шпации в сокращениях (т.к., т.п., т.д.)");
            } // shortwordFromMenu != 2    
            if (initialsFromMenu != 2) { // initialsFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (initialsFromMenu == 1) { // initialsFromMenu == 1   //   +?\\.{0,1}
                    if (asPushkinFromMenu == true) { // asPushkin == true
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\.|\\u\\l\\.)([" + myLineOfSpaces + "]*)(\\u\\.|\\u\\l\\.)([" + myLineOfSpaces + "]*)(\\u\\l)", "$1" + "$2" + myAllSpacesValues[myASPushkinFirstSpaceFromMenu] + "$4" + myAllSpacesValues[myASPushkinSecondSpaceFromMenu] + "$6", pBar, " Шпации в инициалах"); // (А. С. Пушкин   Дж. Дж. Томсон
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\.|\\u\\l\\.|св\\.)([" + myLineOfSpaces + "]*)(\\u\\l)", "$1" + "$2" + myAllSpacesValues[myASPushkinSecondSpaceFromMenu] + "$4", pBar, " Шпации в инициалах"); // (А. Пушкин   Дж. Томсон  св. Августин
                    } // asPushkin == true         
                    if (pushkinASFromMenu == true) { // pushkinAS == true
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\l+)([" + myLineOfSpaces + "]*)(\\u)(\\.)([" + myLineOfSpaces + "]*)(\\u)(\\.)", "$1" + "$2" + myAllSpacesValues[myPushkinASFirstSpaceFromMenu] + "$4" + "$5" + myAllSpacesValues[myPushkinASSecondSpaceFromMenu] + "$7" + "$8", pBar, " Шпации в инициалах");  // Пушкин А. С.  
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\l)([" + myLineOfSpaces + "]*)(\\u)(\\.)", "$1" + "$2" + myAllSpacesValues[myPushkinASFirstSpaceFromMenu] + "$4" + "$5", pBar, " Шпации в инициалах"); // Пушкин А.
                    } // pushkinAS == true    
                } // initialsFromMenu == 1
                if (initialsFromMenu == 0) { // initialsFromMenu == 0    
                    if (asPushkinFromMenu == true) { // asPushkin == true
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\.|\\u\\l\\.)([" + myLineOfSpaces + "]*)(\\u\\.|\\u\\l\\.)([" + myLineOfSpaces + "]*)(\\u\\l)", "$1" + "$2" + "$4" + myAllSpacesValues[myASPushkinSecondSpaceFromMenu] + "$6", pBar, " Удаляем шпации в инициалах"); // (А.С. Пушкин   Дж.Дж. Томсон
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\.|\\u\\l\\.|св\\.)([" + myLineOfSpaces + "]*)(\\u\\l)", "$1" + "$2" + myAllSpacesValues[myASPushkinSecondSpaceFromMenu] + "$4", pBar, " Шпации в инициалах"); // (А. Пушкин   Дж. Томсон  св. Августин
                    } // asPushkin == true
                    if (pushkinASFromMenu == true) { // pushkinAS == true
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\l+)([" + myLineOfSpaces + "]*)(\\u)(\\.)([" + myLineOfSpaces + "]*)(\\u)(\\.)", "$1" + "$2" + myAllSpacesValues[myPushkinASFirstSpaceFromMenu] + "$4" + "$5" + "$7" + "$8", pBar, " Удаляем шпации в инициалах");  // Пушкин А.С.  
                        myFindChangeUsingGREP(myText, "([\\[\\r\\n" + myLineOfSpaces + "\\(\"])(\\u\\l+)([" + myLineOfSpaces + "]*)(\\u)(\\.)", "$1" + "$2" + myAllSpacesValues[myPushkinASFirstSpaceFromMenu] + "$4" + "$5", pBar, " Шпации в инициалах"); // Пушкин А.
                    } // pushkinAS == true                 
                }  // initialsFromMenu == 0
            } // initialsFromMenu != 2
            if (slitnoFromMenu != 2) { // slitnoFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                if (slitnoFromMenu == 1) { // slitnoFromMenu == 1 :: нужна шпация
                    myFindChangeUsingGREP(myText, "(\\d)(" + mySep + "*)(%|‰)", "$1" + myAllSpacesValues[ProcSpaceFromMenu] + "$3", pBar, " Обработка знаков процента и промилле");
                }
                else {  // slitnoFromMenu == 0 :: слитное написание
                    myFindChangeUsingGREP(myText, "(\\d)(" + mySep + "*)(%|‰)", "$1" + "$3", pBar, " Обработка знаков процента и промилле");
                }  // slitnoFromMenu == 1     
            } // slitnoFromMenu != 2

            if (CurrSlitnoFromMenu != 2) { // CurrSlitnoFromMenu != 2    
                myCurrActionNumber++;
                myNextStep(pBar, myCurrActionNumber);
                a = 0;
                if (CurrSlitnoFromMenu == 1) { // slitnoFromMenu == 1 :: нужна шпация
                    myFindChangeUsingGREP(myText, "([" + CurrencySigns + "])(" + mySep + "*)(\\d)", "$1" + myAllSpacesValues[CurrSpaceFromMenu] + "$3", pBar, " Обработка знаков валюты перед числом");
                }
                else {  // CurrSlitnoFromMenu == 0 :: слитное написание
                    myFindChangeUsingGREP(myText, "([" + CurrencySigns + "])(" + mySep + "*)(\\d)", "$1" + "$3", pBar, " Обработка знаков валюты перед числом");
                }  // CurrSlitnoFromMenu == 1     
            } // CurrSlitnoFromMenu != 2
        } // mySpatiumValueFromMenu == 1
        //// 28.03.2015 добавлен grep-запрос обработки №шпация№ заменяется на №№
        myFindChangeUsingGREP(myText, "(№)(" + mySep + ")(№)", "№№", pBar, " № № >> №");
        //// 28.03.2015 добавлены grep-запросы обработки Санкт — Петербург, С-Петербург и С.—Петербург
        myFindChangeUsingGREP(myText, "(Санкт)(" + mySep + "*)([-~_~=~~]+?)(" + mySep + "*)(Петербур)", "$1" + "-" + "$5", pBar, " Санкт-Петербург");
        myFindChangeUsingGREP(myText, "(С)(\\.)*(" + mySep + "*)([-~_~=~~]+?)(" + mySep + "*)(Петербур)", "$1" + ".~~~<" + "$6", pBar, " С.-Петербург");
        if (shortwordFromMenu == 1) myFindChangeUsingGREP(myText, "([к|д]\\.)(" + mySep + "*)(\\l\\.)(" + mySep + "*[-~_~=~~]" + mySep + "*)(\\l\\.)(" + mySep + "*)(н\\.)", "$1" + myAllSpacesValues[myShortWordSpaceFromMenu] + "$3" + "~~~<" + "$5" + myAllSpacesValues[myShortWordSpaceFromMenu] + "$7", pBar, " к.ф.-м.н."); // "~<" -тонкая шпация
        if (shortwordFromMenu == 0) myFindChangeUsingGREP(myText, "([к|д]\\.)(" + mySep + "*)(\\l\\.)(" + mySep + "*[-~_~=~~]" + mySep + "*)(\\l\\.)(" + mySep + "*)(н\\.)", "$1" + "$3" + "~~~<" + "$5" + "$7", pBar, " к.ф.-м.н.");
        myFindChangeUsingGREP(myText, "(чл\\.)(" + mySep + "*[-~_~=~~]" + mySep + "*)(кор)", "$1" + "~~~<" + "$3", pBar, " чл.-корр.");
        if (shortwordFromMenu == 1) myFindChangeUsingGREP(myText, "(\\l\\.)(" + mySep + "*)(\\l\\.)(" + mySep + "*)(\\l\\.)", "$1" + myAllSpacesValues[myShortWordSpaceFromMenu] + "$3" + myAllSpacesValues[myShortWordSpaceFromMenu] + "$5", pBar, " м.н.с., к.т.н.");
        if (shortwordFromMenu == 0) myFindChangeUsingGREP(myText, "(\\l\\.)(" + mySep + "*)(\\l\\.)(" + mySep + "*)(\\l\\.)", "$1" + "$3" + "$5", pBar, " м.н.с., к.т.н.");

        if (nobreakSpaceFromMenu == 1) { // nobreakSpaceFromMenu == 1
            // заменим все неразрывные гибкие пробелы на обычные с атрибутом Nobreak
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = myNonBreakableSpaceVariableWidth;
            var myProblemSpaces = [];
            myProblemSpaces = myText.findGrep();
            //~     if (myProblemSpaces.length > 0) { // myProblemSpaces.length > 0
            //~ // цикл по числу элементов коллекции. Движение снизу вверх
            //~         for (var j=myProblemSpaces.length-1; j >= 0; j--) { // j--	
            //~             myLine = myFoundSamples[j] ;
            app.changeGrepPreferences.changeTo = " ";
            app.changeGrepPreferences.noBreak = true;
            myText.changeGrep();
            //~             myLine.contents = " ";
            //~             myLine.noBreak = true;
            //~             } // j--
            //~         } // myProblemSpaces.length > 0
        }  // nobreakSpaceFromMenu == 1

        if (t_f == "t" && setsFromParaFromMenu == true && !footnoteOnlyProc) { // setsFromParaFromMenu   
            smartNoteProc4(myText);
            smartNoteProc5(myText);
            smartNoteProc6(myText);
            smartNoteProc7(myText);
        } // setsFromParaFromMenu

        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        //////////////////////////////////////////
        if (myPhoneValueFromMenu == 1) { // myPhoneValueFromMenu == 1
            myTelNumberProcessing = true;
            var myInTextSep;
            var mySeparators;
            var mySpaceAndSeparators;
            myFigureSpaceInTel = "\u2007";
            myNearBrasketSpace = myNonbreakingSpaceFixedWidth;
            myGrepSpace = myThinSpace + "|" + mySpace + "|" + myFigureSpaceInTel + "|" + myNearBrasketSpace;
            myDashes = "[" + myDefis + "–—" + myNonbreakingHyphen + "]";
            myDot = "\\.";
            myNearBrasketSpace = myNonbreakingSpaceFixedWidth;
            myAllSeparators = myGrepSpace + "|" + myDashes + "|" + myDot;
            myAllSeparatorsInBraskets = "(" + myAllSeparators + ")";
            myAllGrepSpaceAndSeparatorsInBraskets = "(" + myAllSeparators + "|" + myGrepSpace + ")";
            ///
            myGrepSpaceInBraskets = "(" + myThinSpace + "|" + mySpace + "|" + myFigureSpaceInTel + ")";
            //myCharsAfterTelNumber = "(" + myThinSpace + "|" + "( )|(,)|(;)|(\\. )|(\\.\\r)|(\\.\\n)|(\\n)|(\\r))"; //  отлавливание правой границы телефонного номера
            myCharsAfterTelNumber = "([" + myLineOfSpaces + "]|" + "(,)|(;)|(\\. )|(\\.\\r)|(\\.\\n)|(\\n)|(\\r))"; //  отлавливание правой границы телефонного номера  
            for (var i = 0; i < myText.tables.length; i++) { // i
                for (var j = 0; j < myText.tables[i].cells.length; j++) { // j
                    myText.tables[i].cells[j].insertionPoints[-1].contents = myEnter; // добавим перевод строки после последнего символа в текущей ячейке
                    myText.tables[i].cells[j].insertionPoints[0].contents = mySpace; // добавим пробел перед первым символом в текущей ячейке
                } // j
            } //i
            if (InTextSepIsSpaceFromMenu == 1) {
                mySeparators = myGrepSpaceInBraskets;
                mySpaceAndSeparators = myGrepSpaceInBraskets;
            }
            else if (InTextSepIsDashFromMenu == 1) {
                mySeparators = "(" + myDashes + ")";
                mySpaceAndSeparators = "(" + myGrepSpace + "|" + myDashes + ")";
            }
            else if (InTextSepIsDotFromMenu == 1) {
                mySeparators = "(" + myDot + ")";
                mySpaceAndSeparators = "(" + myGrepSpace + "|" + myDot + ")";
            }
            else {
                alert("Не определен разделитель групп цифр в обрабатываемых телефонных номерах.\nБудут искаться дефисы, минусы, тире.", myProgramTitul);
                mySeparators = "(" + myDashes + ")";
                mySpaceAndSeparators = "(" + myGrepSpace + "|" + myDashes + ")";
            }
            /*7.7.2012:  в записи телефонного номера может быть любой разделитель
                mySeparators =myAllSeparatorsInBraskets;
                mySpaceAndSeparators =myAllGrepSpaceAndSeparatorsInBraskets;
            */
            ///
            var myNmrSep;
            if (SepIsSpaceFromMenu == 1) myNmrSep = myFigureSpaceInTel;
            else if (SepIsDefisFromMenu == 1) myNmrSep = myNonbreakingHyphen;
            else if (SepIsMinusFromMenu == 1) myNmrSep = "–";
            else if (SepIsTireFromMenu == 1) myNmrSep = "—";
            else if (SepIsDotFromMenu == 1) myNmrSep = ".";
            else { alert("Разделитель групп цифр в обработанных телефонных номерах не определен, поэтому в качестве разделителя будет дефис."); myNmrSep = myNonbreakingHyphen; }
            //X XXX XXX-XXXX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + myGrepSpaceInBraskets + "(\\d+)" + myGrepSpaceInBraskets + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNonbreakingSpaceFixedWidth + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + "$8" + "$9", pBar, " Обработка телефонных номеров, формат X XXX XXX-XXXX");
            // X XXX XXX-XX-XX    #  девять grep-масок $1-$9 хватает только на то, чтобы описать номер в таком формате. На отлавливание границы номера -- последовательности myCharsAfterTelNumber масок нет.
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + myGrepSpaceInBraskets + "(\\d+)" + myGrepSpaceInBraskets + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)", "$1" + myNonbreakingSpaceFixedWidth + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + myNmrSep + "$9", pBar, " Обработка телефонных номеров, формат X XXX XXX-XX-XX");
            //X-XXX-XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)", "$1" + myNmrSep + "$3" + myNmrSep + "$5" + myNmrSep + "$7" + myNmrSep + "$9", pBar, " Обработка телефонных номеров, формат X-XXX-XXX-XX-XX");
            ///>>
            //X-XXX-XXX-XXXX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + myNmrSep + "$5" + myNmrSep + "$7" + "$8", pBar, " Обработка телефонных номеров, формат X-XXX-XXX-XXXX");
            ///>>>
            //X (XXX) XXX-XXXX 
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + mySpaceAndSeparators + "(\\(\\d+\\))" + mySpaceAndSeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNonbreakingSpaceFixedWidth + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + "$8", pBar, " Обработка телефонных номеров, формат X (XXX) XXX-XXXX");
            //X (XXX) XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + mySpaceAndSeparators + "(\\(\\d+\\))" + mySpaceAndSeparators + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)", "$1" + myNonbreakingSpaceFixedWidth + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + myNmrSep + "$9", pBar, " Обработка телефонных номеров, формат X (XXX) XXX-XX-XX");
            //X(XXX)XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + "(\\(\\d+\\))" + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNonbreakingSpaceFixedWidth + "$2" + myNonbreakingSpaceFixedWidth + "$3" + myNmrSep + "$5" + myNmrSep + "$7" + "$8", pBar, " Обработка телефонных номеров, формат X(XXX)XXX-XX-XX");
            //X(XXX)XXX-XXXX
            myFindChangeUsingGREP(myText, "(\\+?\\d{1,3})" + "(\\(\\d+\\))" + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNonbreakingSpaceFixedWidth + "$2" + myNonbreakingSpaceFixedWidth + "$3" + myNmrSep + "$5" + "$6", pBar, " Обработка телефонных номеров, формат X(XXX)XXX-XXXX");
            //(X-XXX) XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\(\\+?\\d{1,3})" + mySeparators + "(\\d+\\))" + mySpaceAndSeparators + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)", "$1" + myNmrSep + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + myNmrSep + "$9", pBar, " Обработка телефонных номеров, формат (X-XXX) XXX-XX-XX");
            //(X-XXX) XXX-XXXX
            myFindChangeUsingGREP(myText, "(\\(\\+?\\d{1,3})" + mySeparators + "(\\d+\\))" + mySpaceAndSeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + myNonbreakingSpaceFixedWidth + "$5" + myNmrSep + "$7" + "$8", pBar, " Обработка телефонных номеров, формат (X-XXX) XXX-XXXX");
            //(X-XXX)XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\(\\+?\\d{1,3})" + mySeparators + "(\\d+\\))" + "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + myNonbreakingSpaceFixedWidth + "$4" + myNmrSep + "$6" + myNmrSep + "$8" + "$9", pBar, " Обработка телефонных номеров, формат (X-XXX)XXX-XX-XX");
            // (X-XXX)XXX-XXXX
            myFindChangeUsingGREP(myText, "(\\(\\+?\\d{1,3})" + mySeparators + "(\\d+\\))" + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + myNonbreakingSpaceFixedWidth + "$4" + myNmrSep + "$6" + "$7", pBar, " Обработка телефонных номеров, формат (X-XXX)XXX-XXXX");
            //XXX-XX-XX
            myFindChangeUsingGREP(myText, "(\\d+)" + mySeparators + "(\\d+)" + mySeparators + "(\\d+)" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + myNmrSep + "$5" + "$6", pBar, " Обработка телефонных номеров, формат XXX-XX-XX");
            if (my11DFromMenu == 1) { // my11DFromMenu == 1
                myCharAfterTelNumber(myText, mySpace, myNmrSep);
                myCharAfterTelNumber(myText, ". ", myNmrSep);
                myCharAfterTelNumber(myText, ", ", myNmrSep);
                myCharAfterTelNumber(myText, "; ", myNmrSep);
                myCharAfterTelNumber(myText, myEnter, myNmrSep);
                myCharAfterTelNumber(myText, myShiftEnter, myNmrSep);
            } // my11DFromMenu == 1
            //XXX-XXXX
            //myFindChangeUsingGREP("(\\d{2,3})" + mySeparators + "(\\d{2,4})" + myCharsAfterTelNumber,"$1"+ myNmrSep + "$3" + "$4",pBar," Обработка телефонных номеров, формат XX-XXX / XXX-XX / XXX-XXXX и пр.");
            // 17.11.2014 - установлен более жёсткий критерий, что является телефонным номером
            myFindChangeUsingGREP(myText, "([" + mySep + "|\\.]+?\\d{3})" + mySeparators + "(\\d{4})" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + "$4", pBar, " Обработка телефонных номеров, формат XXX-XXXX");
            if (XX_XX) myFindChangeUsingGREP(myText, "([" + mySep + "|\\.]+?\\d{2})" + mySeparators + "(\\d{2})" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + "$4", pBar, " Обработка телефонных номеров, формат XX-XX");
            if (XXX_XX) myFindChangeUsingGREP(myText, "([" + mySep + "|\\.]+?\\d{3})" + mySeparators + "(\\d{2})" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + "$4", pBar, " Обработка телефонных номеров, формат XXX-XX");
            if (XX_XXX) myFindChangeUsingGREP(myText, "([" + mySep + "|\\.]+?\\d{2})" + mySeparators + "(\\d{3})" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + "$4", pBar, " Обработка телефонных номеров, формат XX-XXX");
            if (XXX_XXX) myFindChangeUsingGREP(myText, "([" + mySep + "|\\.]+?\\d{3})" + mySeparators + "(\\d{3})" + myCharsAfterTelNumber, "$1" + myNmrSep + "$3" + "$4", pBar, " Обработка телефонных номеров, формат XXX-XXX");
            /// 02/08/2014 после обработки телефонных номеров остаются два перевода строки :(
            if (myText.characters[-1].contents == "\r") myText.characters[-1].remove();
            if (myText.characters[-1].contents == "\r") myText.characters[-1].remove();
            ///
        } // myPhoneValueFromMenu == 1
        // все вкладки обработаны
        //~ for (var i = 0; i < myText.tables.length; i++) { // i
        //~ 	for (var j = 0; j < myText.tables[i].cells.length; j++) { // j
        //~         try { while (myText.tables[i].cells[j].characters[-1].contents == "\u000D" || myText.tables[i].cells[j].characters[-1].contents == "\u000A" || myText.tables[i].cells[j].characters[-1].contents == " ") myText.tables[i].cells[j].characters.lastItem().remove(); } catch (e) { }
        //~         try { while (myText.tables[i].cells[j].characters[0].contents == "\u000D" || myText.tables[i].cells[j].characters[0].contents == "\u000A" || myText.tables[i].cells[j].characters[0].contents == " ") myText.tables[i].cells[j].characters.firstItem().remove(); } catch (e) { }  
        //~        // try { while (myText.tables[i].cells[j].characters[-1].contents == "\u000A") myText.tables[i].cells[j].characters.lastItem().remove(); } catch (e) { } 
        //~        // try { while (myText.tables[i].cells[j].characters[0].contents == "\u000A") myText.tables[i].cells[j].characters.firstItem().remove(); } catch (e) { }           
        //~        // try { while (myText.tables[i].cells[j].characters[0].contents == " ") myText.tables[i].cells[j].characters.firstItem().remove();  } catch (e) { }   
        //~        // try { while (myText.tables[i].cells[j].characters[-1].contents == " ") myText.tables[i].cells[j].characters.lastItem().remove(); } catch (e) { }        
        //~       } // j
        //~ } //i
        // удаляем знаки перевода строки в начале и конце текста, оставшиеся после обработки
        //if (myFragment != true || myText.paragraphs.length == 3)  try { myText.characters[-1].remove(); } catch (e) {  } //  myText.paragraphs.length == 3 -- тонкая ошибка: когда выбран один абзац, но не выбрано удаление повторяющихся абзацев, в тексте появляется лишний перевод строки
        //if (myFragment != true)  try { myText.characters[-1].remove(); } catch (e) {  }
        // 12.06.2014   try { if (myFragment == true && repCharFromMenu == false)  myText.characters[-1].remove(); } catch (e) {  }   
        /// >> 13.06.2014 
        try { if (myText.characters[-1].contents == " ") myText.characters[-1].remove(); } catch (e) { }
        //if (myFragment == true) myText.insertionPoints[-1].contents = "\r";
        if (SingleStory == true && PlaceHolderForEnter == "*") try { myText.characters[0].remove(); } catch (e) { }
        //if (PlaceHolderForEnter == "*") try { myText.characters[0].remove(); } catch (e) {  } // при обработке флажка "одна строка - один абзац" служебного символа в начале текста нет, поэтому ничего удалять не надо

        if (myFinishTextQueArray.length > 0) { // myFinishTextQueArray.length > 0
            for (i = 0; i < myFinishTextQueArray.length; i++) { // i < myFinishTextQueArray.length
                try { app.loadFindChangeQuery(myFinishTextQueArray[i], SearchModes.textSearch); } catch (e) { myProblemsWithFinishTextQueryProcessing = true; myMessageAboutQueryProcessingProblems += "F:T: " + myFinishTextQueArray[i] + "\n"; continue; }
                pBar.info(" Выполняется запрос F:T: " + myFinishTextQueArray[i]);
                myText.changeText();
            } // i < myFinishTextQueArray.length
        } // myFinishTextQueArray.length > 0    

        if (myFinishGrepQueArray.length > 0) { // myFinishGrepQueArray.length > 0
            for (i = 0; i < myFinishGrepQueArray.length; i++) { // i < myFinishGrepQueArray.length
                try { app.loadFindChangeQuery(myFinishGrepQueArray[i], SearchModes.grepSearch); } catch (e) { myProblemsWithFinishGrepQueryProcessing = true; myMessageAboutQueryProcessingProblems += "F:G: " + myFinishGrepQueArray[i] + "\n"; continue; }
                pBar.info(" Выполняется запрос F:G: " + myFinishGrepQueArray[i]);
                myText.changeGrep();
            } // i < myFinishGrepQueArray.length
        } // myFinishGrepQueArray.length > 0   

        // 07.03.2019
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "([кК]ак\\l\\l)";
        app.changeGrepPreferences.changeTo = "$1";
        app.changeGrepPreferences.noBreak = true;
        myText.changeGrep();

        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "([кК]ое-\\l)";
        //~     app.findGrepPreferences.findWhat = "([кК]ое)(-)(\\l)";      
        //~     app.changeGrepPreferences.changeTo = "$1$2"+ myDiscretionaryHyphen + "$3";    
        app.changeGrepPreferences.changeTo = "$1";
        app.changeGrepPreferences.noBreak = true;
        myText.changeGrep();

        // 08.03.2019
        if (flexNobreakOnly == true) { // flexNobreakOnly == true
            // заменим все неразрывные фиксированные пробелы на изменяемые неразрывные пробелы
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = myNonbreakingSpaceFixedWidth;
            app.changeGrepPreferences.changeTo = myNonbreakingSpace;
            myText.changeGrep();
        } // flexNobreakOnly == true

        // 12.03.2019    
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "([вВ]о)(й)(\\l)";
        app.changeGrepPreferences.changeTo = "$1$2" + myDiscretionaryHyphen + "$3";
        myText.changeGrep();
        ///
        // 12.03.2019     
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "(руб)(л)";
        app.changeGrepPreferences.changeTo = "$1" + myDiscretionaryHyphen + "$2";
        myText.changeGrep();
        ///
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "(\\d)(-)([хе])(\\s)([вг]\\.)";
        app.changeGrepPreferences.changeTo = "$1" + myNonbreakingHyphen + "$3" + myNonbreakingSpace + "$5";
        myText.changeGrep();
        ///
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "([IVX])(\\s)([-–—])(\\s)([IVX])";
        app.changeGrepPreferences.changeTo = "$1" + myRealDigitSeparator + "$5";
        myText.changeGrep();
        ///
        // 14.03.2019    
        if (theDoubleNames == true) { // DoubleNames
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = "(\\l)(-)(\\u)";
            app.changeGrepPreferences.changeTo = "$1$2" + myDiscretionaryHyphen + "$3";
            myText.changeGrep();
        } // DoubleNames
        if (splitOnHyphen == true) { // splitOnHyphen
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = "(\\l{" + String(word1N) + ",})(-)(\\l{" + String(word2N) + ",})";
            app.changeGrepPreferences.changeTo = "$1$2" + myDiscretionaryHyphen + "$3";
            myText.changeGrep();
        } // splitOnHyphen   
        ///
        var splitExceptionsLength = splitExceptions.length;
        if (splitExceptionsLength > 0) { // splitExceptionsLength > 0
            for (i = 0; i < splitExceptionsLength; i++) { // i++
                var exText = splitExceptions[i];
                app.findGrepPreferences = NothingEnum.nothing;
                app.changeGrepPreferences = NothingEnum.nothing;
                app.findChangeGrepOptions.includeFootnotes = true;
                app.findGrepPreferences.findWhat = "(\\l+)(-)(" + exText + ")";
                app.changeGrepPreferences.changeTo = myDiscretionaryHyphen + "$1$2$3";
                myText.changeGrep();
            } // i++
        } // splitExceptionsLength > 0 
        ///===
        myText.recompose();
        if (ShowProgressbarSingleStory == true) pBar.close();
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
    } // myTxtProcessing
    //////
    function myFindChangeUsingGREP(procText, myFindPattern, mychangePattern, myFunc, myCurrAction) { // myFindChangeUsingGREP
        var my_Text = procText;
        myFunc.info(myCurrAction);
        if (ShowProgressbarSingleStory == true) myFunc.set(myCurrActionNumber);
        /// Ratio&Increment >
        /*
        myParaLength = my_Text.paragraphs.length;
        myRatio = myParaLength / myQuote;
        myProcSteps = Math.round (myRatio);
        if (myProcSteps != myRatio) myProcSteps++;
        myFirstProcessedPara = myParaLength;
        myProcBreak = false;
        */
        var mySaveSpacesInFootnotes = false;
        // mySaveSpacesInFootnotes делается равным true только на время замены шпаций на пробелы, чтобы в сносках она не выполнялась. 
        // Дело в том, что можно назначить автоматически шпацию отбивки между сноской и текстом, но она скриптом до 14.06.2013 заменялась на пробел.
        // Чтобы избежать этой тонкой ошибки, введена такая проверка.
        if (myFindPattern == "[" + myLineOfSpaces + "]") mySaveSpacesInFootnotes = true;
        /*
        for (var j = 0; j < myProcSteps; j++) { // j < myProcSteps
            if (j > 0) { // j > 0 // на текстах, в которых число абзацев меньше величины myQuote (т.е. j = 0), процент выполнения текущей процедуры не выводится.
                myIncrement = (j*100/myProcSteps).toFixed(0);
                myFunc.info (myCurrAction + " ... " + myIncrement + "%" );
                }  // j > 0
            myLastProcessedPara = myFirstProcessedPara - 1;
            myFirstProcessedPara = myLastProcessedPara - myQuote;
            if (myFirstProcessedPara < 0) { myFirstProcessedPara = 0; myProcBreak = true; }
            myProcText = my_Text.paragraphs.itemByRange(myFirstProcessedPara,myLastProcessedPara);
        /// <Ratio&Increment 
        */
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        if (mySaveSpacesInFootnotes == true) app.findChangeGrepOptions.includeFootnotes = false;
        else app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = myFindPattern;
        //app.findGrepPreferences.findWhat = " ";
        app.changeGrepPreferences.changeTo = mychangePattern;
        if (mychangePattern == "$1 —" || mychangePattern == "$1$2 $4" || mychangePattern == "$1 $3 $5" || mychangePattern == "$1 $3~~~<$5 $7" || (myTelNumberProcessing == true && myTelNumBreakFromMenu == 0)) {
            // mychangePattern == "$1 —" -- чтобы исключить случай, что строка порвётся именно по этому пробелу, и тире уйдёт в начало следующей строки.   
            // $1$2 $4 чтобы исключить разрыв сокращения по пробелу. Это возможно на узких колонках.
            // $1 $3 $5 -- то же самое для к. т. н. и.пр. подобных ученых званий
            // $1 $3~~~<$5 $7 к. ф.-т. н. 
            app.changeGrepPreferences.noBreak = true;
        }
        else {
            app.changeGrepPreferences.noBreak = false;
        }
        //app.changeGrepPreferences.horizontalScale = 100;  
        //   myProcText.changeGrep();
        my_Text.changeGrep();
        /// ProcBreak >    
        //  if (myProcBreak == true) break;
        // } // j < myProcSteps
        /// < ProcBreak 
        my_Text.recompose();
    } // myFindChangeUsingGREP 
    //////
    function myFindChangeScaleUsingGREP(procText, myFindPattern, mychangePattern, myRealTire, myFunc, myCurrAction) { // myFindChangeScaleUsingGREP
        var myText = procText;
        myFunc.info(myCurrAction);
        ///
        myParaLength = myText.paragraphs.length;
        myRatio = myParaLength / myQuote;
        myProcSteps = Math.round(myRatio);
        if (myProcSteps != myRatio) myProcSteps++;
        myFirstProcessedPara = myParaLength;
        myProcBreak = false;
        for (var j = 0; j < myProcSteps; j++) { // j < myProcSteps
            if (j > 0) { // j > 0
                myIncrement = (j * 100 / myProcSteps).toFixed(0);
                myFunc.info(myCurrAction + " ... " + myIncrement + "%");
            }  // j > 0
            /// 03/07/2012  Почему-то не работает масштабирование, когда указывается не вся статья, а только её часть. 
            //~     myLastProcessedPara = myFirstProcessedPara - 1;
            //~     myFirstProcessedPara = myLastProcessedPara - myQuote;
            //~     if (myFirstProcessedPara < 0) { myFirstProcessedPara = 0; myProcBreak = true; }
            //~     myProcText = myText.paragraphs.itemByRange(myFirstProcessedPara,myLastProcessedPara);
            myProcBreak = true;
            myProcText = myText;
            ///    
            app.findGrepPreferences = NothingEnum.nothing;
            app.changeGrepPreferences = NothingEnum.nothing;
            app.findChangeGrepOptions.includeFootnotes = true;
            app.findGrepPreferences.findWhat = myFindPattern;
            app.changeGrepPreferences.changeTo = mychangePattern;
            myProcText.changeGrep();
            if (mySpatiumValueFromMenu == 1 && tireAndSpatiumFromMenu == 1 && spationsToSpaceFromMenu == 1 && mySliderValueFromMenu < 100) { // mySliderValueFromMenu <100
                // теперь ищем результаты замены 
                app.findGrepPreferences.findWhat = myAllSpacesValues[1] + myRealTire + myAllSpacesValues[1];
                var myScaledSpaces = myProcText.findGrep();
                var myLine;
                for (i = 0; i < myScaledSpaces.length; i++) { // myScaledSpaces.length
                    myLine = myScaledSpaces[i]; // это объект String
                    // чтобы адресоваться к конкретным символам строки, их надо определить, например, так:
                    try {
                        myLine.characters.item(0).appliedCharacterStyle = myDocument.characterStyles.item("myHorizontalScaleForEmDashSpaceBefore");
                    }
                    catch (e) { };
                    try { myLine.characters.item(2).appliedCharacterStyle = myDocument.characterStyles.item("myHorizontalScaleForEmDashSpaceAfter") } catch (e) { };
                } // myScaledSpaces.length 
            } // mySliderValueFromMenu <100
            if (myProcBreak == true) break;
        } // j < myProcSteps
    } // myFindChangeScaleUsingGREP 
    //////////////////
    function mySetNoBreakRealDigitSeparator(procText, myCharForProc, pBar) { // mySetNoBreakRealDigitSeparator
        var myText = procText;
        app.findGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = myCharForProc;
        myFound = myText.findGrep();
        //~ app.findChangeTextOptions.includeFootnotes = true;
        //~ app.findTextPreferences.findWhat =myCharForProc; // маска поиска
        //~ myFound = myText.findText(); //собрана коллекция искомых элементов в статье
        if (myFound.length != 0) { // !=0
            for (j = 0; j < myFound.length; j++) { // j < myFound.length	
                myLine = myFound[j];
                var myInd = myLine.index;
                myInd++; // если обрабатывается сочетание цифра-минус-цифра, то индекс должен указывать на минус
                myLine.parent.characters[myInd].noBreak = true;
                pBar.info(" Присвоение разделителю цифр атрибута Nobreak" + " ... (текущий символ/общее число символов) " + j + "/" + myFound.length);
            }  // j < myFound.length
        } // !=0
    } // mySetNoBreakRealDigitSeparator
    ///////
    function mySetNoBreakDefis(procText, myCharForProc, pBar) { // mySetNoBreakDefis
        var myText = procText;
        app.findGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = myCharForProc;
        myFound = myText.findGrep();
        if (myFound.length != 0) { // !=0
            for (j = 0; j < myFound.length; j++) { // j < myFound.length	
                myLine = myFound[j];
                var myInd = myLine.index;
                myInd++; // если обрабатывается сочетание цифра-минус-цифра, то индекс должен указывать на минус
                myLine.parent.characters[myInd].noBreak = true;
                pBar.info(" Присвоение дефису атрибута Nobreak" + " ... (текущий символ/общее число символов) " + j + "/" + myFound.length);
            }  // j < myFound.length
        } // !=0
    } // mySetNoBreakDefis
    ///////
    function mySetNoBreakDoubleSlachAndChar(procText, myCharForProc, pBar) { // mySetNoBreakDoubleSlachAndChar
        var myText = procText;
        app.findGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = myCharForProc;
        myFound = myText.findGrep();
        if (myFound.length != 0) { // !=0
            for (j = 0; j < myFound.length; j++) { // j < myFound.length	
                myLine = myFound[j];
                //var myInd = myLine.index;
                //myInd++; // если обрабатывается сочетание цифра-минус-цифра, то индекс должен указывать на минус
                //myLine.parent.characters[myInd].noBreak = true;
                myLine.noBreak = true;
                pBar.info(" Присвоение двум прямым слешам и символу после них атрибута Nobreak" + " ... (текущий символ/общее число символов) " + j + "/" + myFound.length);
            }  // j < myFound.length
        } // !=0
    } // mySetNoBreakDoubleSlachAndChar
    ///////
    function mySetNoBreak(myCharForProc, pBar) { // mySetNoBreakRealDigitSeparator
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findChangeTextOptions.includeFootnotes = true;
        app.findTextPreferences.findWhat = myCharForProc; // маска поиска
        myFound = myText.findText(); //собрана коллекция искомых элементов в статье
        if (myFound.length != 0) { // !=0
            for (j = myFound.length - 1; j >= 0; j--) { // j >= 0	
                myLine = myFound[j];
                var myInd = myLine.index;
                myInd++; // если обрабатывается сочетание цифра-минус-цифра, то индекс должен указывать на минус
                myLine.parent.characters[myInd].noBreak = true;
                pBar.info(" Присвоение разделителю цифр атрибута Nobreak" + " ... (текущий символ/общее число символов) " + j + "/" + myFound.length);
            }  // j >= 0
        } // !=0
    } // mySetNoBreakRealDigitSeparator
    /////////////////////////////////
    //~ function (pBar) { //myAugment
    //~ // Augment -- наращение. Ищем в тексте неправильные наращения, например, 5-ого, 14-ых, и исправляем их: 5-го, 14-х
    //~ var mySearchedTwoCharacters = '(\\d-ье[,.;:!?"+mySep+"]|\\d-ое[,.;:!?"+mySep+"]|\\d-ая[,.;:!?"+mySep+"]|\\d-ый[,.;:!?"+mySep+"]|\\d-ой[,.;:!?"+mySep+"]|\\d-ий[,.;:!?"+mySep+"]|\\d-ым[,.;:!?"+mySep+"]|\\d-им[,.;:!?"+mySep+"]|\\d-ом[,.;:!?"+mySep+"]|\\d-ем[,.;:!?"+mySep+"]|\\d-ых[,.;:!?"+mySep+"]|\\d-их[,.;:!?"+mySep+"]|\\d-ые[,.;:!?"+mySep+"]|\\d-ьи[,.;:!?"+mySep+"]|\\d-ех[,.;:!?"+mySep+"]|\\d-ёх[,.;:!?"+mySep+"])';
    //~ var mySearchedThreeCharacters = '(\\d-ого[,.;:!?"+mySep+"]|\\d-его[,.;:!?"+mySep+"]|\\d-ому[,.;:!?"+mySep+"]|\\d-ему[,.;:!?"+mySep+"]|\\d-ыми[,.;:!?"+mySep+"]|\\d-ими[,.;:!?"+mySep+"])';
    //~ app.findGrepPreferences = NothingEnum.nothing;
    //~ app.findGrepPreferences.findWhat = mySearchedTwoCharacters;				
    //~ myFoundSamples = myText.findGrep();
    //~ if (myFoundSamples.length != 0) { // 1
    //~ // цикл по числу элементов коллекции. Движение снизу вверх
    //~     for (j=myFoundSamples.length-1; j >= 0; j--) {	
    //~ 		myLine = myFoundSamples[j] ;
    //~ 		myLine.characters.itemByRange(2,2).remove();	// удаляем букву после дефиса
    //~          myLine.characters[1].contents = myNonbreakingHyphen;
    //~          var tt = myFoundSamples.length - j;
    //~          pBar.info (" Порядок в двухбуквенном наращении чисел (5-ый > 5-й и пр.)... " + tt + " / " + myFoundSamples.length); 
    //~         }
    //~     } // 1
    //~ app.findGrepPreferences = NothingEnum.nothing;
    //~ app.findGrepPreferences.findWhat = mySearchedThreeCharacters;				
    //~ myFoundSamples = myText.findGrep();
    //~ if (myFoundSamples.length != 0) { // 2
    //~ // цикл по числу элементов коллекции. Движение снизу вверх
    //~     for (j=myFoundSamples.length-1; j >= 0; j--) {	
    //~ 		myLine = myFoundSamples[j] ;
    //~ 		myLine.characters.itemByRange(2,2).remove();	// удаляем букву после дефиса   
    //~          myLine.characters[1].contents = myNonbreakingHyphen;
    //~          var tt = myFoundSamples.length - j;
    //~          pBar.info (" Порядок в трёхбуквенном наращении чисел (4-ыми > 4-ми и пр.)... " + tt + " / " + myFoundSamples.length); 
    //~         }
    //~     } // 2
    //~ } //myAugment
    //////////////
    function rightCharScale(procText) { // rightCharScale
        var myText = procText;
        try {
            myText.characters.itemByRange(0, -1).horizontalScale = 100;
            myText.characters.itemByRange(0, -1).verticalScale = 100;
        }
        catch (e) { }
    } // rightCharScale    
    /////////////
    function myRemoveHyperLinks(procText) { // myRemoveHyperLinks
        var myText = procText;
        var myRez = 0;
        // статей в документе может быть несколько, поэтому узнаем индекс обрабатываемой, myText
        var myStoryIndex = -1;
        for (var jj = 0; jj < myDocument.stories.length; jj++) { // myDocument.stories.length
            if (myDocument.stories[jj] == myText) { myStoryIndex = jj; break; }
        } // myDocument.stories.length
        if (myStoryIndex == -1) { // myStoryIndex == -1
            alert("Не удалось определить индекс статьи. Удаление гиперссылок прекращено. [1]", myProgramTitul);
            return;
        } // myStoryIndex == -1
        if (myDocument.hyperlinks.length > 0) { // if
            var myHypStoryIndex = -1;
            var myHypStory;
            var myHypLink;
            var myDocHypLength = myDocument.hyperlinks.length;
            for (var j = myDocHypLength - 1; j >= 0; j--) { // for   
                myHypLink = myDocument.hyperlinks[j];
                try { myHypStory = myHypLink.source.sourceText.parentStory; } catch (e) { continue; }
                for (var jj = 0; jj < myDocument.stories.length; jj++) { // myDocument.stories.length
                    if (myDocument.stories[jj] == myHypStory) { myHypStoryIndex = jj; break; }
                } // myDocument.stories.length
                if (myHypStoryIndex == -1) { // myHypStoryIndex == -1
                    alert("Не удалось определить индекс статьи. Удаление гиперссылок прекращено. [2]", myProgramTitul);
                    return;
                } // myHypStoryIndex == -1
                if (myStoryIndex != myHypStoryIndex) continue; // найденная гиперссылка не принадлежит этой статье
                // if (myHypLink.source.sourceText.characters[0].index < myStartOfFragment || myHypLink.source.sourceText.characters[0].index > myEndOfFragment) continue; // найденная гиперссылка лежит за пределами выделенного диапазона
                myDocument.hyperlinks[j].remove();
                myRez++;
            } // for
        }  // if
        return myRez;
    } //myRemoveHyperLinks
    //////////////////////
    function myBoldItalicAndIndexSelection(procText, pBarInfo) {  // myBoldItalicAndIndexSelection
        var myText = procText;
        // выделение цветом текста в нижном и верхнем регистре (каждое начертание будет иметь свой символьный стиль)
        // Заменяем верхний индекс форматирования символов на символьный стиль "Superscript" 
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.position = Position.SUPERSCRIPT; // маска поиска
        app.findTextPreferences.findWhat = ".";
        myFound = myText.findGrep(); //собрана коллекция искомых элементов в статье.
        var myFoundLength = myFound.length;
        if (myFound.length != 0) { //L5
            for (j = myFound.length - 1; j >= 0; j--) { // N5
                if (myFound[j].contents == SpecialCharacters.FOOTNOTE_SYMBOL) continue;
                myLine = myFound[j];
                for (k = myLine.length - 1; k >= 0; k--) { // k
                    myCharInLine = myLine.characters[k];
                    //if (myCharInLine.appliedCharacterStyle.name == "[None]") myCharInLine.appliedCharacterStyle = myDocument.characterStyles.item("mySupChars");
                    if (myCharInLine.appliedCharacterStyle.name == myDocument.characterStyles[0].name) {
                        if (myCharInLine.contents == SpecialCharacters.EM_DASH || myCharInLine.contents == "-") myCharInLine.contents = "–"; // в индексах для указания отрицательного числа тире и дефис не приемлемы, только минус
                        myCharInLine.appliedCharacterStyle = myDocument.characterStyles.item("mySupChars");
                    }
                } // k    
                if (myLine.characters[0].contents != " ") { // myLine.characters[0].contents != " "
                    firstCharIndex = myLine.characters[0].index;
                    firstCharIndex--;
                    if (spaceForSupChar == true) { // spaceForSupChar == true             
                        if (myText.characters[firstCharIndex].contents != " ") { // != " "
                            //HairSpace = "\u200A";
                            if (isNaN(myText.characters[firstCharIndex].contents)) { // isNaN
                                myLine.insertionPoints[0].contents = "\u200A";
                                //myLine.insertionPoints[0].position = Position.SUPERSCRIPT;
                            } // isNaN
                        } // != " " 
                        else { // !spaceForSupChar
                            myText.characters[firstCharIndex].contents = "\u200A";
                            myText.characters[firstCharIndex].appliedCharacterStyle = myDocument.characterStyles.item("mySupChars");
                            myText.characters[firstCharIndex].position = Position.NORMAL;
                        }  // !spaceForSupChar
                    } // spaceForSupChar == true
                    else { ///= else
                        if (myText.characters[firstCharIndex].contents == " ") myText.characters[firstCharIndex].remove();
                    } ///= else
                } // myLine.characters[0].contents != " "
                else if (spaceForSupChar == false) myLine.characters[0].remove();
                pBarInfo(myBoldItalicIndexInfo + " | " + "Sup: " + String(myFoundLength - j) + "/" + myFoundLength);
            } //N5
        } //L5
        // Заменяем нижний индекс форматирования символов на символьный стиль "Subrscript" 
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.position = Position.SUBSCRIPT; // маска поиска
        myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
        var myFoundLength = myFound.length;
        if (myFound.length != 0) { //L5
            for (j = myFound.length - 1; j >= 0; j--) { // N5	
                myLine = myFound[j];
                for (k = myLine.length - 1; k >= 0; k--) { // k
                    myCharInLine = myLine.characters[k];
                    if (myCharInLine.appliedCharacterStyle.name == myDocument.characterStyles[0].name) myCharInLine.appliedCharacterStyle = myDocument.characterStyles.item("mySubChars");
                } // k
                pBarInfo(myBoldItalicIndexInfo + " | " + "Sub: " + String(myFoundLength - j) + "/" + myFoundLength);
            } //N5
        } //L5
        //~ //
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.fontStyle = "Bold"; // маска поиска
        myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
        var myFoundLength = myFound.length;
        if (myFound.length != 0) { //L5            #     if (myFound[j].characters[-1].contents == '\r' && myFound[j].characters[0].index == myFound[j].characters[0].paragraphs[0].characters[0].index)
            pBarInfo(myBoldItalicIndexInfo + " | " + "Bold, всего " + myFoundLength);
            showSelectionByColor("myBoldChars");
        } //L5
        // 
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.fontStyle = "Italic"; // маска поиска
        myFound = myText.findText(); //собрана коллекция искомых элементов в статье
        var myFoundLength = myFound.length;
        if (myFound.length != 0) { //L5
            pBarInfo(myBoldItalicIndexInfo + " | " + "Italic, всего " + myFoundLength);
            showSelectionByColor("myItalicChars");
        } //L5
        // 
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.fontStyle = "Bold Italic"; // маска поиска
        myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
        var myFoundLength = myFound.length;
        if (myFound.length != 0) { //L5
            pBarInfo(myBoldItalicIndexInfo + " | " + "Bold Italic, всего " + myFoundLength);
            showSelectionByColor("myBoldItalicChars");
        } //L5
        //underlineAndCapslock(); 
    } // myBoldItalicAndIndexSelection
    ///
    function underlineAndCapslock(procText) { // underlineAndCapslock
        var myText = procText;
        myText.recompose();
        if (useUnderlineFromMenu == 1) { //useUnderline
            app.findChangeGrepOptions = NothingEnum.NOTHING;
            app.findGrepPreferences = NothingEnum.NOTHING;
            app.changeGrepPreferences = NothingEnum.NOTHING;
            app.findGrepPreferences.findWhat = ".";
            app.findGrepPreferences.underline = true;
            myFound = myText.findGrep();
            var myFoundLength = myFound.length;
            var chStyleName;
            for (var ii = 0; ii < myFoundLength; ii++) { // ii++
                chStyleName = myFound[ii].appliedCharacterStyle.name;
                if (chStyleName.match(/Underline/) != null) continue;
                if (chStyleName[0] == "[") chStyleName = "Underline"; // имя [Без стиля] или [None] в имя нового стиля не включается
                else chStyleName += "+Underline";
                //~         try{ myChStName = myDocument.characterStyles.item(chStyleName).name }  
                //~         catch (e) { 
                //~             myDocument.characterStyles.add ({name:chStyleName, fillColor: "myInfoColor" });
                //~             }        

                addDocumentCollectionElement("characterStyles", { name: chStyleName, fillColor: "myInfoColor", underline: true });
                if (chStyleName.match(/BoldItalic/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Bold Italic";
                else if (chStyleName.match(/Bold/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Bold";
                else if (chStyleName.match(/Italic/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Italic";
                //else  if (chStyleName.match (/Special/) == null) myDocument.characterStyles.item(chStyleName).fontStyle = "Regular";        
                myFound[ii].appliedCharacterStyle = myDocument.characterStyles.item(chStyleName);
            } // ii++
        } // useUnderline
        if (useCapslockFromMenu == 1) { //useCapslock
            app.findChangeGrepOptions = NothingEnum.NOTHING;
            app.findGrepPreferences = NothingEnum.NOTHING;
            app.changeGrepPreferences = NothingEnum.NOTHING;
            app.findGrepPreferences.findWhat = ".";
            app.findGrepPreferences.capitalization = Capitalization.ALL_CAPS;
            myFound = myText.findGrep();
            var myFoundLength = myFound.length;
            var chStyleName;
            for (var ii = 0; ii < myFoundLength; ii++) { // ii++
                chStyleName = myFound[ii].appliedCharacterStyle.name;
                if (chStyleName.match(/Capslock/) != null) continue;
                if (chStyleName[0] == "[") chStyleName = "Capslock"; // имя [Без стиля] или [None] в имя нового стиля не включается
                else chStyleName += "+Capslock";
                addDocumentCollectionElement("characterStyles", { name: chStyleName, fillColor: "myInfoColor", capitalization: Capitalization.ALL_CAPS });
                if (chStyleName.match(/Underline/) != null) myDocument.characterStyles.item(chStyleName).underline = true;
                if (chStyleName.match(/BoldItalic/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Bold Italic";
                else if (chStyleName.match(/Bold/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Bold";
                else if (chStyleName.match(/Italic/) != null) myDocument.characterStyles.item(chStyleName).fontStyle = "Italic";
                //else  if (chStyleName.match (/Special/) == null) myDocument.characterStyles.item(chStyleName).fontStyle = "Regular";   
                myFound[ii].appliedCharacterStyle = myDocument.characterStyles.item(chStyleName);
            } // ii++
        } // useCapslock
    } // underlineAndCapslock
    ///////////////
    function myGrekChar(procText) { // myGrekChar
        var myText = procText;
        // содержимое строки mySpecialChar -- это необязательно только символы из гарнитуры Symbol. 
        //mySearchSymbolChars(myUsedGreckFont); //  поэтому сперва ищутся эти знаки  в текущей гарнитуре ... >>>
        var myFSLength;
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = mySpecialChar;
        try {
            myFoundSamples = myText.findGrep();
            myFSLength = myFoundSamples.length;
        }
        catch (e) { myFSLength = 0; }
        if (myFSLength != 0) { // myFoundSamples.length != 0
            // цикл по числу элементов коллекции. Движение снизу вверх
            for (var j = myFoundSamples.length - 1; j >= 0; j--) { // j=myFoundSamples.length-1	
                var myLine = myFoundSamples[j];
                if (myLine.characters[0].appliedCharacterStyle.name == "mySupChars") { // mySupChars
                    myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySupSpecialChars");
                    continue;
                } // mySupChars
                if (myLine.characters[0].appliedCharacterStyle.name == "mySubChars") { // mySubChars
                    myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySubSpecialChars");
                    continue;
                } // mySubChars
                //if (myLine.appliedCharacterStyle.name == myDocument.characterStyles[0].name || myLine.appliedCharacterStyle.name == "myBoldChars" || myLine.appliedCharacterStyle.name == "myBoldItalicChars" || myLine.appliedCharacterStyle.name == "myItalicChars") myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySpecialChars");
                myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySpecialChars");
            } // j=myFoundSamples.length-1
        } // myFoundSamples.length != 0 
        mySearchSymbolChars(myText, myUsedGreckFont); // >>>>>... затем ищутся все символы той гарнитуры, которой отображаются греческие буквы в текущей вёрстке
        //underlineAndCapslock(); 
    } // myGrekChar
    ///////////////
    function myNumberOfActionsAddition(myPara) { // myNumberOfActionsAddition
        if (myPara == true) myNumberOfActions++;
    } // myNumberOfActionsAddition
    ////////////
    // SingleLevelQuotesForDoTextOK.jsx
    function myAllQuoteProcessing(procText, pBar) { // myAllQuoteProcessing
        var myText = procText;
        var myLanguage;
        try { myLanguage = app.languagesWithVendors[myLanguageListFromMenu]; }
        catch (e) { }
        if (myLanguage.name[0] == '[' && myFastUsage == false) { // в любом языке информация, что язык не определен, заключена в квадратные скобки.
            // && myFastUsage == false -- это сообщение выводится только при обработке отдельных статей
            alert("Не определен язык текста.\nПроцедура упорядочения кавычек отменена.", myProgramTitul);
            return;
        }
        app.documents[0].textPreferences.typographersQuotes = true; // установка типографских кавычек для нового текста
        ///////////////
        // абзацы статьи...
        //myProcBreak = false;
        for (var i = 0; i < myText.paragraphs.length; i++) { // i
            pBar.info(" Обработка кавычек" + " ... (текущий абзац/общее число абзацев) " + i + "/" + myText.paragraphs.length);
            myProcessingOfCurrentParagraph(myText.paragraphs[i], myLanguage);
            //~      if (myProcBreak == true) break;
            //~    }  // j < myProcSteps
        } // i
        // сноски...
        for (var i = 0; i < myText.footnotes.length; i++) { // i
            for (var j = 0; j < myText.footnotes[i].paragraphs.length; j++) { // j
                myProcessingOfCurrentParagraph(myText.footnotes[i].paragraphs[j], myLanguage, myText);
            } // j
        } // i
        // таблицы в основном тексте...
        for (var i = 0; i < myText.tables.length; i++) { // i
            for (var j = 0; j < myText.tables[i].cells.length; j++) { // j
                try { myLC = myText.tables[i].cells[j].characters[-1]; } catch (e) { }
                try { myFC = myText.tables[i].cells[j].characters[0]; } catch (e) { }
                app.findGrepPreferences = NothingEnum.nothing;
                app.findGrepPreferences.findWhat = '(„|“|«|»|”|‚|‘|’|\'|\")';
                quoteIsFound = true;
                try { myFoundSamples = myLC.findGrep(); } catch (e) { quoteIsFound = false }
                if (quoteIsFound == true && myFoundSamples.length != 0) myText.tables[i].cells[j].insertionPoints[-1].contents = mySpace; // добавим пробел после кавычки, являющейся последним символом в текущей ячейке
                quoteIsFound = true;
                try { myFoundSamples = myFC.findGrep(); } catch (e) { quoteIsFound = false }
                if (quoteIsFound == true && myFoundSamples.length != 0) myText.tables[i].cells[j].insertionPoints[0].contents = mySpace; // добавим пробел перед кавычкой, являющейся первым символом в текущей ячейке
                for (var k = 0; k < myText.tables[i].cells[j].paragraphs.length; k++) { // k
                    myProcessingOfCurrentParagraph(myText.tables[i].cells[j].paragraphs[k], myLanguage, myText);
                } // k
                try { myLC = myText.tables[i].cells[j].characters[-1].contents; } catch (e) { }
                try { myFC = myText.tables[i].cells[j].characters[0].contents; } catch (e) { }
                if (myLC == mySpace) try { myText.tables[i].cells[j].characters.lastItem().remove(); } catch (e) { } // try catch для исключения попытки удалить символ в пустой ячейке
                if (myFC == mySpace) try { myText.tables[i].cells[j].characters.firstItem().remove(); } catch (e) { }
            } // j
        } //i
        // таблицы в привязанных текстовых фреймах или группах...
        myAllPageItemsProcessing(myText, myLanguage);
        return;
    } // myAllQuoteProcessing
    ///
    function myProcessingOfCurrentParagraph(myPara, myLanguage, myPartOfText) { // myProcessingOfCurrentParagraph
        // если в обычной функции можно так определить переменную цикла (пусть она называется q):   for (q = 0; q < ...; q++)
        // то в рекурсивной функции переменная цакла обязательно должна предваряться инструкцией var:   for (var q = 0; q < ...; q++)
        // это гарантирует, что при при каждом рекурсивном вызове будет создаваться свой экземпляр переменной цикла.
        //
        myQuotesProc(myPara, myLanguage, myPartOfText);
        myAllPageItemsProcessing(myPara, myLanguage, myPartOfText);
        for (var pp = 0; pp < myPara.tables.length; pp++) { // pp
            var myTable = myPara.tables[pp]; // таблица в этом абзаце
            for (var jj = 0; jj < myTable.cells.length; jj++) { // jj
                var myCellInTable = myTable.cells[jj]; // ячейка в этой таблице
                for (var kk = 0; kk < myCellInTable.paragraphs.length; kk++)  myProcessingOfCurrentParagraph(myCellInTable.paragraphs[kk], myLanguage); // рекурсивный вызов функции
            } // jj
        } // pp
    } // myProcessingOfCurrentParagraph
    ////
    function myProcessingOfTextFrame(myTextFrame, myLanguage) { // myProcessingOfTextFrame
        for (var i = 0; i < myTextFrame.tables.length; i++) { // i
            for (var j = 0; j < myTextFrame.tables[i].cells.length; j++) { // j
                for (var k = 0; k < myTextFrame.tables[i].cells[j].paragraphs.length; k++) myProcessingOfCurrentParagraph(myTextFrame.tables[i].cells[j].paragraphs[k], myLanguage);
            } // j
        } // i
        for (var ii = 0; ii < myTextFrame.paragraphs.length; ii++) { // i i
            myProcessingOfCurrentParagraph(myTextFrame.paragraphs[ii], myLanguage);
        } // i i	
    } // myProcessingOfTextFrame
    ///
    function myQuotesProc(myPt, myLanguage, myPartOfText) { // myQuotesProc
        try { myPt.appliedLanguage = myLanguage; }
        catch (e) { };
        //if (myPt.length > 2) myQuoteChars(myPt);
        myQuoteChars(myPt, myPartOfText);
    } // myQuotesProc
    ////
    function myAllPageItemsProcessing(myAPI, myLanguage, myPartOfText) { // myAllPageItemsProcessing
        for (var t = 0; t < myAPI.allPageItems.length; t++) { // t
            myInform = myAPI.allPageItems[0];
            if (myAPI.allPageItems[t].constructor.name == "TextFrame") { // "TextFrame"
                myProcessingOfTextFrame(myAPI.allPageItems[t], myLanguage);
            } // "TextFrame"
            if (myAPI.allPageItems[t].constructor.name == "Group") { // "Group"
                for (var p = 0; p < myAPI.allPageItems[t].textFrames.length; p++) { // p
                    myProcessingOfTextFrame(myAPI.allPageItems[t].textFrames[p], myLanguage);
                } // p
            } // "Group"
        } // t
    } // myAllPageItemsProcessing
    /////
    function myQuoteChars(myAbzatz, myPartOfText) { //myQuoteChars
        var myLetters1 = '(„|“|«|»|”|\")';
        var myLetters2 = '(‚|‘|’|\')';
        var myPrevChar, myNextChar, myLineParent;
        var myP, myN;
        app.findGrepPreferences = NothingEnum.nothing;
        //app.findChangeGrepOptions.includeFootnotes = false;
        app.findGrepPreferences.findWhat = myLetters1;
        myFoundSamples = myAbzatz.findGrep();
        if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
            // цикл по числу элементов коллекции. Движение снизу вверх
            for (var j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                var myLine = myFoundSamples[j];
                myLineParent = myLine.parent;
                myLine.characters[0].contents = "\"";
            } // j >= 0; j--
        } // myFoundSamples.length != 0
        ///
        app.findGrepPreferences = NothingEnum.nothing;
        app.findGrepPreferences.findWhat = myLetters2;
        myFoundSamples = myAbzatz.findGrep();
        if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
            // цикл по числу элементов коллекции. Движение снизу вверх
            for (var j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0; j--	
                var myLine = myFoundSamples[j];
                myLineParent = myLine.parent;
                myLine.characters[0].contents = "\'";
            } // j >= 0; j--
        } // myFoundSamples.length != 0
    } //myQuoteChars
    ///
    function FootnoteSignMustBe(procText, Info) { //FootnoteSignMustBe  
        var myText = procText;
        var myTmpInfo;
        try {
            myDocument.characterStyles.item("myFootnotes").name;
        }
        catch (myError) {
            myDocument.characterStyles.add({ name: "myFootnotes" });
        }
        myDocument.characterStyles.item("myFootnotes").position = Position.SUPERSCRIPT;

        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findChangeTextOptions.properties = { includeFootnotes: true };
        app.findTextPreferences.findWhat = '^F';
        myFoundSamples = myText.findText();
        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            myTmpInfo = Info;
            myFoundSamples[i].appliedCharacterStyle = myDocument.characterStyles.item("myFootnotes");
            if (myFoundSamples[i].parent.constructor.name == "Footnote") continue;
            var mySt = myFoundSamples[i].parentStory;
            var myFootnoteChar = mySt.characters.item(myFoundSamples[i].index);

            var myPrevChar = mySt.characters.item(myFootnoteChar.index - 1);
            var myPrevCharContents = myPrevChar.contents;

            var myNextChar = mySt.characters.item(myFootnoteChar.index + 1);
            try { var myNextCharContents = myNextChar.contents; } catch (e) { return } // это на случай, если сноска является последним символом обрабатываемого текста.
            if (myPrevCharContents == ".") { try { var mayBeUnit = myPrevChar.words[0].contents.split(".")[0] + "."; } catch (e) { return } }
            else { /// else
                try { /// try 
                    var mayBeUnit = "";
                    var subWordLength = myFoundSamples[i].index - myPrevChar.words[0].index;
                    for (var ii = 0; ii < subWordLength; ii++) { /// ii++
                        mayBeUnit += myPrevChar.words[0].characters[ii].contents;
                    } /// ii++
                    mayBeUnit += ".";
                } /// try
                catch (e) { return; }
            } /// else
            if (myFindUnitInArray(mayBeUnit, UnitsAndFootnotes) == true) myTmpInfo = "AfterPoint"; // отменяем правило оформления сносок в русском тексте для случая, когда сноска идёт за словом-сокращением.
            if (myTmpInfo == "BeforePoint") { if (myPrevCharContents == "." || myPrevCharContents == ",") myPrevChar.move(LocationOptions.after, mySt.characters.item(myFoundSamples[i].insertionPoints[0].index)); }
            else  /* myTmpInfo == "AfterPoint"  */ { if (myNextCharContents == "." || myNextCharContents == ",") myNextChar.move(LocationOptions.before, mySt.characters.item(myFoundSamples[i].insertionPoints[0].index)); }
        } // myFoundSamples.length - 1

        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findChangeTextOptions.properties = { includeFootnotes: true };
        app.findTextPreferences.findWhat = '^U';
        myFoundSamples = myText.findText();
        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            myTmpInfo = Info;
            myFoundSamples[i].appliedCharacterStyle = myDocument.characterStyles.item("myFootnotes");
            if (myFoundSamples[i].parent.constructor.name == "Footnote") continue;
            var mySt = myFoundSamples[i].parentStory;
            var myFootnoteChar = mySt.characters.item(myFoundSamples[i].index);

            var myPrevChar = mySt.characters.item(myFootnoteChar.index - 1);
            var myPrevCharContents = myPrevChar.contents;

            var myNextChar = mySt.characters.item(myFootnoteChar.index + 1);
            try { var myNextCharContents = myNextChar.contents; } catch (e) { return } // это на случай, если сноска является последним символом обрабатываемого текста.
            if (myPrevCharContents == ".") { try { var mayBeUnit = myPrevChar.words[0].contents.split(".")[0] + "."; } catch (e) { return } }
            else { /// else
                try { /// try 
                    var mayBeUnit = "";
                    var subWordLength = myFoundSamples[i].index - myPrevChar.words[0].index;
                    for (var ii = 0; ii < subWordLength; ii++) { /// ii++
                        mayBeUnit += myPrevChar.words[0].characters[ii].contents;
                    } /// ii++
                    mayBeUnit += ".";
                } /// try
                catch (e) { return; }
            } /// else
            if (myFindUnitInArray(mayBeUnit, UnitsAndFootnotes) == true) myTmpInfo = "AfterPoint"; // отменяем правило оформления сносок в русском тексте для случая, когда сноска идёт за словом-сокращением.
            if (myTmpInfo == "BeforePoint") { if (myPrevCharContents == "." || myPrevCharContents == ",") myPrevChar.move(LocationOptions.after, mySt.characters.item(myFoundSamples[i].insertionPoints[0].index)); }
            else  /* myTmpInfo == "AfterPoint"  */ { if (myNextCharContents == "." || myNextCharContents == ",") myNextChar.move(LocationOptions.before, mySt.characters.item(myFoundSamples[i].insertionPoints[0].index)); }
        } // myFoundSamples.length - 1
    } // FootnoteSignMustBe
    ////
    function myFindUnitInArray(word, TheArray) { // myFindUnitInArray
        if (word == null) return false;
        ValueFound = false;
        myArr = [];
        while (myArr.length > 0) myArr.shift();
        myArr = TheArray.split("|");
        for (var i = 0; i < myArr.length; i++) { // i++
            if (myArr[i] != word) continue;
            ValueFound = true;
            break;
        } // i++
        return ValueFound;
    } // myFindUnitInArray
    ///
    function myRemoveSpacesBeforeFootnoteSign(procText) { // myRemoveSpacesBeforeFootnoteSign
        var myText = procText;
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = ' ^F'; // ищем пробел и знак сноски
        myFoundSamples = myText.findText();
        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            var myFound = myFoundSamples[i];
            myFound.characters.firstItem().remove(); // пробел удаляем
        } // myFoundSamples.length - 1

        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = ' ^U'; // ищем пробел и знак сноски
        myFoundSamples = myText.findText();
        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            var myFound = myFoundSamples[i];
            myFound.characters.firstItem().remove(); // пробел удаляем
        } // myFoundSamples.length - 1
    } // myRemoveSpacesBeforeFootnoteSign
    ////
    function myAddSpacesBeforeFootnoteSign(procText) { // myAddSpacesBeforeFootnoteSign
        var myText = procText;
        if (footnoteOnlyProc) return; // когда выделена обычная сноска или курсор в блоке концевых сносок, волосяные шпации перед сносками не ставим
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = '^?^F'; // ищем знак сноски и символ перед ним
        myFoundSamples = myText.findText();

        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            var myFound = myFoundSamples[i];
            var myFrstChar = myFound.characters[0].contents;
            if (myFrstChar != "." && myFrstChar != ",")
                // вставляем шпацию перед знаком сноски
                myFound.insertionPoints[-2].contents = HairSpace;
        } // myFoundSamples.length - 1

        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = '^?^U'; // ищем знак сноски и символ перед ним
        myFoundSamples = myText.findText();

        for (i = myFoundSamples.length - 1; i >= 0; i--) { // myFoundSamples.length - 1
            var myFound = myFoundSamples[i];
            var myFrstChar = myFound.characters[0].contents;
            if (myFrstChar != "." && myFrstChar != ",")
                // вставляем шпацию перед знаком сноски
                myFound.insertionPoints[-2].contents = HairSpace;
        } // myFoundSamples.length - 1
    } // myAddSpacesBeforeFootnoteSign
    ////////////////////////
    function myNextStep(myFunc, myCurrActionNumber) { // 
        //myCurrActionNumber++;
        if (ShowProgressbarSingleStory == false) return; // для случая проверки нескольких статей за раз постатейный прогрессбар не работает
        myFunc.set(myCurrActionNumber);
    } // myNextStep
    ///////
    //~ function myFile(myFileName) {
    //~ var myScriptFile = myGetScriptPath();
    //~ var myScriptFolder = decodeURI(myScriptFile.path);
    //~ var myFilePath = decodeURI(myScriptFolder + "/" +myFileName);
    //~ return myFilePath;
    //~ } //myFile
    //~ //
    //~ function myGetScriptPath() {
    //~ 	try{
    //~ 		return app.activeScript;
    //~ 	}
    //~ 	catch(myError){
    //~ 		return File(myError.fileName);
    //~ 	}
    //~ } //myGetScriptPath()
    //////
    function mySetDefaultValues() { // mySetDefaultValues
        myClean_value = myClean_value_start;
        c_options_enabled = c_options_enabled_start;
        repChar_value = repChar_value_start;
        tabs2spaces_value = tabs2spaces_value_start;
        startTabs_value = startTabs_value_start;
        hyphens_value = hyphens_value_start;
        bull2text_value = bull2text_value_start;
        charStyles_value = charStyles_value_start;
        useUnderline_value = useUnderline_value_start;
        useCapslock_value = useCapslock_value_start;
        noParagraphs_value = noParagraphs_value_start;
        digAndChar_value = digAndChar_value_start;
        oneStyle_value = oneStyle_value_start;
        setLang_value = setLang_value_start;
        myTypographica_value = myTypographica_value_start;
        t_options_enabled = t_options_enabled_start;////----
        hyplinks_value = hyplinks_value_start;
        scale100_value = scale100_value_start;
        fixOneLetter_value = fixOneLetter_value_start;
        fixTwoLetter_value = fixTwoLetter_value_start;
        fixDigitAndWord_value = fixDigitAndWord_value_start;
        WordAndLetterSpace_value = WordAndLetterSpace_value_start;
        nobreakSpace_value = nobreakSpace_value_start;
        commonTire_value = commonTire_value_start;
        minus_value = minus_value_start;
        tire_value = tire_value_start;
        defis_value = defis_value_start;
        myDPdefis_value = myDPdefis_value_start;
        myDPminus_value = myDPminus_value_start;
        myDPtire_value = myDPtire_value_start;
        defisN_value = defisN_value_start;
        mlnWithoutPoint_value = mlnWithoutPoint_value_start;
        slitno_selection = slitno_selection_start;
        CurrSlitno_selection = CurrSlitno_selection_start;
        myFootnoteGroup_value = myFootnoteGroup_value_start;
        footnote1_value = footnote1_value_start;
        mySpatium_value = mySpatium_value_start;
        s_options_enabled = s_options_enabled_start;////----
        tireAndSpatium_value = tireAndSpatium_value_start;
        spationsToSpace_value = spationsToSpace_value_start;
        ProcSpace_selection = ProcSpace_selection_start;
        CurrSpace_selection = CurrSpace_selection_start;
        TwoSpacesDrop_selection = TwoSpacesDrop_selection_start;
        mySpaceListBefore_selection = mySpaceListBefore_selection_start;
        mySpaceListAfter_selection = mySpaceListAfter_selection_start;
        mySlider_value = mySlider_value_start;
        commatire_value = commatire_value_start;
        grekCharStyles_value = grekCharStyles_value_start;
        myCommaAndTire_selection = myCommaAndTire_selection_start;
        shortword_value = shortword_value_start;
        myShortWordSpace_selection = myShortWordSpace_selection_start;
        initials_value = initials_value_start;
        myASPushkinFirstSpace_selection = myASPushkinFirstSpace_selection_start;
        myASPushkinSecondSpace_selection = myASPushkinSecondSpace_selection_start;
        myPushkinASFirstSpace_selection = myPushkinASFirstSpace_selection_start;
        myPushkinASSecondSpace_selection = myPushkinASSecondSpace_selection_start;
        setquotes_value = setquotes_value_start;
        partHE_value = partHE_value_start;
        p_options_enabled = p_options_enabled_start;
        SepIsSpace_value = SepIsSpace_value_start;
        SepIsDefis_value = SepIsDefis_value_start;
        SepIsMinus_value = SepIsMinus_value_start;
        SepIsTire_value = SepIsTire_value_start;
        SepIsDot_value = SepIsDot_value_start;
        InTextSepIsSpace_value = InTextSepIsSpace_value_start;
        InTextSepIsDash_value = InTextSepIsDash_value_start;
        InTextSepIsDot_value = InTextSepIsDot_value_start;
        my11D_value = my11D_value_start;
        myTelNumBreak_value = myTelNumBreak_value_start;
        myOneLineIsOneAbzatz_value = myOneLineIsOneAbzatz_start;
        myQuery_value = myQuery_value_start;
        q_options_enabled = q_options_enabled_start;
        spaces_value = spaces_value_start;
        enters_value = enters_value_start;
        shenters_value = shenters_value_start;
        myPhone_value = myPhone_value_start;
        CurrentQueryInfo = CurrentQuery_start;
        mySpaceAfterTireInDialogIndex = spaceAfterTireInDialog_start;

        MathSignsAreTakedIntoAccountValue = MathSignsAreTakedIntoAccount_value;
        myMathSpaceIndex = myMathSpaceInfo_selection;
        //myMathProcSelectIndex = myMathProcSelectIndex_selection;
        myInfoAboutProcFormulasValue = myInfoAboutProcFormulas_value;
        myFormulaToProcessValue = myFormulaToProcess_value;
        //SetFontTypeInCharStyles_value = SetFontTypeInCharStyles_value_start;
    } // mySetDefaultValues
    ////////////
    function MakeSlashNoBreak(procText, pBar) { // MakeSlashNoBreak()
        var myText = procText;
        var mySlashIndex;
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.findWhat = "(\\d)(" + mySep + ")([\\l\\u]+?\\.{0,1})(/)([\\l\\u]+?\\.{0,1})(" + mySep + "|\\.|,)";
        myFoundSamples = myText.findGrep();
        for (var ii = myFoundSamples.length - 1; ii >= 0; ii--) { // myFoundSamples.length - 1
            try { mySlashIndex = myFoundSamples[ii].contents.search("/") } catch (e) { continue }
            myFoundSamples[ii].characters[mySlashIndex].noBreak = true;
            var tt = myFoundSamples.length - ii;
            pBar.info(" Запрет разрыва единиц измерения по дробной черте ... " + tt + " / " + myFoundSamples.length);
        } // myFoundSamples.length - 1
    } // MakeSlashNoBreak()    
    ///////
    function myCharAfterTelNumber(procText, myCharLine, myNmrSep) { // myCharAfterTelNumber
        var myText = procText;
        var delta = myCharLine.length;
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findChangeTextOptions.includeFootnotes = true;
        app.findTextPreferences.findWhat = " ^9" + "^9" + "^9" + "^9" + "^9" + "^9" + "^9" + "^9" + "^9" + "^9" + "^9" + myCharLine; // ищем пробел и одиннадцать идущих подряд цифр, завершаемые одним или двумя символами, переданными как параметр функции
        myFoundSamples = myText.findText(); //собрана коллекция искомых элементов в статье
        if (myFoundSamples.length != 0) { // myFoundSamples.length !=0
            // цикл по числу элементов коллекции. Движение снизу вверх
            for (j = myFoundSamples.length - 1; j >= 0; j--) { // j >= 0	
                myLine = myFoundSamples[j];
                myLine.insertionPoints[-3 - delta].contents = myNmrSep;
                myLine.insertionPoints[-5 - delta].contents = myNmrSep;
                myLine.insertionPoints[-8 - delta].contents = myNmrSep;
                myLine.insertionPoints[2].contents = myNmrSep;
                myLine.appliedCharacterStyle = myDocument.characterStyles.item("myElevenDigitsTelNumber");
                if (myTelNumBreakFromMenu == 1) { myLine.noBreak = false }
                else { myLine.noBreak = true }
            } // j >= 0
        } // myFoundSamples.length !=0
    } // myCharAfterTelNumber    
    /////////// <<< (c) Константин Смородский
    //~ function myBoldItalicAndIndexSelection() {  // myBoldItalicAndIndexSelection
    //~ 	// выделение цветом текста в нижном и верхнем регистре (каждое начертание будет иметь свой символьный стиль)
    //~ 	// Заменяем верхний индекс форматирования символов на символьный стиль "Superscript" 
    //~ 	findAndApplyCharacterStyle({position: Position.SUPERSCRIPT}, "mySupChars");
    //~ 	// Заменяем нижний индекс форматирования символов на символьный стиль "Subrscript" 
    //~ 	findAndApplyCharacterStyle({position: Position.SUBSCRIPT}, "mySubChars");
    //~ 	// Замена стиля текста со специальными начертаниями
    //~ 	findAndApplyCharacterStyle({fontStyle: "Bold"}, "myBoldChars");
    //~ 	findAndApplyCharacterStyle({fontStyle: "Italic"}, "myItalicChars");
    //~ 	findAndApplyCharacterStyle({fontStyle: "Bold Italic"}, "myBoldItalicChars");
    //~ } // myBoldItalicAndIndexSelection
    // ищет в указанной коллекции элемент по имени
    // если такого не находится, то создает его с указанными параметрами
    function addDocumentCollectionElement(collectionName, elementParameters) {
        var collection = myDocument[collectionName];
        var element = collection.itemByName(elementParameters.name);
        // если такого элемента нет - добавим его
        if (!element.isValid) { // !element.isValid
            element = collection.add(elementParameters.name);

            // копируем параметры
            for (var i in elementParameters) { // var i in ...
                // указанный шрифт может отсутствовать
                // или не содержать указанного начертания
                // тогда здесь произойдет исключение
                try {
                    element[i] = elementParameters[i];
                } catch (e) {
                    alert("Ошибка при добавлении " +
                        elementParameters.name + ": " + e.message);
                }
            } // var i in ...
        } // !element.isValid
        return element;
    }
    //~ // ищет символы по признакам, перечисленным в findTextPreferences
    //~ // и применяет указанный символьный стиль
    //~ function findAndApplyCharacterStyle(findTextPreferences, characterStyleName) { ////
    //~ 	// сброс всех параметров поиска
    //~ 	app.findTextPreferences = NothingEnum.nothing;
    //~ 	
    //~ 	// перенесем указанные параметры поиска
    //~ 	for (var i in findTextPreferences) { ///
    //~ 		app.findTextPreferences[i] = findTextPreferences[i];
    //~ 	} ///
    //~ 	var myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
    //~ 	
    //~ 	// выход если ничего не найдено
    //~ 	if (0 == myFound.length) return;
    //~ 	var characterStyle = myDocument.characterStyles.itemByName(characterStyleName);
    //~ 	
    //~ 	// цикл по числу элементов коллекции. Движение снизу вверх
    //~ 	for (var j = myFound.length; j--; ) { //
    //~   	myFound[j].appliedCharacterStyle = characterStyle;
    //~ 	} //
    //~ } ////
    ///////////   (c) Константин Смородский  >>>

    function myMakeQueLineUsingGREP(myText, myFindPattern, mychangePattern) { // myMakeQueLineUsingGREP
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = false;
        app.findGrepPreferences.findWhat = myFindPattern;
        app.changeGrepPreferences.changeTo = mychangePattern;
        myText.changeGrep();
    } // myMakeQueLineUsingGREP 
    //////////
    function myAllButtonShow(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList) { // myAllButtonShow
        myUpButton.show();
        myDnButton.show();
        myDelButton.show();
        myStartQueriesButton.show();
        myFinishQueriesButton.show();
        mySaveSetButton.show();
        myLoadSetButton.show();
        myTreeAndList.show();
    } // myAllButtonShow
    ////
    function myAllButtonHide(myUpButton, myDnButton, myDelButton, myStartQueriesButton, myFinishQueriesButton, mySaveSetButton, myLoadSetButton, myTreeAndList) { // myAllButtonHide
        myUpButton.hide();
        myDnButton.hide();
        myDelButton.hide();
        myStartQueriesButton.hide();
        myFinishQueriesButton.hide();
        mySaveSetButton.hide();
        myLoadSetButton.hide();
        myTreeAndList.hide();
    } // myAllButtonHide

    function mySearchSymbolChars(procText, SymbolCharsFont) { // mySearchSymbolChars
        var myText = procText;
        // ищем символы гарнитуры Symbol  /*(или другой указанной пользователем гарнитуры) 18/10/2013 -- это исключено */
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = true;
        app.findGrepPreferences.appliedFont = app.fonts.item(SymbolCharsFont);
        app.findGrepPreferences.findWhat = "\.";
        myFoundSamples = myText.findGrep();
        if (myFoundSamples.length != 0) { // myFoundSamples.length != 0
            // цикл по числу элементов коллекции. Движение снизу вверх
            for (var j = myFoundSamples.length - 1; j >= 0; j--) { // j=myFoundSamples.length-1	
                var myLine = myFoundSamples[j];
                if (myLine.characters[0].appliedCharacterStyle.name == "mySupChars") { // mySupChars
                    myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySupSymbolChars");
                    continue;
                } // mySupChars
                if (myLine.characters[0].appliedCharacterStyle.name == "mySubChars") { // mySubChars
                    myLine.characters[0].appliedCharacterStyle = myDocument.characterStyles.item("mySubSymbolChars");
                    continue;
                } // mySubChars
                //if (myLine.appliedCharacterStyle.name == "[None]") myLine.characters[0] .appliedCharacterStyle = myDocument.characterStyles.item("mySpecialChars");
                //if (myLine.appliedCharacterStyle.name == myDocument.characterStyles[0].name) myLine.appliedCharacterStyle = myDocument.characterStyles.item("mySymbolChars");
                myLine.appliedCharacterStyle = myDocument.characterStyles.item("mySymbolChars");
            } // j=myFoundSamples.length-1
        } // myFoundSamples.length != 0 
    } //  // mySearchSymbolChars
    ////////////////

    //~ function myRemoveSpacesInIndex() {  // myRemoveSpacesInIndex
    //~ // удаляем пробелы, если они есть в конце верхнего и нижнего индекса
    //~ app.findTextPreferences = NothingEnum.nothing;
    //~ app.changeTextPreferences = NothingEnum.nothing;
    //~ app.findTextPreferences.position = Position.SUPERSCRIPT; // маска поиска
    //~ myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
    //~ if (myFound.length != 0) { //L5
    //~ 	for (j=myFound.length-1; j >= 0; j--){ // for	
    //~          myLine = myFound[j];
    //~          a=0;
    //~          var t = 1;
    //~          var ll = myLine.length;
    //~        //  try {
    //~              while (myLine.characters[ll-t].contents == " ") { // while
    //~                     myLine.characters[ll-t].remove();
    //~                     t++;
    //~                } // while
    //~            a=0;
    //~ 	} // for
    //~ } // if
    //~ // Заменяем нижний индекс форматирования символов на символьный стиль "Subrscript" 
    //~ app.findTextPreferences = NothingEnum.nothing;
    //~ app.changeTextPreferences = NothingEnum.nothing;
    //~ app.findTextPreferences. position = Position.SUBSCRIPT; // маска поиска
    //~ myFound = myText.findText(); //собрана коллекция искомых элементов в статье.
    //~ if (myFound.length != 0) { //L5
    //~ 	for (j=myFound.length-1; j >= 0; j--){ // for	
    //~          myLine = myFound[j];
    //~          a=0;
    //~          var t = 1;
    //~          var ll = myLine.length;
    //~          while (myLine.characters[ll-t].contents == " ") { // while
    //~                     myLine.characters[ll-t].remove();
    //~                     t++;
    //~             } // while
    //~ 	} // for
    //~ } // if
    //~ } // myRemoveSpacesInIndex
    ///////////////
    function mySimpleChange(procText, myFindWhat, myChahgeTo) { // mySimpleChange  //замена одной последовательности знаков на другую
        var myText = procText;
        app.findTextPreferences = NothingEnum.nothing;
        app.changeTextPreferences = NothingEnum.nothing;
        app.findTextPreferences.findWhat = myFindWhat;
        app.changeTextPreferences.changeTo = myChahgeTo;
        myText.changeText();
    } // mySimpleChange
    /////////
    function GetTheValue(TheArray) { // GetTheValue
        var wdth = $.screens[0].right - $.screens[0].left;
        var rez;
        ValueFound = false;
        for (var i = 1; i < TheArray.length; i++) { // i++
            if (TheArray[i].split(",")[0] != wdth) continue;
            if (TheArray[i].split(",")[0] == wdth) { // if
                ValueFound = true;
                break;
            } // if
        } // i++
        if (ValueFound == true) rez = Number(TheArray[i].split(",")[1]);
        else rez = Number(TheArray[0]);
        return rez;
    } // GetTheValue
    ///
    function mySimpleFindChangeUsingGREP(myProcText, myFindPattern, mychangePattern) { // mySimpleFindChangeUsingGREP
        //  if (myProcText.length == 0) return;
        app.findGrepPreferences = NothingEnum.nothing;
        app.changeGrepPreferences = NothingEnum.nothing;
        app.findChangeGrepOptions.includeFootnotes = false;
        app.findGrepPreferences.findWhat = myFindPattern;
        app.changeGrepPreferences.changeTo = mychangePattern;
        myProcText.changeGrep();
    } // mySimpleFindChangeUsingGREP 
    /////////
    function showSelectionByColor(selCharStyle) { // showSelectionByColor
        // цикл по числу элементов коллекции. Движение снизу вверх
        for (var j = 0; j < myFound.length; j++) { // N5        
            myLine = myFound[j];
            if (noParagraphsFromMenu == true) {
                // полные выделенные абзацы не учитываются: # может быть выделено несколько абзацев; песледний перевод строки может быть частью выделения, а может и не быть #
                if (myLine.paragraphs.length > 1) {
                    if (myLine.index == myLine.paragraphs[0].index) continue; // 12.06.14 - в случае выделения нескольких абзацев контролируется только случай, когда многострочное выделение не совпадает с началом абзаца. В следующих обновлениях подумаю, как проверять и совпадение последнего символа выделения с последним символом последнего абзаца, который содержит это выделение. Что-то с .characters[-1].index сходу не получилось. Ненадежно работает :(
                }
                //if (myLine.characters[0].index == myLine.characters[0].paragraphs[0].characters[0].index && (myLine.characters[-1].index == "\r" || myLine.characters[-1].index == myLine.characters[0].paragraphs[0].characters[-2].index)) continue;
                //if (myLine.characters[0].index == myLine.characters[0].paragraphs[0].characters[0].index && (myLine.characters[-1].index == myLine.characters[0].paragraphs[0].characters[-1].index || myLine.characters[-1].index == myLine.characters[0].paragraphs[0].characters[-2].index)) continue;
                else if /* myLine.paragraphs.length == 1 */ (myLine.length == myLine.paragraphs[0].length || myLine.length + 1 == myLine.paragraphs[0].length) continue;
            }
            for (k = myLine.length - 1; k >= 0; k--) { // k
                myCharInLine = myLine.characters[k];
                if (myCharInLine.fillColor.name == "myInfoColor") continue;
                if (myCharInLine.appliedCharacterStyle.name == myDocument.characterStyles[0].name) myCharInLine.appliedCharacterStyle = myDocument.characterStyles.item(selCharStyle);
            } // k
        } //N5
    } // showSelectionByColor
    ////////////////////////////////////////////////////////////
    /////////    <<<<    (c) Борис Кащеев 
    function getParagraphStyleNames() {
        var result = [];
        var myParagraphStyles = app.activeDocument.allParagraphStyles;
        var myParagraphStyleName, obj;
        for (var i = 0; i < myParagraphStyles.length; i++) {
            myParagraphStyleName = myParagraphStyles[i].name;
            obj = myParagraphStyles[i];
            while (obj.parent instanceof ParagraphStyleGroup) {
                myParagraphStyleName = obj.parent.name + ":" + myParagraphStyleName;
                obj = obj.parent;
            }
            result.push(myParagraphStyleName);
        } // for
        // result.shift(); // удаление стиля No Paragraph Style
        return result;
    } // fnc
    //////
    function getMaxStyleNameLength(myNames) {
        var l = myNames[0].length;
        var cur;
        for (var i = 1; i < myNames.length; i++) {
            cur = myNames[i].length
            if (cur > l) l = cur;
        } //for
        return l;
    } // fnc
    ////
    function getParagraphStyleByName(myStyleName) {
        var myParagraphStyles = app.activeDocument.allParagraphStyles;
        var myParagraphStyleName, obj;
        for (var i = 0; i < myParagraphStyles.length; i++) {
            myParagraphStyleName = myParagraphStyles[i].name;
            obj = myParagraphStyles[i];
            while (obj.parent instanceof ParagraphStyleGroup) {
                myParagraphStyleName = obj.parent.name + ":" + myParagraphStyleName;
                obj = obj.parent;
            }
            if (myParagraphStyleName == myStyleName) return myParagraphStyles[i];
        } // for
    } // fnc   
    ///// (c) Борис Кащеев >>>>>>>
    ///////////////////////////////////////
    function myInfoAboutSites() { // myInfoAboutSites
        /*    
        var myWndw = new Window ("dialog", "Программа подготовки текста к вёрстке");
        myWndw.orientation = "column";
        var myMessage = myWndw.add ("statictext");
        myMessage.text = "DoTextOK (" + myCurrentVersionData_xx_xx_xx + ") | © Михаил Иванюшин | m.ivanyushin@gmail.com";
        var myButtonGroup = myWndw.add ("group");
        myButtonGroup.orientation = "row";
        myButtonGroup.alignment = "left";
        //myButtonGroup.alignChildren = ["fill", "fill"];
        var SiteWidth;
        SiteWidth = [0,0,GetTheValue(IndesignRuButtonSize),30];
        YT = [0,0,65,30];
        FB = [0,0,35,30];
        VK = [0,0,35,30];
        var ButtonInfoOKWidth;
        ButtonInfoOKWidth = [0,0,GetTheValue(ButtonInfoOKSize),30];
        ///---
        var JumpToSiteButton = myButtonGroup.add ("button",  SiteWidth, "adobeindesign.ru");
        //var JumpToSiteButton = myButtonGroup.add ("button",  SiteWidth, "WWW");
        //JumpToSiteButton.alignment = "left"; 
        //JumpToSiteButton.helpTip = "adobeindesign.ru\nЗаходите! Тут море информации по работе в InDesign";
        //var SpaceAfterButton = myAllButtonsAndCopyrightInfo.add ("statictext");
        //SpaceAfterButton = myWhiteSpace;
        ///---
        //~ var myYotube = File (decodeURI(myScriptFolder + "/Picts/" + "YouTube-logo.png"));
        //~ var myFacebook = File (decodeURI(myScriptFolder + "/Picts/" + "facebook.png"));
        //~ var myVkontakte = File (decodeURI(myScriptFolder + "/Picts/" + "vkontakte.png"));
        ///---
        try { var myYoutubeButton = myButtonGroup.add("iconbutton", YT, myYotube); } catch (e) { var myYoutubeButton = myButtonGroup.add ("button", YT, "Youtube"); } 
        //myYoutubeButton.alignment = "center";
        myYoutubeButton.helpTip = "http://goo.gl/RSSuK8";
        try { var myFacebookButton = myButtonGroup.add("iconbutton", FB, myFacebook); } catch (e) { var myFacebookButton = myButtonGroup.add ("button", FB, "FB"); } 
        //myFacebookButton.alignment = "center";
        myFacebookButton.helpTip = "https://www.facebook.com/longliveindesign";
        try { var myVkontakteButton = myButtonGroup.add("iconbutton", VK, myVkontakte); } catch (e) { var myVkontakteButton = myButtonGroup.add ("button", VK, "VK"); } 
        myVkontakteButton.helpTip = "http://vk.com/longliveindesign";
        //myVkontakteButton.alignment = "center";
        var myMesOKButton = myButtonGroup.add ("button", ButtonInfoOKWidth, "OK");   
        //myMesOKButton.alignment = "right";
        JumpToSiteButton.onClick = function () { // JumpToSiteButton.onClick   
        rr = openInBrowser("www.adobeindesign.ru")
        } // JumpToSiteButton.onClick
        myYoutubeButton.onClick = function () { // myYoutubeButton.onClick   
        rr = openInBrowser("http://goo.gl/RSSuK8")
        } // myYoutubeButton.onClick
        ///=-
        myFacebookButton.onClick = function () { // myFacebookButton.onClick   
        rr = openInBrowser("https://www.facebook.com/longliveindesign")
        } // myFacebookButton.onClick
        ///=-
        myVkontakteButton.onClick = function () { // myVkontakteButton.onClick   
        rr = openInBrowser("http://vk.com/longliveindesign")
        } // myVkontakteButton.onClick
        myWndw.show (); 
        */
        openInBrowser("https://dotextok.ru");
    } // myInfoAboutSites()
    ///// 
    function NewPrompt(TextAboutAction, myProgramTitulWholeText, SuperFastProc, WrongState, StateOfStoriesProcesing1, StateOfStoriesProcesing2, StateOfStoriesProcesing3, StateOfStoriesProcesing4, StateOfStoriesProcesing5) { // NewPrompt
        var myBttnSize = [0, 0, 555, 30];
        var mySearchPlus = TextAboutAction.search("\\+");
        var wp = new Window("dialog", myProgramTitulWholeText, undefined, { closeButton: true });
        //wp.alignChildren = "left";
        wp.alignChildren = ["fill", "fill"];
        var npline1 = wp.add("statictext", undefined, StateOfStoriesProcesing1);
        var npline2 = wp.add("statictext", undefined, StateOfStoriesProcesing2);
        var separator_p1 = wp.add("panel"); // Помещаем на экран горизонтальную линию.  Для программы этот параметр высота, но по сути это ширина линии
        separator_p1.minimumSize.height = separator_p1.maximumSize.height = 1;
        if (WrongState > 0) { // WrongState
            var npline0 = wp.add("statictext", undefined, "Внимание!");
            var npline3 = wp.add("statictext", undefined, StateOfStoriesProcesing3);
            var npline4 = wp.add("statictext", undefined, StateOfStoriesProcesing4);
            var npline5 = wp.add("statictext", undefined, StateOfStoriesProcesing5);
            var separator_p2 = wp.add("panel");
            separator_p2.minimumSize.height = separator_p2.maximumSize.height = 1;
        } // WrongState
        if (mySearchPlus != -1) { // mySearchPlus != -1
            var ContProc = wp.add("button", myBttnSize, "Продолжить обработку", { name: "ok" });  // будет возвращен минус
            var RepeatProc = wp.add("button", myBttnSize, "Начать обработку заново");  // будет возвращен плюс
            ////
            ContProc.onClick = function () { // ContProc.onClick
                wp.close();
                SuperFastProc = "-";
                return;
            } // ContProc.onClick
            ////
        } // mySearchPlus != -1
        else var RepeatProc = wp.add("button", myBttnSize, "Начать обработку", { name: "ok" });  // будет возвращен плюс
        myCnlBtn = wp.add("button", myBttnSize, "Отменить обработку всех статей", { name: "cancel" });
        ////
        RepeatProc.onClick = function () { // RepeatProc.onClick
            wp.close();
            SuperFastProc = "+";
            return;
        } // RepeatProc.onClick  
        ///
        myCnlBtn.onClick = function () { // myCnlBtn.onClick
            wp.close();
            exit();
        } // myCnlBtn.onClick  
        //if (wp.show() == 2) exit();
        return SuperFastProc;
    } // NewPrompt
    ///
} // main
main();
/////
function myFile(myFileName) {
    var myScriptFile = myGetScriptPath();
    var myScriptFolder = decodeURI(myScriptFile.path);
    var myFilePath = decodeURI(myScriptFolder + "/" + myFileName);
    return myFilePath;
} //myFile
//
function myGetScriptPath() {
    try {
        return app.activeScript;
    }
    catch (myError) {
        return File(myError.fileName);
    }
} //myGetScriptPath()
//////////
// Поначалу была просто нерешаемая проблема, как добиться, чтобы в СС2015 бабочка и другие рисунки на кнопках были по центру, как это есть в версиях вплоть до СС2015.
// идея найдена тут: http://www.indiscripts.com/post/2011/04/sprite-buttons-in-scriptui
////
/// Функция makeImageButton - сделана на базе этого скрипта Марка Аутрета.
// imageButton = makeImageButton (myPngButton, buttonBorder, buttonInset, winLink, imageButtonAction)
// myPngButton -- имя файла с видом кнопки,
// buttonBorder - если true, вокруг рисунка нужна рамка
// borderInset -- величина отступа вокруг картинки кнопки (отступ будет добавлен, даже если buttonBorder = false)
// winLink -- объект в описании окна, с которым будет связана эта кнопка
// imageButtonAction -- название функции, которая будет выполнена при щелчке на кнопке.
//=-
// imageButton -- процедура возвращает ссылку на созданную кнопку
///
function makeImageButton(myPngButton, buttonBorder, buttonInset, winLink, imageButtonAction) { // makeImageButton
    ///
    // InDesign CC Flag
    const CC_FLAG = +(9 <= parseFloat(app.version));
    ///
    // ScriptUI Image Offset Fixer in InDesign CS6 and earlier
    // (This bug has been solved in CC i.e. ScriptUI 6.2.x)
    const FIX_OFFSET = CC_FLAG ? 0 : 1;
    ///
    // Force an Image widget to repaint (= onDraw trigger)
    // CS4-CS6  ->  just reassigning this.size
    // CC             ->  we need to temporarily *change* the size
    // Note: using layout.layout(1) would not work anymore in CC
    // ---
    // Create the UI
    if (buttonBorder) var winImageButton = winLink.add("panel");
    else var winImageButton = winLink.add("group");
    imageButton = winImageButton.add('image', undefined, myPngButton);
    imageSize = imageButton.image.size;
    Image.prototype.refresh = CC_FLAG ?
        function () {
            var wh = this.size;
            this.size = [1 + wh[0], 1 + wh[1]];
            this.size = [wh[0], wh[1]];
            wh = null;
        } :
        function () { this.size = [this.size[0], this.size[1]]; };
    // Window settings
    try { winImageButton.margins = buttonInset; } catch (e) { }
    winImageButton.alignChildren = ['center', 'center'];
    imageButton.size = [imageSize[0], imageSize[1]];
    imageButton.onDraw = function () {
        var dy = 0 + FIX_OFFSET;
        this.graphics.drawImage(this.image, 0, -dy);
        // winLink.graphics.backgroundColor = winLink.graphics.newBrush(0, [.92,.94,.96,1]);
    };
    var mouseEventHandler = function (ev) { // mouseEventHandler
        if (ev.type == 'mouseover') winImageButton.graphics.backgroundColor = winImageButton.graphics.newBrush(0, defSelColor);
        //else winImageButton.graphics.backgroundColor = winImageButton.graphics.newBrush(0, [.92,.94,.96,1]); 
        else winImageButton.graphics.backgroundColor = winImageButton.graphics.newBrush(0, defBgColor);
        this.refresh();
    } // mouseEventHandler
    ///
    imageButton.addEventListener('mouseover', mouseEventHandler);
    imageButton.addEventListener('mousedown', mouseEventHandler);
    imageButton.addEventListener('mouseup', mouseEventHandler);
    imageButton.addEventListener('mouseout', mouseEventHandler);
    // Let's go!
    imageButton.addEventListener('click', function () { imageButtonAction() });
    ///
    return imageButton;
} // makeImageButton
///
// app.activeWindow.activePage = app.selection[0].parentTextFrames[0].parentPage;
// " Тире, минус или дефис между цифрами"

/*

Флажок обработки концевых сносок доступен, только когда курсор в тексте, т.е. ничего не выбрано.
В этом случае будет обработан текст по фрагментам, а потом текст концевых сносок.

*/